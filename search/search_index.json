{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Hamilton-Jacobi-based Proximal Operator","text":"<p> Stanley Osher, Howard Heaton, and Samy Wu Fung</p> <p>Summary</p> <p>We give a formula for estimating proximal operators from (possibly noisy) observations of objective function values.</p> <p>Key Steps</p> <ul> <li> Sample points \\(\\mathsf{y^i}\\) (via a Gaussian) about the input \\(\\mathsf{x}\\)</li> <li> Evaluate function \\(\\mathsf{f}\\) at each point \\(\\mathsf{y^i}\\)</li> <li> Estimate proximal by using softmax to combine the values for \\(\\mathsf{f(y^i)}\\) and \\(\\mathsf{y^i}\\)</li> </ul> <p> Preprint  Reprint  Slides  Code  </p> <p> <p></p> <p></p> <p>Abstract</p> <p>First-order optimization algorithms are widely used today. Two standard building blocks in these algorithms are proximal operators (proximals) and gradients. Although gradients can be computed for a wide array of functions, explicit proximal formulas are known for only limited classes of functions. We provide an algorithm, HJ-Prox, for accurately approximating such proximals. This is derived from a collection of relations between proximals, Moreau envelopes, Hamilton\u2013Jacobi (HJ) equations, heat equations, and Monte Carlo sampling. In particular, HJ-Prox smoothly approximates the Moreau envelope and its gradient. The smoothness can be adjusted to act as a denoiser. Our approach applies even when functions are accessible only by (possibly noisy) black box samples. We show that HJ-Prox is effective numerically via several examples.</p> <p>Citation</p> <pre><code>@article{osher2023hamilton,\n         title={{A Hamilton-Jacobi-based proximal operator}},\n         author={Osher, Stanley and Heaton, Howard and Fung, Samy Wu},\n         journal={{Proceedings of the National Academy of Sciences}},\n         year={2023},\n         volume={120},\n         number={14}\n}\n</code></pre> <p> Contact Us </p>"},{"location":"exp-l1-least-squares/","title":"L1 + Least Squares","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\nfrom google.colab import drive\ndrive.mount('/content/drive')\nsys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')\n\nfrom hj_prox import *\nfrom functions import *\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport matplotlib.pyplot as plt\nimport time\n\ntorch.set_default_dtype(torch.float64)\ntorch.manual_seed(0)\ndevice = 'cuda:0'\n</pre> import os import sys from google.colab import drive drive.mount('/content/drive') sys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')  from hj_prox import * from functions import * import numpy as np import torch import torch.nn as nn import matplotlib.pyplot as plt import time  torch.set_default_dtype(torch.float64) torch.manual_seed(0) device = 'cuda:0' <pre>Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n</pre> In\u00a0[2]: Copied! <pre>dim = 1000\nA = torch.randn(int(dim/2), dim, device=device)\n# x_true = torch.zeros(dim,1, device=device)\n# x_true[500:600] = torch.randn(100, 1, device=device) \n# b = A.matmul(x_true)\nb = torch.randn(int(dim/2), 1, device=device)\nlambd = 1.0\nstep_size = 5e-4\n\ndef f(x, A, lambd = 1e-2): \n  # assumes x has shape n_samples x n_features\n  temp = A.matmul(x.permute(1,0)) - b # has n_features x n_samples\n  temp = temp.permute(1,0) # permute back to n_samples x n_features\n  return 0.5*torch.norm(temp, dim=1)**2 + lambd*torch.norm(x, p=1, dim=1)\n\n\n# ---------------------------------------------------------------------------------------------------\n# ISTA\n# ---------------------------------------------------------------------------------------------------\ndef ista(x0, f, A, lambd, step_size, max_iters, tol=1e-6, verbose=True):\n\n  assert len(x0.shape)==2 and x0.shape[1]==1\n  xk = x0\n  xk_GD = x0 #########################################################\n  fk_hist = torch.zeros(max_iters)\n  norm_diff_hist = torch.zeros(max_iters)\n  fk_hist_GD = torch.zeros(max_iters)\n\n  for i in range(max_iters):\n\n    start_time = time.time()\n    yk = xk - step_size * A.t().matmul(A.matmul(xk)-b)\n    yk = l1_norm_prox(yk, t=lambd*step_size)\n\n    xk_GD =  xk_GD - step_size * A.t().matmul(A.matmul(xk_GD)-b) ######################################################\n\n    norm_diff = torch.norm(yk - xk)\n    fk = f(yk.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1)\n    fk_GD = f(xk_GD.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1) ##########################################\n\n    xk = yk.clone()\n\n    fk_hist[i] = fk.cpu()\n    fk_hist_GD[i] = fk_GD.cpu()\n    norm_diff_hist[i] = norm_diff.cpu()\n    \n    end_time = time.time()\n    iter_time = end_time - start_time\n\n    if verbose:\n      print('iter = ', i+1, ', f(xk) = ', fk.cpu(), ', norm_diff = ', norm_diff.cpu(), ', time = ', iter_time, fk_GD)\n\n    if norm_diff &lt; tol:\n      fk_hist = fk_hist[0:i]\n      norm_diff_hist = norm_diff_hist[0:i]\n      fk_hist_GD = fk_hist_GD[0:i]\n      break\n\n  return xk, fk_hist, norm_diff_hist, fk_hist_GD\n\n# ---------------------------------------------------------------------------------------------------\n# HJ ISTA\n# ---------------------------------------------------------------------------------------------------\ndef hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=100, delta=1e-1, tol=1e-6, verbose=True):\n\n  print('LAMBD = ', lambd)\n\n  assert len(x0.shape)==2 and x0.shape[1]==1\n  xk = x0\n  fk_hist = torch.zeros(max_iters)\n  norm_diff_hist = torch.zeros(max_iters)\n\n  for i in range(max_iters):\n\n    start_time = time.time()\n    yk = xk - step_size * A.t().matmul(A.matmul(xk)-b)\n    yk = yk, linesearch_iters, temo = compute_prox(yk, lambd*step_size, l1_norm, delta=delta, int_samples=int_samples, alpha=1.0, device=device)\n\n    norm_diff = torch.norm(yk - xk)\n    fk = f(xk.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1)\n\n    xk = yk\n\n    fk_hist[i] = fk.cpu()\n    norm_diff_hist[i] = norm_diff.cpu()\n    \n    end_time = time.time()\n    iter_time = end_time - start_time\n\n    if verbose:\n      print('iter = ', i, ', f(xk) = ', fk, ', norm_diff = ', norm_diff, ', linesearch = ', linesearch_iters, ', time = ', iter_time)\n\n    # if norm_diff &lt; tol:\n    #   fk_hist = fk_hist[0:i]\n    #   norm_diff_hist = norm_diff_hist[0:i]\n    #   break\n\n  return xk, fk_hist, norm_diff_hist\n</pre> dim = 1000 A = torch.randn(int(dim/2), dim, device=device) # x_true = torch.zeros(dim,1, device=device) # x_true[500:600] = torch.randn(100, 1, device=device)  # b = A.matmul(x_true) b = torch.randn(int(dim/2), 1, device=device) lambd = 1.0 step_size = 5e-4  def f(x, A, lambd = 1e-2):    # assumes x has shape n_samples x n_features   temp = A.matmul(x.permute(1,0)) - b # has n_features x n_samples   temp = temp.permute(1,0) # permute back to n_samples x n_features   return 0.5*torch.norm(temp, dim=1)**2 + lambd*torch.norm(x, p=1, dim=1)   # --------------------------------------------------------------------------------------------------- # ISTA # --------------------------------------------------------------------------------------------------- def ista(x0, f, A, lambd, step_size, max_iters, tol=1e-6, verbose=True):    assert len(x0.shape)==2 and x0.shape[1]==1   xk = x0   xk_GD = x0 #########################################################   fk_hist = torch.zeros(max_iters)   norm_diff_hist = torch.zeros(max_iters)   fk_hist_GD = torch.zeros(max_iters)    for i in range(max_iters):      start_time = time.time()     yk = xk - step_size * A.t().matmul(A.matmul(xk)-b)     yk = l1_norm_prox(yk, t=lambd*step_size)      xk_GD =  xk_GD - step_size * A.t().matmul(A.matmul(xk_GD)-b) ######################################################      norm_diff = torch.norm(yk - xk)     fk = f(yk.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1)     fk_GD = f(xk_GD.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1) ##########################################      xk = yk.clone()      fk_hist[i] = fk.cpu()     fk_hist_GD[i] = fk_GD.cpu()     norm_diff_hist[i] = norm_diff.cpu()          end_time = time.time()     iter_time = end_time - start_time      if verbose:       print('iter = ', i+1, ', f(xk) = ', fk.cpu(), ', norm_diff = ', norm_diff.cpu(), ', time = ', iter_time, fk_GD)      if norm_diff &lt; tol:       fk_hist = fk_hist[0:i]       norm_diff_hist = norm_diff_hist[0:i]       fk_hist_GD = fk_hist_GD[0:i]       break    return xk, fk_hist, norm_diff_hist, fk_hist_GD  # --------------------------------------------------------------------------------------------------- # HJ ISTA # --------------------------------------------------------------------------------------------------- def hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=100, delta=1e-1, tol=1e-6, verbose=True):    print('LAMBD = ', lambd)    assert len(x0.shape)==2 and x0.shape[1]==1   xk = x0   fk_hist = torch.zeros(max_iters)   norm_diff_hist = torch.zeros(max_iters)    for i in range(max_iters):      start_time = time.time()     yk = xk - step_size * A.t().matmul(A.matmul(xk)-b)     yk = yk, linesearch_iters, temo = compute_prox(yk, lambd*step_size, l1_norm, delta=delta, int_samples=int_samples, alpha=1.0, device=device)      norm_diff = torch.norm(yk - xk)     fk = f(xk.permute(1,0), A, lambd=lambd) # need to input xk with dimensions (n_samples x 1)      xk = yk      fk_hist[i] = fk.cpu()     norm_diff_hist[i] = norm_diff.cpu()          end_time = time.time()     iter_time = end_time - start_time      if verbose:       print('iter = ', i, ', f(xk) = ', fk, ', norm_diff = ', norm_diff, ', linesearch = ', linesearch_iters, ', time = ', iter_time)      # if norm_diff &lt; tol:     #   fk_hist = fk_hist[0:i]     #   norm_diff_hist = norm_diff_hist[0:i]     #   break    return xk, fk_hist, norm_diff_hist In\u00a0[3]: Copied! <pre>x0 = torch.randn(A.shape[1], 1, device=device)\n\n# Compute numerical \"true\" solution f_star\nstart_time_ista = time.time()\nxopt_ista, fk_ista_hist, norm_diff_ista_hist, fk_GD_hist = ista(x0, f, A, lambd, step_size, int(1e4), verbose=False)\nend_time_ista = time.time()\n\ntime_ista = end_time_ista - start_time_ista\nprint('ista finished running after ', time_ista)\n</pre> x0 = torch.randn(A.shape[1], 1, device=device)  # Compute numerical \"true\" solution f_star start_time_ista = time.time() xopt_ista, fk_ista_hist, norm_diff_ista_hist, fk_GD_hist = ista(x0, f, A, lambd, step_size, int(1e4), verbose=False) end_time_ista = time.time()  time_ista = end_time_ista - start_time_ista print('ista finished running after ', time_ista) <pre>ista finished running after  6.848653554916382\n</pre> In\u00a0[4]: Copied! <pre>f_star = min(fk_ista_hist); print('f_star = ', f_star)\n</pre> f_star = min(fk_ista_hist); print('f_star = ', f_star) <pre>f_star =  tensor(19.8150)\n</pre> In\u00a0[6]: Copied! <pre>max_iters = int(1e4)\n</pre> max_iters = int(1e4) In\u00a0[7]: Copied! <pre># Average runs over 30 trials: standalone\nn_trials = 1\nsample_array = [int(1e2), int(1e3), int(1e4)]\n\nxopt_HJ_ista_array = torch.zeros(len(sample_array), xopt_ista.shape[0], xopt_ista.shape[1])\nfk_HJ_ista_hist_array = torch.zeros(len(sample_array), max_iters)\nnorm_diff_HJ_ista_hist_array = torch.zeros(len(sample_array), max_iters)\n\nfor sample_index in range(len(sample_array)):\n  print('Number of Samples =', sample_array[sample_index])\n  for i in range(n_trials):\n    start_time_hj_ista = time.time()\n    current_samples = sample_array[sample_index]\n    xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp = hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=current_samples, delta=1.0, verbose=False)\n    end_time_hj_ista = time.time()\n    time_hj_ista = end_time_hj_ista - start_time_hj_ista\n    print('trial ', i+1, ' finished after', time_hj_ista)\n    \n    if i==0:\n      xopt_HJ_ista, fk_HJ_ista_hist, norm_diff_HJ_ista_hist = xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp\n    else:\n      xopt_HJ_ista = xopt_HJ_ista + xopt_HJ_ista_temp\n      fk_HJ_ista_hist = fk_HJ_ista_hist + fk_HJ_ista_hist_temp\n      norm_diff_HJ_ista_hist = norm_diff_HJ_ista_hist + norm_diff_HJ_ista_hist_temp\n\n  xopt_HJ_ista_array[sample_index, :, :] = xopt_HJ_ista/n_trials\n  fk_HJ_ista_hist_array[sample_index, :] = fk_HJ_ista_hist/n_trials\n  norm_diff_HJ_ista_hist_array[sample_index, :] = norm_diff_HJ_ista_hist/n_trials\n</pre> # Average runs over 30 trials: standalone n_trials = 1 sample_array = [int(1e2), int(1e3), int(1e4)]  xopt_HJ_ista_array = torch.zeros(len(sample_array), xopt_ista.shape[0], xopt_ista.shape[1]) fk_HJ_ista_hist_array = torch.zeros(len(sample_array), max_iters) norm_diff_HJ_ista_hist_array = torch.zeros(len(sample_array), max_iters)  for sample_index in range(len(sample_array)):   print('Number of Samples =', sample_array[sample_index])   for i in range(n_trials):     start_time_hj_ista = time.time()     current_samples = sample_array[sample_index]     xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp = hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=current_samples, delta=1.0, verbose=False)     end_time_hj_ista = time.time()     time_hj_ista = end_time_hj_ista - start_time_hj_ista     print('trial ', i+1, ' finished after', time_hj_ista)          if i==0:       xopt_HJ_ista, fk_HJ_ista_hist, norm_diff_HJ_ista_hist = xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp     else:       xopt_HJ_ista = xopt_HJ_ista + xopt_HJ_ista_temp       fk_HJ_ista_hist = fk_HJ_ista_hist + fk_HJ_ista_hist_temp       norm_diff_HJ_ista_hist = norm_diff_HJ_ista_hist + norm_diff_HJ_ista_hist_temp    xopt_HJ_ista_array[sample_index, :, :] = xopt_HJ_ista/n_trials   fk_HJ_ista_hist_array[sample_index, :] = fk_HJ_ista_hist/n_trials   norm_diff_HJ_ista_hist_array[sample_index, :] = norm_diff_HJ_ista_hist/n_trials <pre>Number of Samples = 100\nLAMBD =  1.0\ntrial  1  finished after 10.023954629898071\nNumber of Samples = 1000\nLAMBD =  1.0\ntrial  1  finished after 8.753089904785156\nNumber of Samples = 10000\nLAMBD =  1.0\ntrial  1  finished after 11.900594472885132\n</pre> In\u00a0[9]: Copied! <pre># plotting parameters\ntitle_fontsize = 22\nfontsize       = 20\nfig1 = plt.figure()\nmy_blue = '#1f77b4'\nmy_orange = '#F97306'\n\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nf_star = 0.0\n\nax.semilogy(fk_ista_hist[0:max_iters] - f_star, linewidth=5, color=my_orange)\nax.semilogy(fk_GD_hist[0:max_iters] - f_star, linewidth=5, color='tab:brown')\nax.semilogy(fk_HJ_ista_hist_array[0,:] - f_star, '--', linewidth=5, color=my_blue)\nax.semilogy(fk_HJ_ista_hist_array[1,:] - f_star, '--', linewidth=5, color='tab:green')\nax.semilogy(fk_HJ_ista_hist_array[2,:] - f_star, '--', linewidth=5, color='tab:purple')\n\n# fig1.set_figwidth(5.5)\n# fig1.set_figheight(5.4)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['ISTA', 'Gradient Descent', 'HJ-ISTA 100 Samples', 'HJ-ISTA 1K Samples', 'HJ-ISTA 10K Samples'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left')\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'ISTA_sample_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> # plotting parameters title_fontsize = 22 fontsize       = 20 fig1 = plt.figure() my_blue = '#1f77b4' my_orange = '#F97306'  fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  f_star = 0.0  ax.semilogy(fk_ista_hist[0:max_iters] - f_star, linewidth=5, color=my_orange) ax.semilogy(fk_GD_hist[0:max_iters] - f_star, linewidth=5, color='tab:brown') ax.semilogy(fk_HJ_ista_hist_array[0,:] - f_star, '--', linewidth=5, color=my_blue) ax.semilogy(fk_HJ_ista_hist_array[1,:] - f_star, '--', linewidth=5, color='tab:green') ax.semilogy(fk_HJ_ista_hist_array[2,:] - f_star, '--', linewidth=5, color='tab:purple')  # fig1.set_figwidth(5.5) # fig1.set_figheight(5.4)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['ISTA', 'Gradient Descent', 'HJ-ISTA 100 Samples', 'HJ-ISTA 1K Samples', 'HJ-ISTA 10K Samples'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left') ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'ISTA_sample_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-9-4a7a49eff751&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> In\u00a0[10]: Copied! <pre># Average runs over 30 trials: standalone\ndelta_array = [1e-2, 1e-1, 1e0]\n\nxopt_HJ_ista_array = torch.zeros(len(delta_array), xopt_ista.shape[0], xopt_ista.shape[1])\nfk_HJ_ista_hist_array = torch.zeros(len(delta_array), max_iters)\nnorm_diff_HJ_ista_hist_array = torch.zeros(len(delta_array), max_iters)\n\nfor delta_index in range(len(delta_array)):\n  print('Delta Index =', delta_array[delta_index])\n  for i in range(n_trials):\n    start_time_hj_ista = time.time()\n    current_delta = delta_array[delta_index]\n    xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp = hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=int(1e3), delta=current_delta, verbose=False)\n    end_time_hj_ista = time.time()\n    time_hj_ista = end_time_hj_ista - start_time_hj_ista\n    print('trial ', i+1, ' finished after', time_hj_ista)\n      \n    if i==0:\n      xopt_HJ_ista, fk_HJ_ista_hist, norm_diff_HJ_ista_hist = xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp\n    else:\n      xopt_HJ_ista = xopt_HJ_ista + xopt_HJ_ista_temp\n      fk_HJ_ista_hist = fk_HJ_ista_hist + fk_HJ_ista_hist_temp\n      norm_diff_HJ_ista_hist = norm_diff_HJ_ista_hist + norm_diff_HJ_ista_hist_temp\n\n\n  xopt_HJ_ista_array[delta_index, :, :] = xopt_HJ_ista/n_trials\n  fk_HJ_ista_hist_array[delta_index, :] = fk_HJ_ista_hist/n_trials\n  norm_diff_HJ_ista_hist_array[delta_index, :] = norm_diff_HJ_ista_hist/n_trials\n</pre> # Average runs over 30 trials: standalone delta_array = [1e-2, 1e-1, 1e0]  xopt_HJ_ista_array = torch.zeros(len(delta_array), xopt_ista.shape[0], xopt_ista.shape[1]) fk_HJ_ista_hist_array = torch.zeros(len(delta_array), max_iters) norm_diff_HJ_ista_hist_array = torch.zeros(len(delta_array), max_iters)  for delta_index in range(len(delta_array)):   print('Delta Index =', delta_array[delta_index])   for i in range(n_trials):     start_time_hj_ista = time.time()     current_delta = delta_array[delta_index]     xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp = hj_ista(x0, f, A, lambd, step_size, max_iters, int_samples=int(1e3), delta=current_delta, verbose=False)     end_time_hj_ista = time.time()     time_hj_ista = end_time_hj_ista - start_time_hj_ista     print('trial ', i+1, ' finished after', time_hj_ista)            if i==0:       xopt_HJ_ista, fk_HJ_ista_hist, norm_diff_HJ_ista_hist = xopt_HJ_ista_temp, fk_HJ_ista_hist_temp, norm_diff_HJ_ista_hist_temp     else:       xopt_HJ_ista = xopt_HJ_ista + xopt_HJ_ista_temp       fk_HJ_ista_hist = fk_HJ_ista_hist + fk_HJ_ista_hist_temp       norm_diff_HJ_ista_hist = norm_diff_HJ_ista_hist + norm_diff_HJ_ista_hist_temp     xopt_HJ_ista_array[delta_index, :, :] = xopt_HJ_ista/n_trials   fk_HJ_ista_hist_array[delta_index, :] = fk_HJ_ista_hist/n_trials   norm_diff_HJ_ista_hist_array[delta_index, :] = norm_diff_HJ_ista_hist/n_trials <pre>Delta Index = 0.01\nLAMBD =  1.0\ntrial  1  finished after 8.748048067092896\nDelta Index = 0.1\nLAMBD =  1.0\ntrial  1  finished after 8.673576831817627\nDelta Index = 1.0\nLAMBD =  1.0\ntrial  1  finished after 8.724540948867798\n</pre> In\u00a0[11]: Copied! <pre># plotting parameters\ntitle_fontsize = 22\nfontsize       = 20\nfig1 = plt.figure()\nmy_blue = '#1f77b4'\nmy_orange = '#F97306'\n\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.semilogy(fk_ista_hist[0:max_iters], linewidth=5, color=my_orange)\nax.semilogy(fk_HJ_ista_hist_array[0,:], '--', linewidth=5, color=my_blue)\nax.semilogy(fk_HJ_ista_hist_array[1,:], '--', linewidth=5, color='tab:green')\nax.semilogy(fk_HJ_ista_hist_array[2,:], '--', linewidth=5, color='tab:purple')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['ISTA', 'HJ-ISTA $\\delta=0.01$', 'HJ-ISTA $\\delta=0.1$', 'HJ-ISTA $\\delta=1$',],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left')\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'ISTA_delta_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> # plotting parameters title_fontsize = 22 fontsize       = 20 fig1 = plt.figure() my_blue = '#1f77b4' my_orange = '#F97306'  fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.semilogy(fk_ista_hist[0:max_iters], linewidth=5, color=my_orange) ax.semilogy(fk_HJ_ista_hist_array[0,:], '--', linewidth=5, color=my_blue) ax.semilogy(fk_HJ_ista_hist_array[1,:], '--', linewidth=5, color='tab:green') ax.semilogy(fk_HJ_ista_hist_array[2,:], '--', linewidth=5, color='tab:purple')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['ISTA', 'HJ-ISTA $\\delta=0.01$', 'HJ-ISTA $\\delta=0.1$', 'HJ-ISTA $\\delta=1$',],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left') ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'ISTA_delta_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-11-c1c409b9edbb&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre>"},{"location":"exp-l1-least-squares/#given-gradient-of-moreau-envelope","title":"Given gradient of Moreau envelope\u00b6","text":"<p>\\begin{equation}   \\nabla u^\\delta(x,t) = \\dfrac{1}{t}\\cdot  \\dfrac{\\mathbb{E}_{y\\sim  \\mathbb{P}_{x,t}}\\left[(x-y) \\exp\\left(-\\delta^{-1}\\tilde{f}(y)\\right) \\right]}     {\\mathbb{E}_{y\\sim  \\mathbb{P}_{x,t}}\\left[ \\exp\\left(-\\delta^{-1} \\tilde{f}(y)\\right) \\right]} = \\dfrac{1}{t} \\left(x -  \\dfrac{\\mathbb{E}_{y\\sim  \\mathbb{P}_{x,t}}\\left[(y) \\exp\\left(-\\delta^{-1}\\tilde{f}(y)\\right) \\right]}     {\\mathbb{E}_{y\\sim  \\mathbb{P}_{x,t}}\\left[ \\exp\\left(-\\delta^{-1} \\tilde{f}(y)\\right) \\right]}\\right) \\end{equation}</p> <p>The proximal can be approximated as</p> <p>\\begin{equation}   \\text{prox}_{tf}(x) = x - t \\nabla u(x,t) \\end{equation}</p>"},{"location":"exp-l1-least-squares/#performing-ista-with-prox_hj","title":"Performing ISTA with prox_HJ\u00b6","text":""},{"location":"exp-l1-least-squares/#run-hj-ista-for-different-number-of-samples","title":"Run HJ ISTA for different number of samples\u00b6","text":""},{"location":"exp-l1-least-squares/#hj-ista-delta-comparison","title":"HJ ISTA Delta Comparison\u00b6","text":""},{"location":"exp-oracle-constraints/","title":"Noisy Oracle + Constraints","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport sys\nfrom google.colab import drive\ndrive.mount('/content/drive')\nsys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')\n\nfrom hj_prox import *\nfrom functions import *\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport matplotlib.pyplot as plt\nimport time\n\ntorch.set_default_dtype(torch.float64)\ntorch.manual_seed(0)\ndevice = 'cuda:0'\n</pre> import os import sys from google.colab import drive drive.mount('/content/drive') sys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')  from hj_prox import * from functions import * import numpy as np import torch import torch.nn as nn import matplotlib.pyplot as plt import time  torch.set_default_dtype(torch.float64) torch.manual_seed(0) device = 'cuda:0' <pre>Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n</pre> In\u00a0[\u00a0]: Copied! <pre>def l1_norm_noisy(x):\n  # assumes shape of x is (n_samples x dim)\n  return (1 + 5e-3*torch.randn(x.shape[0], device=x.device))*torch.norm(x, dim=1, p=1)\n</pre> def l1_norm_noisy(x):   # assumes shape of x is (n_samples x dim)   return (1 + 5e-3*torch.randn(x.shape[0], device=x.device))*torch.norm(x, dim=1, p=1) In\u00a0[\u00a0]: Copied! <pre>torch.manual_seed(1)\ndim = int(1e3)\nA = torch.randn(int(dim/2), dim, device=device)\nW = 1e-1*torch.randn(dim, dim, device=device)\nb = torch.randn(int(dim/2), 1, device=device)\n\nalpha = 1e-3\nbeta = 1e-1\nlambd = 1e-2 \n\ndef ladmm(x0, W, A, b, max_iters, tol=1e-6, alpha=1e-2, beta=1e-1, lambd=1e-2, verbose=True):\n\n  assert len(x0.shape)==2 and x0.shape[1]==1\n  dim1 = A.shape[1]\n  dim2 = A.shape[0]\n  # note if A is underdetermined, dim1 &lt; dim2 \n\n  device = x0.device\n  xk = x0\n  pk = torch.zeros(dim1, 1, device=device)\n  nu1k = torch.zeros(dim1, 1, device=device)\n  nu2k = torch.zeros(dim2, 1, device=device)\n\n  fk_hist = torch.zeros(max_iters)\n  fixed_point_residual_hist = torch.zeros(max_iters)\n\n  for i in range(max_iters):\n    Wxk = W.matmul(xk)\n    temp = pk + lambd*(nu1k + alpha*(Wxk - pk))\n    pk = l1_norm_prox(temp, t=lambd) \n    nu1k_plus1 = nu1k + alpha*(Wxk - pk)\n    nu2k_plus1 = nu2k + alpha*(A.matmul(xk) - b)\n    rk = W.t().matmul(2*nu1k_plus1 - nu1k) + A.t().matmul(2*nu2k_plus1 - nu2k)\n    xk = xk - beta*rk\n\n    fk = l1_norm(W.matmul(xk).permute(1,0)).cpu()\n    fk_hist[i] = fk\n    fixed_point_residual = torch.norm(beta*rk).cpu()\n    fixed_point_residual_hist[i] = fixed_point_residual\n\n    if verbose:\n      print('iter: ', i, ', fk: ', fk, ', fixed pt res: ', fixed_point_residual)\n\n    if fixed_point_residual &lt;= tol:\n      x_sol = xk\n      fk_hist = fk_hist[0:i]\n      fixed_point_residual_hist = fixed_point_residual_hist[0:i]\n      print('LADMM converged to fixed pt. res. of', fixed_point_residual, ', after ', i, ' iterations ')\n      break\n\n  return xk, fk_hist, fixed_point_residual_hist\n\ndef hj_mm(x0, W, A, b, max_iters, delta=1e-1, int_samples=int(1e2), step_size=1e-1, tol=1e-8, lambd=0.5, verbose=True, x_true=[], print_freq=1, alpha=1.0):\n\n  assert len(x0.shape)==2 and x0.shape[1]==1\n  dim1 = A.shape[1]\n  dim2 = A.shape[0]\n\n  assert b.shape[1]==1 and b.shape[0]==dim2\n  # note if A is underdetermined, dim1 &lt; dim2 \n\n  device = x0.device\n  xk = x0\n  uk = torch.zeros(dim2, 1, device=device)\n\n  fk_hist = torch.zeros(max_iters)\n  fixed_point_residual_hist = torch.zeros(max_iters)\n  rel_err_hist = torch.zeros(max_iters)\n  linesearch_iters_hist = torch.zeros(max_iters)\n\n\n  def f_noisy(x):\n    return l1_norm_noisy(W.matmul(x.permute(1,0)).permute(1,0))\n\n  res = A.matmul(xk)-b\n\n  assert res.shape[0]==dim2 and res.shape[1]==1\n\n\n  for i in range(max_iters):\n\n    start_time = time.time()\n\n    xold = xk.clone()\n\n    res = A.matmul(xk)-b\n    xk = xk - step_size*A.t().matmul(uk + lambd*res)\n    xk, linesearch_iters, temp_envelope = compute_prox(xk, step_size, f_noisy, delta=delta, int_samples=int_samples, alpha=alpha, device=device)\n\n    res = A.matmul(xk)-b\n    uk = uk + lambd*(res)\n\n    assert res.shape[0]==A.shape[0] and res.shape[1]==1\n    assert uk.shape==res.shape\n\n    Wxk = W.matmul(xk)\n\n    fk = l1_norm(Wxk.permute(1,0)).cpu()\n    fk_hist[i] = fk\n    fixed_point_residual = torch.norm(xk - xold).cpu()\n    fixed_point_residual_hist[i] = fixed_point_residual.cpu()\n    rel_err = (torch.norm(xk - x_true)/torch.norm(x_true)).cpu()\n    rel_err_hist[i] = rel_err.cpu()\n    linesearch_iters_hist[i] = linesearch_iters\n\n    end_time = time.time()\n    iter_time = end_time - start_time\n\n    if verbose:\n      if (i+1)%print_freq==0:\n        print('iter: ', i+1, ', fixed pt res: ', fixed_point_residual, ', ls: ', linesearch_iters,  ', rel_err: ', rel_err, ', time: ', iter_time)\n\n  return xk, fk_hist, fixed_point_residual_hist, rel_err_hist, linesearch_iters_hist\n\ndef grad_descent(x0, A, b, max_iters, tol=1e-6, step_size=1e-1, verbose=True, x_true=[]):\n\n  xk = x0\n  grad_norm_hist = torch.zeros(max_iters)\n  rel_err_hist = torch.zeros(max_iters)\n\n  for i in range(max_iters):\n    start_time = time.time()\n    grad_term = A.t().matmul(A.matmul(xk)-b)\n    xk =  xk - step_size * grad_term\n\n    grad_norm_hist[i] = torch.norm(grad_term).cpu()\n    rel_err = (torch.norm(xk - x_true)/torch.norm(x_true)).cpu()\n    rel_err_hist[i] = rel_err\n    \n    end_time = time.time()\n    iter_time = end_time - start_time\n\n    if verbose:\n      print('iter = ', i+1, ', grad_norm = ', grad_norm_hist[i], ', rel_err = ', rel_err)\n\n  return xk, grad_norm_hist, rel_err_hist\n</pre> torch.manual_seed(1) dim = int(1e3) A = torch.randn(int(dim/2), dim, device=device) W = 1e-1*torch.randn(dim, dim, device=device) b = torch.randn(int(dim/2), 1, device=device)  alpha = 1e-3 beta = 1e-1 lambd = 1e-2   def ladmm(x0, W, A, b, max_iters, tol=1e-6, alpha=1e-2, beta=1e-1, lambd=1e-2, verbose=True):    assert len(x0.shape)==2 and x0.shape[1]==1   dim1 = A.shape[1]   dim2 = A.shape[0]   # note if A is underdetermined, dim1 &lt; dim2     device = x0.device   xk = x0   pk = torch.zeros(dim1, 1, device=device)   nu1k = torch.zeros(dim1, 1, device=device)   nu2k = torch.zeros(dim2, 1, device=device)    fk_hist = torch.zeros(max_iters)   fixed_point_residual_hist = torch.zeros(max_iters)    for i in range(max_iters):     Wxk = W.matmul(xk)     temp = pk + lambd*(nu1k + alpha*(Wxk - pk))     pk = l1_norm_prox(temp, t=lambd)      nu1k_plus1 = nu1k + alpha*(Wxk - pk)     nu2k_plus1 = nu2k + alpha*(A.matmul(xk) - b)     rk = W.t().matmul(2*nu1k_plus1 - nu1k) + A.t().matmul(2*nu2k_plus1 - nu2k)     xk = xk - beta*rk      fk = l1_norm(W.matmul(xk).permute(1,0)).cpu()     fk_hist[i] = fk     fixed_point_residual = torch.norm(beta*rk).cpu()     fixed_point_residual_hist[i] = fixed_point_residual      if verbose:       print('iter: ', i, ', fk: ', fk, ', fixed pt res: ', fixed_point_residual)      if fixed_point_residual &lt;= tol:       x_sol = xk       fk_hist = fk_hist[0:i]       fixed_point_residual_hist = fixed_point_residual_hist[0:i]       print('LADMM converged to fixed pt. res. of', fixed_point_residual, ', after ', i, ' iterations ')       break    return xk, fk_hist, fixed_point_residual_hist  def hj_mm(x0, W, A, b, max_iters, delta=1e-1, int_samples=int(1e2), step_size=1e-1, tol=1e-8, lambd=0.5, verbose=True, x_true=[], print_freq=1, alpha=1.0):    assert len(x0.shape)==2 and x0.shape[1]==1   dim1 = A.shape[1]   dim2 = A.shape[0]    assert b.shape[1]==1 and b.shape[0]==dim2   # note if A is underdetermined, dim1 &lt; dim2     device = x0.device   xk = x0   uk = torch.zeros(dim2, 1, device=device)    fk_hist = torch.zeros(max_iters)   fixed_point_residual_hist = torch.zeros(max_iters)   rel_err_hist = torch.zeros(max_iters)   linesearch_iters_hist = torch.zeros(max_iters)     def f_noisy(x):     return l1_norm_noisy(W.matmul(x.permute(1,0)).permute(1,0))    res = A.matmul(xk)-b    assert res.shape[0]==dim2 and res.shape[1]==1     for i in range(max_iters):      start_time = time.time()      xold = xk.clone()      res = A.matmul(xk)-b     xk = xk - step_size*A.t().matmul(uk + lambd*res)     xk, linesearch_iters, temp_envelope = compute_prox(xk, step_size, f_noisy, delta=delta, int_samples=int_samples, alpha=alpha, device=device)      res = A.matmul(xk)-b     uk = uk + lambd*(res)      assert res.shape[0]==A.shape[0] and res.shape[1]==1     assert uk.shape==res.shape      Wxk = W.matmul(xk)      fk = l1_norm(Wxk.permute(1,0)).cpu()     fk_hist[i] = fk     fixed_point_residual = torch.norm(xk - xold).cpu()     fixed_point_residual_hist[i] = fixed_point_residual.cpu()     rel_err = (torch.norm(xk - x_true)/torch.norm(x_true)).cpu()     rel_err_hist[i] = rel_err.cpu()     linesearch_iters_hist[i] = linesearch_iters      end_time = time.time()     iter_time = end_time - start_time      if verbose:       if (i+1)%print_freq==0:         print('iter: ', i+1, ', fixed pt res: ', fixed_point_residual, ', ls: ', linesearch_iters,  ', rel_err: ', rel_err, ', time: ', iter_time)    return xk, fk_hist, fixed_point_residual_hist, rel_err_hist, linesearch_iters_hist  def grad_descent(x0, A, b, max_iters, tol=1e-6, step_size=1e-1, verbose=True, x_true=[]):    xk = x0   grad_norm_hist = torch.zeros(max_iters)   rel_err_hist = torch.zeros(max_iters)    for i in range(max_iters):     start_time = time.time()     grad_term = A.t().matmul(A.matmul(xk)-b)     xk =  xk - step_size * grad_term      grad_norm_hist[i] = torch.norm(grad_term).cpu()     rel_err = (torch.norm(xk - x_true)/torch.norm(x_true)).cpu()     rel_err_hist[i] = rel_err          end_time = time.time()     iter_time = end_time - start_time      if verbose:       print('iter = ', i+1, ', grad_norm = ', grad_norm_hist[i], ', rel_err = ', rel_err)    return xk, grad_norm_hist, rel_err_hist In\u00a0[\u00a0]: Copied! <pre>n_trials_true = 3\nx_true_array = torch.randn(n_trials_true, dim, device=device)\nfor i in range(n_trials_true):\n  x0 = torch.randn(dim, 1, device=device)\n\n  start_time_ladmm = time.time()\n  x_true, fk_admm_hist, fixed_point_residual_admm_hist = ladmm(x0, W, A, b, int(5e4), alpha=alpha, lambd=lambd, beta=beta, verbose=False, tol=1e-6)\n  end_time_ladmm = time.time()\n  time_ladmm = end_time_ladmm - start_time_ladmm\n  print('trial ', i, ', time = ', time_ladmm)\n  x_true_array[i, :] = x_true.view(-1)\n  assert(max(x_true)&lt;np.inf)\n</pre> n_trials_true = 3 x_true_array = torch.randn(n_trials_true, dim, device=device) for i in range(n_trials_true):   x0 = torch.randn(dim, 1, device=device)    start_time_ladmm = time.time()   x_true, fk_admm_hist, fixed_point_residual_admm_hist = ladmm(x0, W, A, b, int(5e4), alpha=alpha, lambd=lambd, beta=beta, verbose=False, tol=1e-6)   end_time_ladmm = time.time()   time_ladmm = end_time_ladmm - start_time_ladmm   print('trial ', i, ', time = ', time_ladmm)   x_true_array[i, :] = x_true.view(-1)   assert(max(x_true) <pre>LADMM converged to fixed pt. res. of tensor(9.9999e-07) , after  33947  iterations \ntrial  0 , time =  17.05860137939453\nLADMM converged to fixed pt. res. of tensor(1.0000e-06) , after  34690  iterations \ntrial  1 , time =  17.195754289627075\nLADMM converged to fixed pt. res. of tensor(9.9986e-07) , after  31409  iterations \ntrial  2 , time =  15.552043437957764\n</pre> In\u00a0[\u00a0]: Copied! <pre># get relative errors for ladmm_no_prox.\nmax_iters = int(1e4)\nU, s, Vt = torch.svd(A.t().matmul(A))\nstep_size = 1/s.max().cpu() - 1e-8\nlambd=0.5\n\nxopt_GD, grad_norm_hist_GD, rel_err_hist_GD = grad_descent(x0, A, b, max_iters, step_size=step_size, verbose=False, x_true=x_true)\n</pre> # get relative errors for ladmm_no_prox. max_iters = int(1e4) U, s, Vt = torch.svd(A.t().matmul(A)) step_size = 1/s.max().cpu() - 1e-8 lambd=0.5  xopt_GD, grad_norm_hist_GD, rel_err_hist_GD = grad_descent(x0, A, b, max_iters, step_size=step_size, verbose=False, x_true=x_true) In\u00a0[\u00a0]: Copied! <pre># Average runs over 30 trials: standalone\nn_trials = 1\ndelta_array = [1e-2, 1e-1, 1.0, 10, 100]\nalpha_array = [2**(-12), 2**(-9), (2**(-5) + 2**(-6))/2, 2**(-2), 2**(-1)]\n\nxopt_HJ_lmm_delta_array = torch.zeros(len(delta_array), x_true.shape[0], x_true.shape[1])\nfk_HJ_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters)\nnorm_diff_HJ_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters)\nrel_err_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters)\nls_iters_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters)\n\nsamples_for_varying_delta = int(1e4)\n\nfor delta_index in range(len(delta_array)):\n  print('delta =', delta_array[delta_index])\n  for i in range(n_trials):\n    start_time_hj_lmm = time.time()\n    current_delta = delta_array[delta_index]\n    xopt_HJ_lmm_temp, fk_HJ_lmm_hist_temp, norm_diff_HJ_lmm_hist_temp, rel_err_hist_temp, ls_iters_hist_temp = hj_mm(x0, W, A, b, max_iters, \n                                                                                                  int_samples=samples_for_varying_delta, \n                                                                                                  delta=current_delta,\n                                                                                                  lambd = lambd, \n                                                                                                  step_size=step_size,\n                                                                                                  verbose=True, \n                                                                                                  print_freq=50,\n                                                                                                  x_true=x_true,\n                                                                                                  alpha=alpha_array[delta_index])\n    end_time_hj_lmm = time.time()\n    time_hj_lmm = end_time_hj_lmm - start_time_hj_lmm\n    print('trial ', i+1, ' finished after', time_hj_lmm)\n      \n\n    print('\\n\\n\\n\\n CHANGE, delta = ', current_delta)\n\n    if i==0:\n      xopt_HJ_lmm = xopt_HJ_lmm_temp\n      fk_HJ_lmm_hist = fk_HJ_lmm_hist_temp\n      norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist_temp\n      rel_err_hist = rel_err_hist_temp\n      ls_iters_hist = ls_iters_hist_temp\n    else:\n      xopt_HJ_lmm = xopt_HJ_lmm + xopt_HJ_lmm_temp\n      fk_HJ_lmm_hist = fk_HJ_lmm_hist + fk_HJ_lmm_hist_temp\n      norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist + norm_diff_HJ_lmm_hist_temp\n      rel_err_hist = rel_err_hist + rel_err_hist_temp\n      ls_iters_hist = ls_iters_hist + ls_iters_hist_temp\n\n\n  xopt_HJ_lmm_delta_array[delta_index, :, :] = xopt_HJ_lmm/n_trials\n  fk_HJ_lmm_hist_delta_array[delta_index, :] = fk_HJ_lmm_hist/n_trials\n  norm_diff_HJ_lmm_hist_delta_array[delta_index, :] = norm_diff_HJ_lmm_hist/n_trials\n  rel_err_lmm_hist_delta_array[delta_index, :] = rel_err_hist/n_trials \n  ls_iters_lmm_hist_delta_array[delta_index,:] = ls_iters_hist/n_trials\n  print('norm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) = ', torch.norm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[delta_index,:]))\n</pre> # Average runs over 30 trials: standalone n_trials = 1 delta_array = [1e-2, 1e-1, 1.0, 10, 100] alpha_array = [2**(-12), 2**(-9), (2**(-5) + 2**(-6))/2, 2**(-2), 2**(-1)]  xopt_HJ_lmm_delta_array = torch.zeros(len(delta_array), x_true.shape[0], x_true.shape[1]) fk_HJ_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters) norm_diff_HJ_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters) rel_err_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters) ls_iters_lmm_hist_delta_array = torch.zeros(len(delta_array), max_iters)  samples_for_varying_delta = int(1e4)  for delta_index in range(len(delta_array)):   print('delta =', delta_array[delta_index])   for i in range(n_trials):     start_time_hj_lmm = time.time()     current_delta = delta_array[delta_index]     xopt_HJ_lmm_temp, fk_HJ_lmm_hist_temp, norm_diff_HJ_lmm_hist_temp, rel_err_hist_temp, ls_iters_hist_temp = hj_mm(x0, W, A, b, max_iters,                                                                                                    int_samples=samples_for_varying_delta,                                                                                                    delta=current_delta,                                                                                                   lambd = lambd,                                                                                                    step_size=step_size,                                                                                                   verbose=True,                                                                                                    print_freq=50,                                                                                                   x_true=x_true,                                                                                                   alpha=alpha_array[delta_index])     end_time_hj_lmm = time.time()     time_hj_lmm = end_time_hj_lmm - start_time_hj_lmm     print('trial ', i+1, ' finished after', time_hj_lmm)             print('\\n\\n\\n\\n CHANGE, delta = ', current_delta)      if i==0:       xopt_HJ_lmm = xopt_HJ_lmm_temp       fk_HJ_lmm_hist = fk_HJ_lmm_hist_temp       norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist_temp       rel_err_hist = rel_err_hist_temp       ls_iters_hist = ls_iters_hist_temp     else:       xopt_HJ_lmm = xopt_HJ_lmm + xopt_HJ_lmm_temp       fk_HJ_lmm_hist = fk_HJ_lmm_hist + fk_HJ_lmm_hist_temp       norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist + norm_diff_HJ_lmm_hist_temp       rel_err_hist = rel_err_hist + rel_err_hist_temp       ls_iters_hist = ls_iters_hist + ls_iters_hist_temp     xopt_HJ_lmm_delta_array[delta_index, :, :] = xopt_HJ_lmm/n_trials   fk_HJ_lmm_hist_delta_array[delta_index, :] = fk_HJ_lmm_hist/n_trials   norm_diff_HJ_lmm_hist_delta_array[delta_index, :] = norm_diff_HJ_lmm_hist/n_trials   rel_err_lmm_hist_delta_array[delta_index, :] = rel_err_hist/n_trials    ls_iters_lmm_hist_delta_array[delta_index,:] = ls_iters_hist/n_trials   print('norm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) = ', torch.norm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[delta_index,:])) <pre>delta = 0.01\niter:  50 , fixed pt res:  tensor(0.6014) , ls:  1 , rel_err:  tensor(15.2876) , time:  0.002866983413696289\niter:  100 , fixed pt res:  tensor(0.2610) , ls:  1 , rel_err:  tensor(14.1650) , time:  0.0026578903198242188\niter:  150 , fixed pt res:  tensor(0.1266) , ls:  1 , rel_err:  tensor(13.2045) , time:  0.002607583999633789\niter:  200 , fixed pt res:  tensor(0.0741) , ls:  1 , rel_err:  tensor(12.3301) , time:  0.0027289390563964844\niter:  250 , fixed pt res:  tensor(0.0612) , ls:  1 , rel_err:  tensor(11.5111) , time:  0.0026788711547851562\niter:  300 , fixed pt res:  tensor(0.0564) , ls:  1 , rel_err:  tensor(10.7342) , time:  0.0026938915252685547\niter:  350 , fixed pt res:  tensor(0.0528) , ls:  1 , rel_err:  tensor(10.0056) , time:  0.0026712417602539062\niter:  400 , fixed pt res:  tensor(0.0527) , ls:  1 , rel_err:  tensor(9.3370) , time:  0.0026133060455322266\niter:  450 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(8.7010) , time:  0.0026159286499023438\niter:  500 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(8.1159) , time:  0.002603769302368164\niter:  550 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(7.5500) , time:  0.0025870800018310547\niter:  600 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(7.0455) , time:  0.002651691436767578\niter:  650 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(6.5675) , time:  0.0026242733001708984\niter:  700 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(6.1281) , time:  0.0026123523712158203\niter:  750 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(5.7053) , time:  0.0027201175689697266\niter:  800 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(5.3180) , time:  0.002632617950439453\niter:  850 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(4.9593) , time:  0.002621889114379883\niter:  900 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(4.6238) , time:  0.002607107162475586\niter:  950 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(4.3144) , time:  0.002595186233520508\niter:  1000 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(4.0185) , time:  0.002645254135131836\niter:  1050 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(3.7540) , time:  0.002599954605102539\niter:  1100 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(3.5047) , time:  0.0026836395263671875\niter:  1150 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(3.2836) , time:  0.0026116371154785156\niter:  1200 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(3.0738) , time:  0.002595663070678711\niter:  1250 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(2.8702) , time:  0.002620220184326172\niter:  1300 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(2.6800) , time:  0.0026030540466308594\niter:  1350 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(2.5230) , time:  0.002622842788696289\niter:  1400 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(2.3789) , time:  0.0026531219482421875\niter:  1450 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(2.2404) , time:  0.002665281295776367\niter:  1500 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(2.1036) , time:  0.002603769302368164\niter:  1550 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(1.9756) , time:  0.0026116371154785156\niter:  1600 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(1.8512) , time:  0.0026519298553466797\niter:  1650 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(1.7429) , time:  0.0026175975799560547\niter:  1700 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(1.6449) , time:  0.0026214122772216797\niter:  1750 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(1.5489) , time:  0.002623319625854492\niter:  1800 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.4627) , time:  0.002610445022583008\niter:  1850 , fixed pt res:  tensor(0.0426) , ls:  1 , rel_err:  tensor(1.3820) , time:  0.0026204586029052734\niter:  1900 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(1.3105) , time:  0.002740621566772461\niter:  1950 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(1.2419) , time:  0.0026121139526367188\niter:  2000 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(1.1821) , time:  0.0026407241821289062\niter:  2050 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(1.1262) , time:  0.0026285648345947266\niter:  2100 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(1.0700) , time:  0.0027396678924560547\niter:  2150 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(1.0336) , time:  0.0026540756225585938\niter:  2200 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.9851) , time:  0.0028276443481445312\niter:  2250 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.9466) , time:  0.0026481151580810547\niter:  2300 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.8937) , time:  0.002695798873901367\niter:  2350 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.8420) , time:  0.00261688232421875\niter:  2400 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.8041) , time:  0.0026023387908935547\niter:  2450 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.7707) , time:  0.0026216506958007812\niter:  2500 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.7425) , time:  0.0026090145111083984\niter:  2550 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.7211) , time:  0.0026030540466308594\niter:  2600 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.6999) , time:  0.0026161670684814453\niter:  2650 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.6637) , time:  0.0026285648345947266\niter:  2700 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.6484) , time:  0.002592325210571289\niter:  2750 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.6204) , time:  0.0026221275329589844\niter:  2800 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.5907) , time:  0.0026400089263916016\niter:  2850 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.5667) , time:  0.002603769302368164\niter:  2900 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.5479) , time:  0.002847433090209961\niter:  2950 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.5221) , time:  0.002637147903442383\niter:  3000 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.4944) , time:  0.002875804901123047\niter:  3050 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.4865) , time:  0.0026242733001708984\niter:  3100 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.4677) , time:  0.002634286880493164\niter:  3150 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.4603) , time:  0.0026273727416992188\niter:  3200 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.4451) , time:  0.0027008056640625\niter:  3250 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.4363) , time:  0.002660512924194336\niter:  3300 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.4198) , time:  0.002737283706665039\niter:  3350 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.4052) , time:  0.002620697021484375\niter:  3400 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.3929) , time:  0.002596616744995117\niter:  3450 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.3751) , time:  0.002627134323120117\niter:  3500 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.3594) , time:  0.0026710033416748047\niter:  3550 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.3492) , time:  0.0026192665100097656\niter:  3600 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.3329) , time:  0.002612590789794922\niter:  3650 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.3213) , time:  0.0026526451110839844\niter:  3700 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.3138) , time:  0.002615213394165039\niter:  3750 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.3068) , time:  0.0026254653930664062\niter:  3800 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2985) , time:  0.0026793479919433594\niter:  3850 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2954) , time:  0.0026276111602783203\niter:  3900 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2995) , time:  0.0027604103088378906\niter:  3950 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2918) , time:  0.0026252269744873047\niter:  4000 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2829) , time:  0.002598285675048828\niter:  4050 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2883) , time:  0.0026128292083740234\niter:  4100 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2823) , time:  0.0026764869689941406\niter:  4150 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2749) , time:  0.0026464462280273438\niter:  4200 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2738) , time:  0.002658843994140625\niter:  4250 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2839) , time:  0.002664327621459961\niter:  4300 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2846) , time:  0.002600431442260742\niter:  4350 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2822) , time:  0.002614736557006836\niter:  4400 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2766) , time:  0.0026111602783203125\niter:  4450 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2851) , time:  0.002942800521850586\niter:  4500 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2790) , time:  0.002645254135131836\niter:  4550 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2737) , time:  0.0026237964630126953\niter:  4600 , fixed pt res:  tensor(0.0425) , ls:  1 , rel_err:  tensor(0.2737) , time:  0.0026972293853759766\niter:  4650 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2738) , time:  0.002602815628051758\niter:  4700 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2681) , time:  0.0027227401733398438\niter:  4750 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2600) , time:  0.0026187896728515625\niter:  4800 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2689) , time:  0.002664327621459961\niter:  4850 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2647) , time:  0.002623319625854492\niter:  4900 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2610) , time:  0.0026009082794189453\niter:  4950 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2547) , time:  0.0026657581329345703\niter:  5000 , fixed pt res:  tensor(0.0422) , ls:  1 , rel_err:  tensor(0.2452) , time:  0.0026068687438964844\niter:  5050 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2534) , time:  0.002641439437866211\niter:  5100 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.2546) , time:  0.0025894641876220703\niter:  5150 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2565) , time:  0.0026578903198242188\niter:  5200 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2602) , time:  0.002780437469482422\niter:  5250 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2538) , time:  0.002653360366821289\niter:  5300 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2541) , time:  0.0026001930236816406\niter:  5350 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2446) , time:  0.0026025772094726562\niter:  5400 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2299) , time:  0.002604246139526367\niter:  5450 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2321) , time:  0.002683401107788086\niter:  5500 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2332) , time:  0.0026204586029052734\niter:  5550 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2307) , time:  0.0025882720947265625\niter:  5600 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2264) , time:  0.0026459693908691406\niter:  5650 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2368) , time:  0.002635955810546875\niter:  5700 , fixed pt res:  tensor(0.0426) , ls:  1 , rel_err:  tensor(0.2348) , time:  0.002643585205078125\niter:  5750 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2338) , time:  0.002627849578857422\niter:  5800 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2340) , time:  0.002646923065185547\niter:  5850 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2335) , time:  0.002660036087036133\niter:  5900 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2385) , time:  0.002616405487060547\niter:  5950 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2460) , time:  0.002605915069580078\niter:  6000 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2416) , time:  0.0026574134826660156\niter:  6050 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2449) , time:  0.0026526451110839844\niter:  6100 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2512) , time:  0.0025959014892578125\niter:  6150 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2495) , time:  0.0025892257690429688\niter:  6200 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2530) , time:  0.002648591995239258\niter:  6250 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2474) , time:  0.0026361942291259766\niter:  6300 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2457) , time:  0.0026311874389648438\niter:  6350 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2481) , time:  0.002582073211669922\niter:  6400 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2603) , time:  0.0027589797973632812\niter:  6450 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2571) , time:  0.002671957015991211\niter:  6500 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(0.2515) , time:  0.0026404857635498047\niter:  6550 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2546) , time:  0.002638101577758789\niter:  6600 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2515) , time:  0.002616405487060547\niter:  6650 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.2477) , time:  0.0026443004608154297\niter:  6700 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2431) , time:  0.0026798248291015625\niter:  6750 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2456) , time:  0.0026657581329345703\niter:  6800 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2512) , time:  0.00266265869140625\niter:  6850 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2436) , time:  0.0026111602783203125\niter:  6900 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2404) , time:  0.0026488304138183594\niter:  6950 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2493) , time:  0.0025832653045654297\niter:  7000 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2581) , time:  0.002736330032348633\niter:  7050 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2536) , time:  0.0026400089263916016\niter:  7100 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2552) , time:  0.002611398696899414\niter:  7150 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2662) , time:  0.0026242733001708984\niter:  7200 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2723) , time:  0.002617359161376953\niter:  7250 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2547) , time:  0.0026268959045410156\niter:  7300 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2492) , time:  0.0026891231536865234\niter:  7350 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2514) , time:  0.0025877952575683594\niter:  7400 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2516) , time:  0.0026044845581054688\niter:  7450 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2598) , time:  0.0025823116302490234\niter:  7500 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2602) , time:  0.0026979446411132812\niter:  7550 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2565) , time:  0.002629995346069336\niter:  7600 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2516) , time:  0.002672433853149414\niter:  7650 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2441) , time:  0.0026144981384277344\niter:  7700 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2406) , time:  0.0026328563690185547\niter:  7750 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2406) , time:  0.0026073455810546875\niter:  7800 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2393) , time:  0.0026388168334960938\niter:  7850 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2345) , time:  0.0026521682739257812\niter:  7900 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2379) , time:  0.0026383399963378906\niter:  7950 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2370) , time:  0.002651214599609375\niter:  8000 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2446) , time:  0.002850055694580078\niter:  8050 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2443) , time:  0.0026161670684814453\niter:  8100 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2481) , time:  0.0026061534881591797\niter:  8150 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2444) , time:  0.0026128292083740234\niter:  8200 , fixed pt res:  tensor(0.0464) , ls:  1 , rel_err:  tensor(0.2433) , time:  0.0027930736541748047\niter:  8250 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2440) , time:  0.0026159286499023438\niter:  8300 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2494) , time:  0.00262451171875\niter:  8350 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2557) , time:  0.002601146697998047\niter:  8400 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2539) , time:  0.002947568893432617\niter:  8450 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2474) , time:  0.0026085376739501953\niter:  8500 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2328) , time:  0.0026068687438964844\niter:  8550 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2369) , time:  0.0025882720947265625\niter:  8600 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2276) , time:  0.002688169479370117\niter:  8650 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2380) , time:  0.0025942325592041016\niter:  8700 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2387) , time:  0.0026848316192626953\niter:  8750 , fixed pt res:  tensor(0.0420) , ls:  1 , rel_err:  tensor(0.2441) , time:  0.002606630325317383\niter:  8800 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2478) , time:  0.0026895999908447266\niter:  8850 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2411) , time:  0.0025746822357177734\niter:  8900 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2358) , time:  0.0026254653930664062\niter:  8950 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2361) , time:  0.0026378631591796875\niter:  9000 , fixed pt res:  tensor(0.0426) , ls:  1 , rel_err:  tensor(0.2347) , time:  0.0026183128356933594\niter:  9050 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2319) , time:  0.002596139907836914\niter:  9100 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2398) , time:  0.002637624740600586\niter:  9150 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2427) , time:  0.0026619434356689453\niter:  9200 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2579) , time:  0.002629995346069336\niter:  9250 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2582) , time:  0.0026335716247558594\niter:  9300 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2596) , time:  0.002610445022583008\niter:  9350 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2467) , time:  0.0026264190673828125\niter:  9400 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2438) , time:  0.0026292800903320312\niter:  9450 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2456) , time:  0.0026323795318603516\niter:  9500 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2347) , time:  0.002623319625854492\niter:  9550 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2371) , time:  0.002624988555908203\niter:  9600 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2468) , time:  0.0026865005493164062\niter:  9650 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2422) , time:  0.002601146697998047\niter:  9700 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2472) , time:  0.00258636474609375\niter:  9750 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2434) , time:  0.0026235580444335938\niter:  9800 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.2460) , time:  0.0028467178344726562\niter:  9850 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2459) , time:  0.0026454925537109375\niter:  9900 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2351) , time:  0.0026373863220214844\niter:  9950 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2353) , time:  0.002624034881591797\niter:  10000 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2458) , time:  0.002570629119873047\ntrial  1  finished after 27.3780620098114\n\n\n\n\n CHANGE, delta =  0.01\nnorm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) =  tensor(0.)\ndelta = 0.1\niter:  50 , fixed pt res:  tensor(0.6024) , ls:  1 , rel_err:  tensor(15.2734) , time:  0.0026395320892333984\niter:  100 , fixed pt res:  tensor(0.2571) , ls:  1 , rel_err:  tensor(14.1573) , time:  0.002633810043334961\niter:  150 , fixed pt res:  tensor(0.1314) , ls:  1 , rel_err:  tensor(13.2116) , time:  0.002636432647705078\niter:  200 , fixed pt res:  tensor(0.0796) , ls:  1 , rel_err:  tensor(12.3254) , time:  0.002630472183227539\niter:  250 , fixed pt res:  tensor(0.0655) , ls:  1 , rel_err:  tensor(11.4973) , time:  0.0026044845581054688\niter:  300 , fixed pt res:  tensor(0.0626) , ls:  1 , rel_err:  tensor(10.7382) , time:  0.002668619155883789\niter:  350 , fixed pt res:  tensor(0.0591) , ls:  1 , rel_err:  tensor(10.0184) , time:  0.0026521682739257812\niter:  400 , fixed pt res:  tensor(0.0576) , ls:  1 , rel_err:  tensor(9.3451) , time:  0.0036263465881347656\niter:  450 , fixed pt res:  tensor(0.0553) , ls:  1 , rel_err:  tensor(8.7179) , time:  0.002643108367919922\niter:  500 , fixed pt res:  tensor(0.0547) , ls:  1 , rel_err:  tensor(8.1263) , time:  0.0026276111602783203\niter:  550 , fixed pt res:  tensor(0.0541) , ls:  1 , rel_err:  tensor(7.5703) , time:  0.002591371536254883\niter:  600 , fixed pt res:  tensor(0.0519) , ls:  1 , rel_err:  tensor(7.0570) , time:  0.00260162353515625\niter:  650 , fixed pt res:  tensor(0.0512) , ls:  1 , rel_err:  tensor(6.5821) , time:  0.0026454925537109375\niter:  700 , fixed pt res:  tensor(0.0519) , ls:  1 , rel_err:  tensor(6.1244) , time:  0.0026962757110595703\niter:  750 , fixed pt res:  tensor(0.0525) , ls:  1 , rel_err:  tensor(5.7183) , time:  0.0025899410247802734\niter:  800 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(5.3294) , time:  0.0026574134826660156\niter:  850 , fixed pt res:  tensor(0.0498) , ls:  1 , rel_err:  tensor(4.9821) , time:  0.0026454925537109375\niter:  900 , fixed pt res:  tensor(0.0508) , ls:  1 , rel_err:  tensor(4.6579) , time:  0.002607583999633789\niter:  950 , fixed pt res:  tensor(0.0522) , ls:  1 , rel_err:  tensor(4.3529) , time:  0.002629995346069336\niter:  1000 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(4.0844) , time:  0.0026361942291259766\niter:  1050 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(3.8181) , time:  0.0026645660400390625\niter:  1100 , fixed pt res:  tensor(0.0519) , ls:  1 , rel_err:  tensor(3.5839) , time:  0.002616405487060547\niter:  1150 , fixed pt res:  tensor(0.0508) , ls:  1 , rel_err:  tensor(3.3641) , time:  0.002714872360229492\niter:  1200 , fixed pt res:  tensor(0.0504) , ls:  1 , rel_err:  tensor(3.1551) , time:  0.002900838851928711\niter:  1250 , fixed pt res:  tensor(0.0512) , ls:  1 , rel_err:  tensor(2.9600) , time:  0.002619028091430664\niter:  1300 , fixed pt res:  tensor(0.0514) , ls:  1 , rel_err:  tensor(2.7889) , time:  0.002590656280517578\niter:  1350 , fixed pt res:  tensor(0.0500) , ls:  1 , rel_err:  tensor(2.6252) , time:  0.002590656280517578\niter:  1400 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(2.4691) , time:  0.002591371536254883\niter:  1450 , fixed pt res:  tensor(0.0520) , ls:  1 , rel_err:  tensor(2.3233) , time:  0.0026082992553710938\niter:  1500 , fixed pt res:  tensor(0.0529) , ls:  1 , rel_err:  tensor(2.1884) , time:  0.0026760101318359375\niter:  1550 , fixed pt res:  tensor(0.0515) , ls:  1 , rel_err:  tensor(2.0734) , time:  0.002660512924194336\niter:  1600 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(1.9564) , time:  0.0026001930236816406\niter:  1650 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(1.8567) , time:  0.002652883529663086\niter:  1700 , fixed pt res:  tensor(0.0491) , ls:  1 , rel_err:  tensor(1.7603) , time:  0.0026578903198242188\niter:  1750 , fixed pt res:  tensor(0.0499) , ls:  1 , rel_err:  tensor(1.6678) , time:  0.002605438232421875\niter:  1800 , fixed pt res:  tensor(0.0499) , ls:  1 , rel_err:  tensor(1.5920) , time:  0.002622365951538086\niter:  1850 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(1.5209) , time:  0.002629518508911133\niter:  1900 , fixed pt res:  tensor(0.0484) , ls:  1 , rel_err:  tensor(1.4413) , time:  0.0026397705078125\niter:  1950 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(1.3834) , time:  0.0026040077209472656\niter:  2000 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(1.3253) , time:  0.002625703811645508\niter:  2050 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(1.2545) , time:  0.002617359161376953\niter:  2100 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(1.2010) , time:  0.0026395320892333984\niter:  2150 , fixed pt res:  tensor(0.0528) , ls:  1 , rel_err:  tensor(1.1449) , time:  0.0026330947875976562\niter:  2200 , fixed pt res:  tensor(0.0486) , ls:  1 , rel_err:  tensor(1.0987) , time:  0.0026540756225585938\niter:  2250 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(1.0528) , time:  0.002614259719848633\niter:  2300 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(1.0073) , time:  0.0025959014892578125\niter:  2350 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.9671) , time:  0.0025959014892578125\niter:  2400 , fixed pt res:  tensor(0.0498) , ls:  1 , rel_err:  tensor(0.9244) , time:  0.002643585205078125\niter:  2450 , fixed pt res:  tensor(0.0521) , ls:  1 , rel_err:  tensor(0.8814) , time:  0.0026264190673828125\niter:  2500 , fixed pt res:  tensor(0.0491) , ls:  1 , rel_err:  tensor(0.8438) , time:  0.0028371810913085938\niter:  2550 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.8141) , time:  0.002639293670654297\niter:  2600 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.7701) , time:  0.0028192996978759766\niter:  2650 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.7341) , time:  0.0026717185974121094\niter:  2700 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(0.7033) , time:  0.002650737762451172\niter:  2750 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.6702) , time:  0.0025954246520996094\niter:  2800 , fixed pt res:  tensor(0.0520) , ls:  1 , rel_err:  tensor(0.6541) , time:  0.002783060073852539\niter:  2850 , fixed pt res:  tensor(0.0505) , ls:  1 , rel_err:  tensor(0.6294) , time:  0.0026559829711914062\niter:  2900 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.6014) , time:  0.0029981136322021484\niter:  2950 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.5876) , time:  0.0027670860290527344\niter:  3000 , fixed pt res:  tensor(0.0522) , ls:  1 , rel_err:  tensor(0.5688) , time:  0.0028235912322998047\niter:  3050 , fixed pt res:  tensor(0.0508) , ls:  1 , rel_err:  tensor(0.5508) , time:  0.0026345252990722656\niter:  3100 , fixed pt res:  tensor(0.0499) , ls:  1 , rel_err:  tensor(0.5394) , time:  0.0027310848236083984\niter:  3150 , fixed pt res:  tensor(0.0514) , ls:  1 , rel_err:  tensor(0.5302) , time:  0.002622365951538086\niter:  3200 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.5260) , time:  0.002646923065185547\niter:  3250 , fixed pt res:  tensor(0.0486) , ls:  1 , rel_err:  tensor(0.5135) , time:  0.0025806427001953125\niter:  3300 , fixed pt res:  tensor(0.0500) , ls:  1 , rel_err:  tensor(0.5036) , time:  0.002665281295776367\niter:  3350 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(0.4874) , time:  0.002624034881591797\niter:  3400 , fixed pt res:  tensor(0.0485) , ls:  1 , rel_err:  tensor(0.4782) , time:  0.0026574134826660156\niter:  3450 , fixed pt res:  tensor(0.0526) , ls:  1 , rel_err:  tensor(0.4766) , time:  0.0026869773864746094\niter:  3500 , fixed pt res:  tensor(0.0483) , ls:  1 , rel_err:  tensor(0.4638) , time:  0.0027141571044921875\niter:  3550 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(0.4446) , time:  0.002619028091430664\niter:  3600 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(0.4431) , time:  0.002580881118774414\niter:  3650 , fixed pt res:  tensor(0.0515) , ls:  1 , rel_err:  tensor(0.4307) , time:  0.002605915069580078\niter:  3700 , fixed pt res:  tensor(0.0504) , ls:  1 , rel_err:  tensor(0.4222) , time:  0.00266265869140625\niter:  3750 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(0.4080) , time:  0.0026161670684814453\niter:  3800 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.4069) , time:  0.0025949478149414062\niter:  3850 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.3987) , time:  0.002596139907836914\niter:  3900 , fixed pt res:  tensor(0.0499) , ls:  1 , rel_err:  tensor(0.3832) , time:  0.002691507339477539\niter:  3950 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.3856) , time:  0.002644777297973633\niter:  4000 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(0.3708) , time:  0.0026993751525878906\niter:  4050 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.3730) , time:  0.002619028091430664\niter:  4100 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.3689) , time:  0.0026683807373046875\niter:  4150 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(0.3694) , time:  0.00261688232421875\niter:  4200 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(0.3652) , time:  0.002650737762451172\niter:  4250 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(0.3573) , time:  0.0026361942291259766\niter:  4300 , fixed pt res:  tensor(0.0491) , ls:  1 , rel_err:  tensor(0.3519) , time:  0.0031049251556396484\niter:  4350 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.3418) , time:  0.0026412010192871094\niter:  4400 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.3438) , time:  0.002599477767944336\niter:  4450 , fixed pt res:  tensor(0.0533) , ls:  1 , rel_err:  tensor(0.3472) , time:  0.002591848373413086\niter:  4500 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.3378) , time:  0.002658367156982422\niter:  4550 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(0.3343) , time:  0.002669095993041992\niter:  4600 , fixed pt res:  tensor(0.0477) , ls:  1 , rel_err:  tensor(0.3372) , time:  0.0025866031646728516\niter:  4650 , fixed pt res:  tensor(0.0489) , ls:  1 , rel_err:  tensor(0.3435) , time:  0.002625703811645508\niter:  4700 , fixed pt res:  tensor(0.0513) , ls:  1 , rel_err:  tensor(0.3364) , time:  0.0026092529296875\niter:  4750 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.3308) , time:  0.0026960372924804688\niter:  4800 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(0.3289) , time:  0.0026102066040039062\niter:  4850 , fixed pt res:  tensor(0.0487) , ls:  1 , rel_err:  tensor(0.3347) , time:  0.0026645660400390625\niter:  4900 , fixed pt res:  tensor(0.0505) , ls:  1 , rel_err:  tensor(0.3225) , time:  0.002632617950439453\niter:  4950 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(0.3249) , time:  0.0026404857635498047\niter:  5000 , fixed pt res:  tensor(0.0520) , ls:  1 , rel_err:  tensor(0.3180) , time:  0.0026352405548095703\niter:  5050 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(0.3167) , time:  0.0026044845581054688\niter:  5100 , fixed pt res:  tensor(0.0513) , ls:  1 , rel_err:  tensor(0.3107) , time:  0.0026082992553710938\niter:  5150 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(0.3191) , time:  0.002648591995239258\niter:  5200 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.3144) , time:  0.002597808837890625\niter:  5250 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.3067) , time:  0.0026259422302246094\niter:  5300 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.3126) , time:  0.0026192665100097656\niter:  5350 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(0.2975) , time:  0.002664804458618164\niter:  5400 , fixed pt res:  tensor(0.0516) , ls:  1 , rel_err:  tensor(0.3082) , time:  0.0026803016662597656\niter:  5450 , fixed pt res:  tensor(0.0515) , ls:  1 , rel_err:  tensor(0.3042) , time:  0.0026454925537109375\niter:  5500 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.3087) , time:  0.0026674270629882812\niter:  5550 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.3069) , time:  0.002651214599609375\niter:  5600 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2987) , time:  0.0025959014892578125\niter:  5650 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2988) , time:  0.002653360366821289\niter:  5700 , fixed pt res:  tensor(0.0521) , ls:  1 , rel_err:  tensor(0.2915) , time:  0.002653360366821289\niter:  5750 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.2909) , time:  0.0026268959045410156\niter:  5800 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(0.2915) , time:  0.0026569366455078125\niter:  5850 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(0.2881) , time:  0.0026044845581054688\niter:  5900 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(0.2900) , time:  0.0026781558990478516\niter:  5950 , fixed pt res:  tensor(0.0500) , ls:  1 , rel_err:  tensor(0.2745) , time:  0.0025932788848876953\niter:  6000 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.2660) , time:  0.0025959014892578125\niter:  6050 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2699) , time:  0.0026063919067382812\niter:  6100 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(0.2744) , time:  0.0027208328247070312\niter:  6150 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(0.2756) , time:  0.002628326416015625\niter:  6200 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.2902) , time:  0.002673625946044922\niter:  6250 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.2795) , time:  0.005936861038208008\niter:  6300 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2847) , time:  0.002641439437866211\niter:  6350 , fixed pt res:  tensor(0.0514) , ls:  1 , rel_err:  tensor(0.2862) , time:  0.002637624740600586\niter:  6400 , fixed pt res:  tensor(0.0495) , ls:  1 , rel_err:  tensor(0.2855) , time:  0.0026657581329345703\niter:  6450 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.2882) , time:  0.0026798248291015625\niter:  6500 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2736) , time:  0.0026044845581054688\niter:  6550 , fixed pt res:  tensor(0.0508) , ls:  1 , rel_err:  tensor(0.2734) , time:  0.0026023387908935547\niter:  6600 , fixed pt res:  tensor(0.0484) , ls:  1 , rel_err:  tensor(0.2813) , time:  0.0026292800903320312\niter:  6650 , fixed pt res:  tensor(0.0475) , ls:  1 , rel_err:  tensor(0.2846) , time:  0.002617359161376953\niter:  6700 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.2871) , time:  0.0026006698608398438\niter:  6750 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(0.2827) , time:  0.0026998519897460938\niter:  6800 , fixed pt res:  tensor(0.0491) , ls:  1 , rel_err:  tensor(0.2914) , time:  0.002641916275024414\niter:  6850 , fixed pt res:  tensor(0.0511) , ls:  1 , rel_err:  tensor(0.2767) , time:  0.0026628971099853516\niter:  6900 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.2685) , time:  0.002627849578857422\niter:  6950 , fixed pt res:  tensor(0.0485) , ls:  1 , rel_err:  tensor(0.2683) , time:  0.0026264190673828125\niter:  7000 , fixed pt res:  tensor(0.0517) , ls:  1 , rel_err:  tensor(0.2680) , time:  0.002621889114379883\niter:  7050 , fixed pt res:  tensor(0.0487) , ls:  1 , rel_err:  tensor(0.2720) , time:  0.002657175064086914\niter:  7100 , fixed pt res:  tensor(0.0504) , ls:  1 , rel_err:  tensor(0.2722) , time:  0.0027887821197509766\niter:  7150 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(0.2694) , time:  0.0026350021362304688\niter:  7200 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.2759) , time:  0.0026476383209228516\niter:  7250 , fixed pt res:  tensor(0.0515) , ls:  1 , rel_err:  tensor(0.2741) , time:  0.0025992393493652344\niter:  7300 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(0.2775) , time:  0.0026497840881347656\niter:  7350 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2756) , time:  0.0026824474334716797\niter:  7400 , fixed pt res:  tensor(0.0517) , ls:  1 , rel_err:  tensor(0.2752) , time:  0.002943754196166992\niter:  7450 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2795) , time:  0.0026013851165771484\niter:  7500 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2867) , time:  0.002633810043334961\niter:  7550 , fixed pt res:  tensor(0.0489) , ls:  1 , rel_err:  tensor(0.2829) , time:  0.0026514530181884766\niter:  7600 , fixed pt res:  tensor(0.0526) , ls:  1 , rel_err:  tensor(0.2755) , time:  0.002739429473876953\niter:  7650 , fixed pt res:  tensor(0.0489) , ls:  1 , rel_err:  tensor(0.2817) , time:  0.002626657485961914\niter:  7700 , fixed pt res:  tensor(0.0518) , ls:  1 , rel_err:  tensor(0.2754) , time:  0.002665281295776367\niter:  7750 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.2794) , time:  0.0026416778564453125\niter:  7800 , fixed pt res:  tensor(0.0515) , ls:  1 , rel_err:  tensor(0.2688) , time:  0.0026836395263671875\niter:  7850 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.2722) , time:  0.0026421546936035156\niter:  7900 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(0.2603) , time:  0.002622842788696289\niter:  7950 , fixed pt res:  tensor(0.0513) , ls:  1 , rel_err:  tensor(0.2730) , time:  0.0026264190673828125\niter:  8000 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2707) , time:  0.0026280879974365234\niter:  8050 , fixed pt res:  tensor(0.0531) , ls:  1 , rel_err:  tensor(0.2837) , time:  0.002634286880493164\niter:  8100 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(0.2819) , time:  0.002626180648803711\niter:  8150 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.2658) , time:  0.0026307106018066406\niter:  8200 , fixed pt res:  tensor(0.0498) , ls:  1 , rel_err:  tensor(0.2765) , time:  0.0026407241821289062\niter:  8250 , fixed pt res:  tensor(0.0507) , ls:  1 , rel_err:  tensor(0.2701) , time:  0.002642393112182617\niter:  8300 , fixed pt res:  tensor(0.0512) , ls:  1 , rel_err:  tensor(0.2767) , time:  0.002636432647705078\niter:  8350 , fixed pt res:  tensor(0.0525) , ls:  1 , rel_err:  tensor(0.2821) , time:  0.0026226043701171875\niter:  8400 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(0.2873) , time:  0.002777576446533203\niter:  8450 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(0.2763) , time:  0.002614259719848633\niter:  8500 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.2895) , time:  0.0026481151580810547\niter:  8550 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(0.2829) , time:  0.0026159286499023438\niter:  8600 , fixed pt res:  tensor(0.0485) , ls:  1 , rel_err:  tensor(0.2801) , time:  0.00262451171875\niter:  8650 , fixed pt res:  tensor(0.0495) , ls:  1 , rel_err:  tensor(0.2850) , time:  0.0025970935821533203\niter:  8700 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(0.2773) , time:  0.0026483535766601562\niter:  8750 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.2770) , time:  0.0026476383209228516\niter:  8800 , fixed pt res:  tensor(0.0504) , ls:  1 , rel_err:  tensor(0.2859) , time:  0.002651214599609375\niter:  8850 , fixed pt res:  tensor(0.0509) , ls:  1 , rel_err:  tensor(0.2834) , time:  0.002624034881591797\niter:  8900 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.2798) , time:  0.002610921859741211\niter:  8950 , fixed pt res:  tensor(0.0477) , ls:  1 , rel_err:  tensor(0.2901) , time:  0.002869129180908203\niter:  9000 , fixed pt res:  tensor(0.0513) , ls:  1 , rel_err:  tensor(0.2827) , time:  0.0026993751525878906\niter:  9050 , fixed pt res:  tensor(0.0496) , ls:  1 , rel_err:  tensor(0.2763) , time:  0.0026035308837890625\niter:  9100 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2757) , time:  0.0026476383209228516\niter:  9150 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.2769) , time:  0.002643108367919922\niter:  9200 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(0.2807) , time:  0.0026454925537109375\niter:  9250 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.2818) , time:  0.002629518508911133\niter:  9300 , fixed pt res:  tensor(0.0502) , ls:  1 , rel_err:  tensor(0.2832) , time:  0.0027909278869628906\niter:  9350 , fixed pt res:  tensor(0.0483) , ls:  1 , rel_err:  tensor(0.2743) , time:  0.0026569366455078125\niter:  9400 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(0.2720) , time:  0.002588510513305664\niter:  9450 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(0.2639) , time:  0.0026352405548095703\niter:  9500 , fixed pt res:  tensor(0.0474) , ls:  1 , rel_err:  tensor(0.2650) , time:  0.0026216506958007812\niter:  9550 , fixed pt res:  tensor(0.0505) , ls:  1 , rel_err:  tensor(0.2635) , time:  0.002645730972290039\niter:  9600 , fixed pt res:  tensor(0.0511) , ls:  1 , rel_err:  tensor(0.2621) , time:  0.002592802047729492\niter:  9650 , fixed pt res:  tensor(0.0504) , ls:  1 , rel_err:  tensor(0.2597) , time:  0.002633333206176758\niter:  9700 , fixed pt res:  tensor(0.0482) , ls:  1 , rel_err:  tensor(0.2604) , time:  0.002636432647705078\niter:  9750 , fixed pt res:  tensor(0.0485) , ls:  1 , rel_err:  tensor(0.2763) , time:  0.0026273727416992188\niter:  9800 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(0.2771) , time:  0.002584695816040039\niter:  9850 , fixed pt res:  tensor(0.0492) , ls:  1 , rel_err:  tensor(0.2740) , time:  0.002599477767944336\niter:  9900 , fixed pt res:  tensor(0.0486) , ls:  1 , rel_err:  tensor(0.2774) , time:  0.002656221389770508\niter:  9950 , fixed pt res:  tensor(0.0490) , ls:  1 , rel_err:  tensor(0.2829) , time:  0.002659320831298828\niter:  10000 , fixed pt res:  tensor(0.0501) , ls:  1 , rel_err:  tensor(0.2859) , time:  0.0026171207427978516\ntrial  1  finished after 27.39184856414795\n\n\n\n\n CHANGE, delta =  0.1\nnorm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) =  tensor(0.)\ndelta = 1.0\niter:  50 , fixed pt res:  tensor(0.6005) , ls:  1 , rel_err:  tensor(15.2768) , time:  0.0026540756225585938\niter:  100 , fixed pt res:  tensor(0.2584) , ls:  1 , rel_err:  tensor(14.1514) , time:  0.002636432647705078\niter:  150 , fixed pt res:  tensor(0.1262) , ls:  1 , rel_err:  tensor(13.2173) , time:  0.0026426315307617188\niter:  200 , fixed pt res:  tensor(0.0774) , ls:  1 , rel_err:  tensor(12.3428) , time:  0.0026314258575439453\niter:  250 , fixed pt res:  tensor(0.0582) , ls:  1 , rel_err:  tensor(11.5279) , time:  0.0026137828826904297\niter:  300 , fixed pt res:  tensor(0.0570) , ls:  1 , rel_err:  tensor(10.7427) , time:  0.0026383399963378906\niter:  350 , fixed pt res:  tensor(0.0529) , ls:  1 , rel_err:  tensor(10.0210) , time:  0.002575397491455078\niter:  400 , fixed pt res:  tensor(0.0512) , ls:  1 , rel_err:  tensor(9.3471) , time:  0.0026078224182128906\niter:  450 , fixed pt res:  tensor(0.0520) , ls:  1 , rel_err:  tensor(8.7221) , time:  0.0026149749755859375\niter:  500 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(8.1162) , time:  0.0028815269470214844\niter:  550 , fixed pt res:  tensor(0.0497) , ls:  1 , rel_err:  tensor(7.5650) , time:  0.0026204586029052734\niter:  600 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(7.0442) , time:  0.002576112747192383\niter:  650 , fixed pt res:  tensor(0.0493) , ls:  1 , rel_err:  tensor(6.5619) , time:  0.0026092529296875\niter:  700 , fixed pt res:  tensor(0.0482) , ls:  1 , rel_err:  tensor(6.1032) , time:  0.002608776092529297\niter:  750 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(5.6962) , time:  0.002565622329711914\niter:  800 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(5.3075) , time:  0.0025768280029296875\niter:  850 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(4.9531) , time:  0.002599954605102539\niter:  900 , fixed pt res:  tensor(0.0480) , ls:  1 , rel_err:  tensor(4.6159) , time:  0.0026197433471679688\niter:  950 , fixed pt res:  tensor(0.0478) , ls:  1 , rel_err:  tensor(4.3099) , time:  0.002585887908935547\niter:  1000 , fixed pt res:  tensor(0.0481) , ls:  1 , rel_err:  tensor(4.0246) , time:  0.002577066421508789\niter:  1050 , fixed pt res:  tensor(0.0474) , ls:  1 , rel_err:  tensor(3.7718) , time:  0.0026106834411621094\niter:  1100 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(3.5245) , time:  0.0026373863220214844\niter:  1150 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(3.3049) , time:  0.002629518508911133\niter:  1200 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(3.0891) , time:  0.0026445388793945312\niter:  1250 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(2.8850) , time:  0.0026628971099853516\niter:  1300 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(2.7110) , time:  0.00262451171875\niter:  1350 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(2.5294) , time:  0.0026557445526123047\niter:  1400 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(2.3791) , time:  0.0026009082794189453\niter:  1450 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(2.2291) , time:  0.0026459693908691406\niter:  1500 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(2.0951) , time:  0.002675294876098633\niter:  1550 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(1.9579) , time:  0.0025932788848876953\niter:  1600 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(1.8430) , time:  0.002668619155883789\niter:  1650 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(1.7305) , time:  0.0026373863220214844\niter:  1700 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(1.6303) , time:  0.002611398696899414\niter:  1750 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(1.5428) , time:  0.002649068832397461\niter:  1800 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(1.4608) , time:  0.0026705265045166016\niter:  1850 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(1.3826) , time:  0.0026466846466064453\niter:  1900 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(1.3036) , time:  0.002669095993041992\niter:  1950 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(1.2278) , time:  0.0026056766510009766\niter:  2000 , fixed pt res:  tensor(0.0471) , ls:  1 , rel_err:  tensor(1.1679) , time:  0.0026493072509765625\niter:  2050 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(1.1019) , time:  0.0026268959045410156\niter:  2100 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(1.0464) , time:  0.00262451171875\niter:  2150 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(1.0033) , time:  0.002627849578857422\niter:  2200 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.9490) , time:  0.002641916275024414\niter:  2250 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.8957) , time:  0.0026352405548095703\niter:  2300 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(0.8654) , time:  0.002621173858642578\niter:  2350 , fixed pt res:  tensor(0.0479) , ls:  1 , rel_err:  tensor(0.8243) , time:  0.0027053356170654297\niter:  2400 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.7950) , time:  0.0026209354400634766\niter:  2450 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.7708) , time:  0.0026350021362304688\niter:  2500 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.7380) , time:  0.002679109573364258\niter:  2550 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.7190) , time:  0.002644777297973633\niter:  2600 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.6741) , time:  0.0026051998138427734\niter:  2650 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.6421) , time:  0.0026192665100097656\niter:  2700 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(0.6235) , time:  0.0026314258575439453\niter:  2750 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.5928) , time:  0.002638578414916992\niter:  2800 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.5695) , time:  0.002611398696899414\niter:  2850 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.5487) , time:  0.0026407241821289062\niter:  2900 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.5377) , time:  0.002595186233520508\niter:  2950 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.5236) , time:  0.002619504928588867\niter:  3000 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.4881) , time:  0.0026061534881591797\niter:  3050 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.4761) , time:  0.0026426315307617188\niter:  3100 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.4674) , time:  0.002640962600708008\niter:  3150 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.4544) , time:  0.0026710033416748047\niter:  3200 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.4424) , time:  0.0026140213012695312\niter:  3250 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.4442) , time:  0.0026242733001708984\niter:  3300 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.4376) , time:  0.0026433467864990234\niter:  3350 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.4240) , time:  0.0026373863220214844\niter:  3400 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.4060) , time:  0.002625703811645508\niter:  3450 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.3985) , time:  0.002706766128540039\niter:  3500 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.3738) , time:  0.0026137828826904297\niter:  3550 , fixed pt res:  tensor(0.0475) , ls:  1 , rel_err:  tensor(0.3622) , time:  0.0026497840881347656\niter:  3600 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.3532) , time:  0.0025882720947265625\niter:  3650 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.3436) , time:  0.0026092529296875\niter:  3700 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.3315) , time:  0.0029354095458984375\niter:  3750 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(0.3287) , time:  0.002648591995239258\niter:  3800 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.3257) , time:  0.0026578903198242188\niter:  3850 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(0.3218) , time:  0.0026292800903320312\niter:  3900 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.3271) , time:  0.0026068687438964844\niter:  3950 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.3251) , time:  0.0026171207427978516\niter:  4000 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.3210) , time:  0.002641916275024414\niter:  4050 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.3092) , time:  0.002651214599609375\niter:  4100 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.3099) , time:  0.0026879310607910156\niter:  4150 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.3023) , time:  0.0026187896728515625\niter:  4200 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2965) , time:  0.0026483535766601562\niter:  4250 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2969) , time:  0.002678394317626953\niter:  4300 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2840) , time:  0.0026154518127441406\niter:  4350 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2805) , time:  0.0026285648345947266\niter:  4400 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2865) , time:  0.002627134323120117\niter:  4450 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2870) , time:  0.002590179443359375\niter:  4500 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(0.2870) , time:  0.0026192665100097656\niter:  4550 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.2886) , time:  0.002604246139526367\niter:  4600 , fixed pt res:  tensor(0.0474) , ls:  1 , rel_err:  tensor(0.2938) , time:  0.002635478973388672\niter:  4650 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(0.2835) , time:  0.0026128292083740234\niter:  4700 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.2962) , time:  0.0026760101318359375\niter:  4750 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2938) , time:  0.002630472183227539\niter:  4800 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2811) , time:  0.0026006698608398438\niter:  4850 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2715) , time:  0.0026330947875976562\niter:  4900 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2852) , time:  0.0026869773864746094\niter:  4950 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2726) , time:  0.002587556838989258\niter:  5000 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2675) , time:  0.002599000930786133\niter:  5050 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2669) , time:  0.002650737762451172\niter:  5100 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(0.2728) , time:  0.0026428699493408203\niter:  5150 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2719) , time:  0.0026433467864990234\niter:  5200 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2842) , time:  0.002634286880493164\niter:  5250 , fixed pt res:  tensor(0.0471) , ls:  1 , rel_err:  tensor(0.2828) , time:  0.002868175506591797\niter:  5300 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2798) , time:  0.0026540756225585938\niter:  5350 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2775) , time:  0.002628803253173828\niter:  5400 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2736) , time:  0.0025908946990966797\niter:  5450 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2676) , time:  0.0025773048400878906\niter:  5500 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2721) , time:  0.002618551254272461\niter:  5550 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2685) , time:  0.0026159286499023438\niter:  5600 , fixed pt res:  tensor(0.0475) , ls:  1 , rel_err:  tensor(0.2680) , time:  0.0026025772094726562\niter:  5650 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2586) , time:  0.0025658607482910156\niter:  5700 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2543) , time:  0.0026159286499023438\niter:  5750 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2570) , time:  0.002605438232421875\niter:  5800 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2530) , time:  0.003300905227661133\niter:  5850 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.2553) , time:  0.002602100372314453\niter:  5900 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2602) , time:  0.0026242733001708984\niter:  5950 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2625) , time:  0.0026111602783203125\niter:  6000 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2580) , time:  0.0029571056365966797\niter:  6050 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2541) , time:  0.0026388168334960938\niter:  6100 , fixed pt res:  tensor(0.0476) , ls:  1 , rel_err:  tensor(0.2559) , time:  0.0026400089263916016\niter:  6150 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2496) , time:  0.002628803253173828\niter:  6200 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2486) , time:  0.002633333206176758\niter:  6250 , fixed pt res:  tensor(0.0471) , ls:  1 , rel_err:  tensor(0.2526) , time:  0.0025932788848876953\niter:  6300 , fixed pt res:  tensor(0.0464) , ls:  1 , rel_err:  tensor(0.2486) , time:  0.0026178359985351562\niter:  6350 , fixed pt res:  tensor(0.0471) , ls:  1 , rel_err:  tensor(0.2381) , time:  0.002589702606201172\niter:  6400 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2374) , time:  0.0026047229766845703\niter:  6450 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2355) , time:  0.002631664276123047\niter:  6500 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2353) , time:  0.0025975704193115234\niter:  6550 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2260) , time:  0.002611875534057617\niter:  6600 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2244) , time:  0.002643585205078125\niter:  6650 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2314) , time:  0.002623319625854492\niter:  6700 , fixed pt res:  tensor(0.0471) , ls:  1 , rel_err:  tensor(0.2334) , time:  0.0026040077209472656\niter:  6750 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2349) , time:  0.002633333206176758\niter:  6800 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2346) , time:  0.0026187896728515625\niter:  6850 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2335) , time:  0.002584218978881836\niter:  6900 , fixed pt res:  tensor(0.0478) , ls:  1 , rel_err:  tensor(0.2362) , time:  0.002745389938354492\niter:  6950 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2329) , time:  0.00258636474609375\niter:  7000 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2421) , time:  0.002652883529663086\niter:  7050 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.2474) , time:  0.0026178359985351562\niter:  7100 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(0.2483) , time:  0.0026175975799560547\niter:  7150 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2538) , time:  0.0026121139526367188\niter:  7200 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2634) , time:  0.0026302337646484375\niter:  7250 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2635) , time:  0.002633333206176758\niter:  7300 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2602) , time:  0.0025920867919921875\niter:  7350 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2569) , time:  0.00262451171875\niter:  7400 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2582) , time:  0.0026018619537353516\niter:  7450 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2591) , time:  0.002658367156982422\niter:  7500 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2521) , time:  0.0026044845581054688\niter:  7550 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2517) , time:  0.002680063247680664\niter:  7600 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(0.2522) , time:  0.002724170684814453\niter:  7650 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2457) , time:  0.002649068832397461\niter:  7700 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2462) , time:  0.002586841583251953\niter:  7750 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2563) , time:  0.0026137828826904297\niter:  7800 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2561) , time:  0.002600431442260742\niter:  7850 , fixed pt res:  tensor(0.0464) , ls:  1 , rel_err:  tensor(0.2601) , time:  0.002637147903442383\niter:  7900 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2634) , time:  0.0025911331176757812\niter:  7950 , fixed pt res:  tensor(0.0480) , ls:  1 , rel_err:  tensor(0.2607) , time:  0.0025832653045654297\niter:  8000 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2636) , time:  0.0030062198638916016\niter:  8050 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(0.2702) , time:  0.0026273727416992188\niter:  8100 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2676) , time:  0.0026102066040039062\niter:  8150 , fixed pt res:  tensor(0.0474) , ls:  1 , rel_err:  tensor(0.2655) , time:  0.002643108367919922\niter:  8200 , fixed pt res:  tensor(0.0470) , ls:  1 , rel_err:  tensor(0.2644) , time:  0.002836942672729492\niter:  8250 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2599) , time:  0.0026481151580810547\niter:  8300 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(0.2528) , time:  0.0026917457580566406\niter:  8350 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2515) , time:  0.002638101577758789\niter:  8400 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2581) , time:  0.0026161670684814453\niter:  8450 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2615) , time:  0.0026121139526367188\niter:  8500 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2630) , time:  0.002630472183227539\niter:  8550 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.2544) , time:  0.0026378631591796875\niter:  8600 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.2536) , time:  0.0028374195098876953\niter:  8650 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.2555) , time:  0.0026123523712158203\niter:  8700 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2586) , time:  0.0026521682739257812\niter:  8750 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2590) , time:  0.0026025772094726562\niter:  8800 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2606) , time:  0.0026471614837646484\niter:  8850 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(0.2578) , time:  0.0026187896728515625\niter:  8900 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2623) , time:  0.002620697021484375\niter:  8950 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2704) , time:  0.002619504928588867\niter:  9000 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(0.2746) , time:  0.00292205810546875\niter:  9050 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2834) , time:  0.002611875534057617\niter:  9100 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2765) , time:  0.002656698226928711\niter:  9150 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2818) , time:  0.0026679039001464844\niter:  9200 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2774) , time:  0.002641916275024414\niter:  9250 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2712) , time:  0.0025887489318847656\niter:  9300 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2731) , time:  0.002611875534057617\niter:  9350 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2686) , time:  0.002651691436767578\niter:  9400 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2698) , time:  0.0026099681854248047\niter:  9450 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2642) , time:  0.002611398696899414\niter:  9500 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(0.2521) , time:  0.0028138160705566406\niter:  9550 , fixed pt res:  tensor(0.0478) , ls:  1 , rel_err:  tensor(0.2604) , time:  0.002634763717651367\niter:  9600 , fixed pt res:  tensor(0.0476) , ls:  1 , rel_err:  tensor(0.2566) , time:  0.0026116371154785156\niter:  9650 , fixed pt res:  tensor(0.0473) , ls:  1 , rel_err:  tensor(0.2515) , time:  0.002725362777709961\niter:  9700 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2516) , time:  0.0025947093963623047\niter:  9750 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2511) , time:  0.0026650428771972656\niter:  9800 , fixed pt res:  tensor(0.0480) , ls:  1 , rel_err:  tensor(0.2353) , time:  0.002584218978881836\niter:  9850 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2436) , time:  0.0028257369995117188\niter:  9900 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2401) , time:  0.002621173858642578\niter:  9950 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2476) , time:  0.002672910690307617\niter:  10000 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2453) , time:  0.0026237964630126953\ntrial  1  finished after 27.315054655075073\n\n\n\n\n CHANGE, delta =  1.0\nnorm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) =  tensor(0.)\ndelta = 10\niter:  50 , fixed pt res:  tensor(0.6019) , ls:  1 , rel_err:  tensor(15.2753) , time:  0.0026540756225585938\niter:  100 , fixed pt res:  tensor(0.2578) , ls:  1 , rel_err:  tensor(14.1615) , time:  0.0026514530181884766\niter:  150 , fixed pt res:  tensor(0.1269) , ls:  1 , rel_err:  tensor(13.2275) , time:  0.0026235580444335938\niter:  200 , fixed pt res:  tensor(0.0762) , ls:  1 , rel_err:  tensor(12.3565) , time:  0.002614736557006836\niter:  250 , fixed pt res:  tensor(0.0597) , ls:  1 , rel_err:  tensor(11.5210) , time:  0.002669095993041992\niter:  300 , fixed pt res:  tensor(0.0571) , ls:  1 , rel_err:  tensor(10.7411) , time:  0.0026438236236572266\niter:  350 , fixed pt res:  tensor(0.0520) , ls:  1 , rel_err:  tensor(10.0191) , time:  0.002608060836791992\niter:  400 , fixed pt res:  tensor(0.0518) , ls:  1 , rel_err:  tensor(9.3347) , time:  0.0026454925537109375\niter:  450 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(8.6942) , time:  0.002699136734008789\niter:  500 , fixed pt res:  tensor(0.0485) , ls:  1 , rel_err:  tensor(8.0995) , time:  0.002779245376586914\niter:  550 , fixed pt res:  tensor(0.0510) , ls:  1 , rel_err:  tensor(7.5484) , time:  0.0026400089263916016\niter:  600 , fixed pt res:  tensor(0.0489) , ls:  1 , rel_err:  tensor(7.0212) , time:  0.0026590824127197266\niter:  650 , fixed pt res:  tensor(0.0483) , ls:  1 , rel_err:  tensor(6.5332) , time:  0.0026786327362060547\niter:  700 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(6.0990) , time:  0.002670764923095703\niter:  750 , fixed pt res:  tensor(0.0494) , ls:  1 , rel_err:  tensor(5.6841) , time:  0.0026121139526367188\niter:  800 , fixed pt res:  tensor(0.0467) , ls:  1 , rel_err:  tensor(5.3001) , time:  0.002619504928588867\niter:  850 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(4.9403) , time:  0.002660512924194336\niter:  900 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(4.5992) , time:  0.002605438232421875\niter:  950 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(4.3029) , time:  0.0026481151580810547\niter:  1000 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(4.0176) , time:  0.002672910690307617\niter:  1050 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(3.7485) , time:  0.0026397705078125\niter:  1100 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(3.5050) , time:  0.0026443004608154297\niter:  1150 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(3.2698) , time:  0.002622842788696289\niter:  1200 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(3.0443) , time:  0.0027205944061279297\niter:  1250 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(2.8493) , time:  0.002618551254272461\niter:  1300 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(2.6783) , time:  0.0026373863220214844\niter:  1350 , fixed pt res:  tensor(0.0414) , ls:  1 , rel_err:  tensor(2.5112) , time:  0.0026564598083496094\niter:  1400 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(2.3520) , time:  0.0026865005493164062\niter:  1450 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(2.2008) , time:  0.0027163028717041016\niter:  1500 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(2.0657) , time:  0.0026688575744628906\niter:  1550 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(1.9482) , time:  0.002709627151489258\niter:  1600 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(1.8259) , time:  0.0026383399963378906\niter:  1650 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.7236) , time:  0.0026502609252929688\niter:  1700 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(1.6258) , time:  0.0026776790618896484\niter:  1750 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(1.5325) , time:  0.002692699432373047\niter:  1800 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(1.4510) , time:  0.0027060508728027344\niter:  1850 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(1.3683) , time:  0.0026793479919433594\niter:  1900 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(1.2950) , time:  0.002918243408203125\niter:  1950 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.2262) , time:  0.0026624202728271484\niter:  2000 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(1.1582) , time:  0.0028617382049560547\niter:  2050 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(1.1049) , time:  0.002691507339477539\niter:  2100 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(1.0510) , time:  0.0027077198028564453\niter:  2150 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.9996) , time:  0.0026416778564453125\niter:  2200 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.9575) , time:  0.002642393112182617\niter:  2250 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.9075) , time:  0.002653837203979492\niter:  2300 , fixed pt res:  tensor(0.0430) , ls:  1 , rel_err:  tensor(0.8576) , time:  0.002691984176635742\niter:  2350 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.8157) , time:  0.002669811248779297\niter:  2400 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.7775) , time:  0.002611398696899414\niter:  2450 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.7434) , time:  0.002624034881591797\niter:  2500 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.7074) , time:  0.0026209354400634766\niter:  2550 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.6806) , time:  0.0026488304138183594\niter:  2600 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.6435) , time:  0.002690553665161133\niter:  2650 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.6135) , time:  0.0027344226837158203\niter:  2700 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.5929) , time:  0.002749204635620117\niter:  2750 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.5653) , time:  0.0027985572814941406\niter:  2800 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.5382) , time:  0.002658843994140625\niter:  2850 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.5252) , time:  0.002630949020385742\niter:  2900 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.5129) , time:  0.002830982208251953\niter:  2950 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.4813) , time:  0.0026781558990478516\niter:  3000 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.4677) , time:  0.0026559829711914062\niter:  3050 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.4501) , time:  0.002631664276123047\niter:  3100 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.4472) , time:  0.0026276111602783203\niter:  3150 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.4336) , time:  0.002597808837890625\niter:  3200 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.4200) , time:  0.002661466598510742\niter:  3250 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.4142) , time:  0.002621889114379883\niter:  3300 , fixed pt res:  tensor(0.0421) , ls:  1 , rel_err:  tensor(0.3954) , time:  0.002713441848754883\niter:  3350 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.3863) , time:  0.0026400089263916016\niter:  3400 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.3733) , time:  0.002678394317626953\niter:  3450 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.3668) , time:  0.002679109573364258\niter:  3500 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.3535) , time:  0.0026700496673583984\niter:  3550 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.3507) , time:  0.0026290416717529297\niter:  3600 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.3416) , time:  0.0026311874389648438\niter:  3650 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.3300) , time:  0.0027027130126953125\niter:  3700 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.3323) , time:  0.0026731491088867188\niter:  3750 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.3244) , time:  0.002677440643310547\niter:  3800 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.3207) , time:  0.0026001930236816406\niter:  3850 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.3108) , time:  0.0026946067810058594\niter:  3900 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.3088) , time:  0.0026557445526123047\niter:  3950 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.3105) , time:  0.0026497840881347656\niter:  4000 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.3087) , time:  0.002724170684814453\niter:  4050 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.3149) , time:  0.002661466598510742\niter:  4100 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.3114) , time:  0.0026755332946777344\niter:  4150 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.3084) , time:  0.002646923065185547\niter:  4200 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.3067) , time:  0.0026345252990722656\niter:  4250 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2983) , time:  0.002586841583251953\niter:  4300 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.3007) , time:  0.002732515335083008\niter:  4350 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2996) , time:  0.00261688232421875\niter:  4400 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2934) , time:  0.002596139907836914\niter:  4450 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2900) , time:  0.002726316452026367\niter:  4500 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2807) , time:  0.002689361572265625\niter:  4550 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2853) , time:  0.0026869773864746094\niter:  4600 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2876) , time:  0.0026433467864990234\niter:  4650 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2823) , time:  0.0026700496673583984\niter:  4700 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2841) , time:  0.0026471614837646484\niter:  4750 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2762) , time:  0.0026712417602539062\niter:  4800 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2731) , time:  0.002760648727416992\niter:  4850 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2585) , time:  0.002687215805053711\niter:  4900 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2593) , time:  0.00275421142578125\niter:  4950 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2579) , time:  0.0027098655700683594\niter:  5000 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2592) , time:  0.002589702606201172\niter:  5050 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2644) , time:  0.0025992393493652344\niter:  5100 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2573) , time:  0.002879619598388672\niter:  5150 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2536) , time:  0.002627849578857422\niter:  5200 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2591) , time:  0.002704143524169922\niter:  5250 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2442) , time:  0.002785921096801758\niter:  5300 , fixed pt res:  tensor(0.0469) , ls:  1 , rel_err:  tensor(0.2435) , time:  0.0026731491088867188\niter:  5350 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2527) , time:  0.0026497840881347656\niter:  5400 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2567) , time:  0.002666473388671875\niter:  5450 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2584) , time:  0.0027420520782470703\niter:  5500 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2566) , time:  0.002741575241088867\niter:  5550 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.2675) , time:  0.0027132034301757812\niter:  5600 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2643) , time:  0.002718210220336914\niter:  5650 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2668) , time:  0.002752065658569336\niter:  5700 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2581) , time:  0.0026581287384033203\niter:  5750 , fixed pt res:  tensor(0.0428) , ls:  1 , rel_err:  tensor(0.2603) , time:  0.002724170684814453\niter:  5800 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2698) , time:  0.0027420520782470703\niter:  5850 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2633) , time:  0.0026688575744628906\niter:  5900 , fixed pt res:  tensor(0.0430) , ls:  1 , rel_err:  tensor(0.2637) , time:  0.0026891231536865234\niter:  5950 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2634) , time:  0.002692699432373047\niter:  6000 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2569) , time:  0.002665996551513672\niter:  6050 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2561) , time:  0.002684354782104492\niter:  6100 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2504) , time:  0.002671957015991211\niter:  6150 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2581) , time:  0.0026755332946777344\niter:  6200 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2574) , time:  0.0026607513427734375\niter:  6250 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2477) , time:  0.002636432647705078\niter:  6300 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2521) , time:  0.0027189254760742188\niter:  6350 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2508) , time:  0.0027017593383789062\niter:  6400 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2479) , time:  0.0026891231536865234\niter:  6450 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2471) , time:  0.002687692642211914\niter:  6500 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2560) , time:  0.002639293670654297\niter:  6550 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2571) , time:  0.002622842788696289\niter:  6600 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2565) , time:  0.0026454925537109375\niter:  6650 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2631) , time:  0.002637147903442383\niter:  6700 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2600) , time:  0.0026543140411376953\niter:  6750 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2621) , time:  0.00264739990234375\niter:  6800 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2623) , time:  0.0032041072845458984\niter:  6850 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2492) , time:  0.0026340484619140625\niter:  6900 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2476) , time:  0.002618551254272461\niter:  6950 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2500) , time:  0.0026683807373046875\niter:  7000 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2462) , time:  0.0026750564575195312\niter:  7050 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2455) , time:  0.0026268959045410156\niter:  7100 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2419) , time:  0.0026750564575195312\niter:  7150 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2353) , time:  0.0025870800018310547\niter:  7200 , fixed pt res:  tensor(0.0426) , ls:  1 , rel_err:  tensor(0.2313) , time:  0.0027091503143310547\niter:  7250 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2405) , time:  0.0025959014892578125\niter:  7300 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2351) , time:  0.0026917457580566406\niter:  7350 , fixed pt res:  tensor(0.0419) , ls:  1 , rel_err:  tensor(0.2425) , time:  0.0026624202728271484\niter:  7400 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.2339) , time:  0.002680063247680664\niter:  7450 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2306) , time:  0.0026695728302001953\niter:  7500 , fixed pt res:  tensor(0.0420) , ls:  1 , rel_err:  tensor(0.2351) , time:  0.0026400089263916016\niter:  7550 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2418) , time:  0.0026137828826904297\niter:  7600 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2372) , time:  0.0026285648345947266\niter:  7650 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2312) , time:  0.002652406692504883\niter:  7700 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2385) , time:  0.0028412342071533203\niter:  7750 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2259) , time:  0.002637147903442383\niter:  7800 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2300) , time:  0.0027627944946289062\niter:  7850 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2300) , time:  0.0026209354400634766\niter:  7900 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2359) , time:  0.0027120113372802734\niter:  7950 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2265) , time:  0.002808094024658203\niter:  8000 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.2234) , time:  0.002773761749267578\niter:  8050 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2249) , time:  0.0026445388793945312\niter:  8100 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2226) , time:  0.0027518272399902344\niter:  8150 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2228) , time:  0.0026426315307617188\niter:  8200 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.2248) , time:  0.002750873565673828\niter:  8250 , fixed pt res:  tensor(0.0421) , ls:  1 , rel_err:  tensor(0.2283) , time:  0.002641439437866211\niter:  8300 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2306) , time:  0.0026345252990722656\niter:  8350 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2301) , time:  0.002625703811645508\niter:  8400 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.2244) , time:  0.0026750564575195312\niter:  8450 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2286) , time:  0.0026092529296875\niter:  8500 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2295) , time:  0.0026237964630126953\niter:  8550 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2288) , time:  0.0026187896728515625\niter:  8600 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2285) , time:  0.002825498580932617\niter:  8650 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2294) , time:  0.002656698226928711\niter:  8700 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2260) , time:  0.002588033676147461\niter:  8750 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2314) , time:  0.0026361942291259766\niter:  8800 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2353) , time:  0.0026760101318359375\niter:  8850 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2314) , time:  0.0026254653930664062\niter:  8900 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2321) , time:  0.002634763717651367\niter:  8950 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2350) , time:  0.0026259422302246094\niter:  9000 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2309) , time:  0.002634763717651367\niter:  9050 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2292) , time:  0.0026578903198242188\niter:  9100 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2276) , time:  0.002710580825805664\niter:  9150 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2342) , time:  0.002606630325317383\niter:  9200 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2367) , time:  0.0026199817657470703\niter:  9250 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2335) , time:  0.002606630325317383\niter:  9300 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2380) , time:  0.0026226043701171875\niter:  9350 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2328) , time:  0.002691030502319336\niter:  9400 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2285) , time:  0.0028655529022216797\niter:  9450 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2304) , time:  0.0026679039001464844\niter:  9500 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2202) , time:  0.002732515335083008\niter:  9550 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2295) , time:  0.0026450157165527344\niter:  9600 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2291) , time:  0.0028519630432128906\niter:  9650 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2385) , time:  0.0026679039001464844\niter:  9700 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2467) , time:  0.0026292800903320312\niter:  9750 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2429) , time:  0.0026733875274658203\niter:  9800 , fixed pt res:  tensor(0.0428) , ls:  1 , rel_err:  tensor(0.2391) , time:  0.002670764923095703\niter:  9850 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2349) , time:  0.0026319026947021484\niter:  9900 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2392) , time:  0.0026323795318603516\niter:  9950 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2395) , time:  0.002651691436767578\niter:  10000 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2342) , time:  0.0026276111602783203\ntrial  1  finished after 27.629093647003174\n\n\n\n\n CHANGE, delta =  10\nnorm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) =  tensor(0.)\ndelta = 100\niter:  50 , fixed pt res:  tensor(0.6023) , ls:  1 , rel_err:  tensor(15.2866) , time:  0.0026459693908691406\niter:  100 , fixed pt res:  tensor(0.2743) , ls:  1 , rel_err:  tensor(14.2015) , time:  0.002714872360229492\niter:  150 , fixed pt res:  tensor(0.1567) , ls:  1 , rel_err:  tensor(13.2935) , time:  0.0026772022247314453\niter:  200 , fixed pt res:  tensor(0.1120) , ls:  1 , rel_err:  tensor(12.4750) , time:  0.002736330032348633\niter:  250 , fixed pt res:  tensor(0.1090) , ls:  1 , rel_err:  tensor(11.7074) , time:  0.0026776790618896484\niter:  300 , fixed pt res:  tensor(0.1033) , ls:  1 , rel_err:  tensor(10.9887) , time:  0.002933025360107422\niter:  350 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(10.3216) , time:  0.0027055740356445312\niter:  400 , fixed pt res:  tensor(0.0972) , ls:  1 , rel_err:  tensor(9.7369) , time:  0.0026187896728515625\niter:  450 , fixed pt res:  tensor(0.0987) , ls:  1 , rel_err:  tensor(9.1810) , time:  0.0026667118072509766\niter:  500 , fixed pt res:  tensor(0.1002) , ls:  1 , rel_err:  tensor(8.6461) , time:  0.0026848316192626953\niter:  550 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(8.1415) , time:  0.0026662349700927734\niter:  600 , fixed pt res:  tensor(0.1000) , ls:  1 , rel_err:  tensor(7.6925) , time:  0.0027320384979248047\niter:  650 , fixed pt res:  tensor(0.0998) , ls:  1 , rel_err:  tensor(7.2723) , time:  0.002678394317626953\niter:  700 , fixed pt res:  tensor(0.0997) , ls:  1 , rel_err:  tensor(6.8970) , time:  0.0026404857635498047\niter:  750 , fixed pt res:  tensor(0.0987) , ls:  1 , rel_err:  tensor(6.5439) , time:  0.0026535987854003906\niter:  800 , fixed pt res:  tensor(0.0996) , ls:  1 , rel_err:  tensor(6.2256) , time:  0.002608060836791992\niter:  850 , fixed pt res:  tensor(0.0970) , ls:  1 , rel_err:  tensor(5.9144) , time:  0.002660036087036133\niter:  900 , fixed pt res:  tensor(0.0996) , ls:  1 , rel_err:  tensor(5.6303) , time:  0.002655029296875\niter:  950 , fixed pt res:  tensor(0.0964) , ls:  1 , rel_err:  tensor(5.3909) , time:  0.0026865005493164062\niter:  1000 , fixed pt res:  tensor(0.0943) , ls:  1 , rel_err:  tensor(5.1599) , time:  0.002641916275024414\niter:  1050 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(4.9327) , time:  0.002622365951538086\niter:  1100 , fixed pt res:  tensor(0.0976) , ls:  1 , rel_err:  tensor(4.7290) , time:  0.002641916275024414\niter:  1150 , fixed pt res:  tensor(0.1019) , ls:  1 , rel_err:  tensor(4.5391) , time:  0.00260162353515625\niter:  1200 , fixed pt res:  tensor(0.0966) , ls:  1 , rel_err:  tensor(4.3715) , time:  0.002603292465209961\niter:  1250 , fixed pt res:  tensor(0.0969) , ls:  1 , rel_err:  tensor(4.1634) , time:  0.002655506134033203\niter:  1300 , fixed pt res:  tensor(0.0937) , ls:  1 , rel_err:  tensor(4.0231) , time:  0.00273895263671875\niter:  1350 , fixed pt res:  tensor(0.1010) , ls:  1 , rel_err:  tensor(3.8837) , time:  0.002590179443359375\niter:  1400 , fixed pt res:  tensor(0.0976) , ls:  1 , rel_err:  tensor(3.7580) , time:  0.0026481151580810547\niter:  1450 , fixed pt res:  tensor(0.0942) , ls:  1 , rel_err:  tensor(3.6261) , time:  0.0025975704193115234\niter:  1500 , fixed pt res:  tensor(0.0992) , ls:  1 , rel_err:  tensor(3.5287) , time:  0.0029494762420654297\niter:  1550 , fixed pt res:  tensor(0.0973) , ls:  1 , rel_err:  tensor(3.4125) , time:  0.002590179443359375\niter:  1600 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(3.2955) , time:  0.002639293670654297\niter:  1650 , fixed pt res:  tensor(0.1037) , ls:  1 , rel_err:  tensor(3.1531) , time:  0.002641439437866211\niter:  1700 , fixed pt res:  tensor(0.0973) , ls:  1 , rel_err:  tensor(3.0603) , time:  0.002615690231323242\niter:  1750 , fixed pt res:  tensor(0.0964) , ls:  1 , rel_err:  tensor(2.9629) , time:  0.002638578414916992\niter:  1800 , fixed pt res:  tensor(0.1004) , ls:  1 , rel_err:  tensor(2.8633) , time:  0.002737760543823242\niter:  1850 , fixed pt res:  tensor(0.1000) , ls:  1 , rel_err:  tensor(2.7754) , time:  0.002644777297973633\niter:  1900 , fixed pt res:  tensor(0.0986) , ls:  1 , rel_err:  tensor(2.7222) , time:  0.0027008056640625\niter:  1950 , fixed pt res:  tensor(0.0954) , ls:  1 , rel_err:  tensor(2.6393) , time:  0.002593517303466797\niter:  2000 , fixed pt res:  tensor(0.0967) , ls:  1 , rel_err:  tensor(2.5414) , time:  0.002609729766845703\niter:  2050 , fixed pt res:  tensor(0.0985) , ls:  1 , rel_err:  tensor(2.4807) , time:  0.0025920867919921875\niter:  2100 , fixed pt res:  tensor(0.1011) , ls:  1 , rel_err:  tensor(2.4069) , time:  0.002677440643310547\niter:  2150 , fixed pt res:  tensor(0.1029) , ls:  1 , rel_err:  tensor(2.3481) , time:  0.002691984176635742\niter:  2200 , fixed pt res:  tensor(0.0995) , ls:  1 , rel_err:  tensor(2.3009) , time:  0.002658843994140625\niter:  2250 , fixed pt res:  tensor(0.0974) , ls:  1 , rel_err:  tensor(2.2204) , time:  0.002644777297973633\niter:  2300 , fixed pt res:  tensor(0.0958) , ls:  1 , rel_err:  tensor(2.1699) , time:  0.0026183128356933594\niter:  2350 , fixed pt res:  tensor(0.0962) , ls:  1 , rel_err:  tensor(2.1140) , time:  0.0026688575744628906\niter:  2400 , fixed pt res:  tensor(0.0949) , ls:  1 , rel_err:  tensor(2.0510) , time:  0.002635955810546875\niter:  2450 , fixed pt res:  tensor(0.1010) , ls:  1 , rel_err:  tensor(1.9629) , time:  0.002660036087036133\niter:  2500 , fixed pt res:  tensor(0.0966) , ls:  1 , rel_err:  tensor(1.9201) , time:  0.0028488636016845703\niter:  2550 , fixed pt res:  tensor(0.0983) , ls:  1 , rel_err:  tensor(1.8688) , time:  0.0026946067810058594\niter:  2600 , fixed pt res:  tensor(0.0928) , ls:  1 , rel_err:  tensor(1.8419) , time:  0.0028378963470458984\niter:  2650 , fixed pt res:  tensor(0.1003) , ls:  1 , rel_err:  tensor(1.7858) , time:  0.0026476383209228516\niter:  2700 , fixed pt res:  tensor(0.0988) , ls:  1 , rel_err:  tensor(1.7670) , time:  0.0026540756225585938\niter:  2750 , fixed pt res:  tensor(0.1000) , ls:  1 , rel_err:  tensor(1.7203) , time:  0.002648591995239258\niter:  2800 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(1.6839) , time:  0.002696990966796875\niter:  2850 , fixed pt res:  tensor(0.0967) , ls:  1 , rel_err:  tensor(1.6716) , time:  0.0027446746826171875\niter:  2900 , fixed pt res:  tensor(0.0982) , ls:  1 , rel_err:  tensor(1.6258) , time:  0.002668619155883789\niter:  2950 , fixed pt res:  tensor(0.0991) , ls:  1 , rel_err:  tensor(1.5811) , time:  0.0026657581329345703\niter:  3000 , fixed pt res:  tensor(0.1003) , ls:  1 , rel_err:  tensor(1.5758) , time:  0.002733945846557617\niter:  3050 , fixed pt res:  tensor(0.0959) , ls:  1 , rel_err:  tensor(1.5285) , time:  0.0026404857635498047\niter:  3100 , fixed pt res:  tensor(0.0985) , ls:  1 , rel_err:  tensor(1.4862) , time:  0.0026612281799316406\niter:  3150 , fixed pt res:  tensor(0.0980) , ls:  1 , rel_err:  tensor(1.4581) , time:  0.002658843994140625\niter:  3200 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(1.4271) , time:  0.002880096435546875\niter:  3250 , fixed pt res:  tensor(0.0999) , ls:  1 , rel_err:  tensor(1.4019) , time:  0.002668619155883789\niter:  3300 , fixed pt res:  tensor(0.1013) , ls:  1 , rel_err:  tensor(1.3836) , time:  0.0028009414672851562\niter:  3350 , fixed pt res:  tensor(0.0952) , ls:  1 , rel_err:  tensor(1.3714) , time:  0.0027768611907958984\niter:  3400 , fixed pt res:  tensor(0.0960) , ls:  1 , rel_err:  tensor(1.3542) , time:  0.002624988555908203\niter:  3450 , fixed pt res:  tensor(0.0976) , ls:  1 , rel_err:  tensor(1.3573) , time:  0.002659320831298828\niter:  3500 , fixed pt res:  tensor(0.0967) , ls:  1 , rel_err:  tensor(1.3376) , time:  0.002629518508911133\niter:  3550 , fixed pt res:  tensor(0.0979) , ls:  1 , rel_err:  tensor(1.3192) , time:  0.0026197433471679688\niter:  3600 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(1.3276) , time:  0.0026237964630126953\niter:  3650 , fixed pt res:  tensor(0.0979) , ls:  1 , rel_err:  tensor(1.3151) , time:  0.002643108367919922\niter:  3700 , fixed pt res:  tensor(0.0990) , ls:  1 , rel_err:  tensor(1.2869) , time:  0.0025787353515625\niter:  3750 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(1.2659) , time:  0.0026044845581054688\niter:  3800 , fixed pt res:  tensor(0.0971) , ls:  1 , rel_err:  tensor(1.2559) , time:  0.0027234554290771484\niter:  3850 , fixed pt res:  tensor(0.0954) , ls:  1 , rel_err:  tensor(1.2633) , time:  0.0026369094848632812\niter:  3900 , fixed pt res:  tensor(0.0973) , ls:  1 , rel_err:  tensor(1.2327) , time:  0.0026540756225585938\niter:  3950 , fixed pt res:  tensor(0.0986) , ls:  1 , rel_err:  tensor(1.1850) , time:  0.002602815628051758\niter:  4000 , fixed pt res:  tensor(0.0990) , ls:  1 , rel_err:  tensor(1.1821) , time:  0.0025894641876220703\niter:  4050 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(1.1858) , time:  0.002626657485961914\niter:  4100 , fixed pt res:  tensor(0.0947) , ls:  1 , rel_err:  tensor(1.1439) , time:  0.002600431442260742\niter:  4150 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(1.1387) , time:  0.0026493072509765625\niter:  4200 , fixed pt res:  tensor(0.0996) , ls:  1 , rel_err:  tensor(1.1192) , time:  0.0028383731842041016\niter:  4250 , fixed pt res:  tensor(0.0949) , ls:  1 , rel_err:  tensor(1.0881) , time:  0.0027513504028320312\niter:  4300 , fixed pt res:  tensor(0.0958) , ls:  1 , rel_err:  tensor(1.0803) , time:  0.0026311874389648438\niter:  4350 , fixed pt res:  tensor(0.0997) , ls:  1 , rel_err:  tensor(1.0660) , time:  0.0026144981384277344\niter:  4400 , fixed pt res:  tensor(0.0955) , ls:  1 , rel_err:  tensor(1.0327) , time:  0.0026459693908691406\niter:  4450 , fixed pt res:  tensor(0.0964) , ls:  1 , rel_err:  tensor(1.0417) , time:  0.002648591995239258\niter:  4500 , fixed pt res:  tensor(0.0976) , ls:  1 , rel_err:  tensor(1.0445) , time:  0.002627849578857422\niter:  4550 , fixed pt res:  tensor(0.0935) , ls:  1 , rel_err:  tensor(1.0299) , time:  0.002614736557006836\niter:  4600 , fixed pt res:  tensor(0.0952) , ls:  1 , rel_err:  tensor(1.0165) , time:  0.0026810169219970703\niter:  4650 , fixed pt res:  tensor(0.0977) , ls:  1 , rel_err:  tensor(1.0161) , time:  0.0026397705078125\niter:  4700 , fixed pt res:  tensor(0.0997) , ls:  1 , rel_err:  tensor(1.0329) , time:  0.0026242733001708984\niter:  4750 , fixed pt res:  tensor(0.0987) , ls:  1 , rel_err:  tensor(1.0263) , time:  0.002673625946044922\niter:  4800 , fixed pt res:  tensor(0.0957) , ls:  1 , rel_err:  tensor(1.0179) , time:  0.0026826858520507812\niter:  4850 , fixed pt res:  tensor(0.0989) , ls:  1 , rel_err:  tensor(1.0152) , time:  0.002739429473876953\niter:  4900 , fixed pt res:  tensor(0.0958) , ls:  1 , rel_err:  tensor(1.0190) , time:  0.0026226043701171875\niter:  4950 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(1.0083) , time:  0.0027060508728027344\niter:  5000 , fixed pt res:  tensor(0.0958) , ls:  1 , rel_err:  tensor(0.9981) , time:  0.0026297569274902344\niter:  5050 , fixed pt res:  tensor(0.0980) , ls:  1 , rel_err:  tensor(0.9669) , time:  0.0026192665100097656\niter:  5100 , fixed pt res:  tensor(0.0957) , ls:  1 , rel_err:  tensor(0.9647) , time:  0.002637624740600586\niter:  5150 , fixed pt res:  tensor(0.0973) , ls:  1 , rel_err:  tensor(0.9442) , time:  0.002691030502319336\niter:  5200 , fixed pt res:  tensor(0.0995) , ls:  1 , rel_err:  tensor(0.9389) , time:  0.002645730972290039\niter:  5250 , fixed pt res:  tensor(0.1021) , ls:  1 , rel_err:  tensor(0.9361) , time:  0.0026426315307617188\niter:  5300 , fixed pt res:  tensor(0.0970) , ls:  1 , rel_err:  tensor(0.9394) , time:  0.0026667118072509766\niter:  5350 , fixed pt res:  tensor(0.0947) , ls:  1 , rel_err:  tensor(0.9366) , time:  0.0026564598083496094\niter:  5400 , fixed pt res:  tensor(0.0977) , ls:  1 , rel_err:  tensor(0.9341) , time:  0.002665281295776367\niter:  5450 , fixed pt res:  tensor(0.0952) , ls:  1 , rel_err:  tensor(0.9331) , time:  0.002624988555908203\niter:  5500 , fixed pt res:  tensor(0.0955) , ls:  1 , rel_err:  tensor(0.9150) , time:  0.0027475357055664062\niter:  5550 , fixed pt res:  tensor(0.1011) , ls:  1 , rel_err:  tensor(0.9156) , time:  0.0026793479919433594\niter:  5600 , fixed pt res:  tensor(0.0967) , ls:  1 , rel_err:  tensor(0.9214) , time:  0.003243684768676758\niter:  5650 , fixed pt res:  tensor(0.0969) , ls:  1 , rel_err:  tensor(0.9045) , time:  0.0027420520782470703\niter:  5700 , fixed pt res:  tensor(0.0970) , ls:  1 , rel_err:  tensor(0.9005) , time:  0.0028600692749023438\niter:  5750 , fixed pt res:  tensor(0.0975) , ls:  1 , rel_err:  tensor(0.8744) , time:  0.0026273727416992188\niter:  5800 , fixed pt res:  tensor(0.1004) , ls:  1 , rel_err:  tensor(0.8787) , time:  0.0026781558990478516\niter:  5850 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(0.8809) , time:  0.0026412010192871094\niter:  5900 , fixed pt res:  tensor(0.1017) , ls:  1 , rel_err:  tensor(0.8876) , time:  0.0027167797088623047\niter:  5950 , fixed pt res:  tensor(0.0959) , ls:  1 , rel_err:  tensor(0.9126) , time:  0.0028395652770996094\niter:  6000 , fixed pt res:  tensor(0.0977) , ls:  1 , rel_err:  tensor(0.9226) , time:  0.0026731491088867188\niter:  6050 , fixed pt res:  tensor(0.1001) , ls:  1 , rel_err:  tensor(0.9003) , time:  0.002645730972290039\niter:  6100 , fixed pt res:  tensor(0.0969) , ls:  1 , rel_err:  tensor(0.8834) , time:  0.0027151107788085938\niter:  6150 , fixed pt res:  tensor(0.0941) , ls:  1 , rel_err:  tensor(0.8768) , time:  0.002652406692504883\niter:  6200 , fixed pt res:  tensor(0.0940) , ls:  1 , rel_err:  tensor(0.8559) , time:  0.002678394317626953\niter:  6250 , fixed pt res:  tensor(0.1001) , ls:  1 , rel_err:  tensor(0.8983) , time:  0.002643585205078125\niter:  6300 , fixed pt res:  tensor(0.0964) , ls:  1 , rel_err:  tensor(0.8749) , time:  0.0027146339416503906\niter:  6350 , fixed pt res:  tensor(0.1014) , ls:  1 , rel_err:  tensor(0.8756) , time:  0.0026204586029052734\niter:  6400 , fixed pt res:  tensor(0.0987) , ls:  1 , rel_err:  tensor(0.8709) , time:  0.003339052200317383\niter:  6450 , fixed pt res:  tensor(0.0978) , ls:  1 , rel_err:  tensor(0.8542) , time:  0.002626180648803711\niter:  6500 , fixed pt res:  tensor(0.0923) , ls:  1 , rel_err:  tensor(0.8736) , time:  0.0028307437896728516\niter:  6550 , fixed pt res:  tensor(0.1011) , ls:  1 , rel_err:  tensor(0.8672) , time:  0.00263214111328125\niter:  6600 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(0.8565) , time:  0.002622842788696289\niter:  6650 , fixed pt res:  tensor(0.0956) , ls:  1 , rel_err:  tensor(0.8584) , time:  0.002637147903442383\niter:  6700 , fixed pt res:  tensor(0.1013) , ls:  1 , rel_err:  tensor(0.8428) , time:  0.0026862621307373047\niter:  6750 , fixed pt res:  tensor(0.0975) , ls:  1 , rel_err:  tensor(0.8281) , time:  0.0026366710662841797\niter:  6800 , fixed pt res:  tensor(0.1006) , ls:  1 , rel_err:  tensor(0.8326) , time:  0.002646207809448242\niter:  6850 , fixed pt res:  tensor(0.0989) , ls:  1 , rel_err:  tensor(0.8473) , time:  0.002773284912109375\niter:  6900 , fixed pt res:  tensor(0.0977) , ls:  1 , rel_err:  tensor(0.8323) , time:  0.002663850784301758\niter:  6950 , fixed pt res:  tensor(0.0964) , ls:  1 , rel_err:  tensor(0.8157) , time:  0.0027344226837158203\niter:  7000 , fixed pt res:  tensor(0.0948) , ls:  1 , rel_err:  tensor(0.7917) , time:  0.0026133060455322266\niter:  7050 , fixed pt res:  tensor(0.0980) , ls:  1 , rel_err:  tensor(0.7897) , time:  0.002618551254272461\niter:  7100 , fixed pt res:  tensor(0.0989) , ls:  1 , rel_err:  tensor(0.8002) , time:  0.0026454925537109375\niter:  7150 , fixed pt res:  tensor(0.0995) , ls:  1 , rel_err:  tensor(0.7800) , time:  0.0026922225952148438\niter:  7200 , fixed pt res:  tensor(0.0969) , ls:  1 , rel_err:  tensor(0.7724) , time:  0.002665281295776367\niter:  7250 , fixed pt res:  tensor(0.0959) , ls:  1 , rel_err:  tensor(0.7787) , time:  0.0026602745056152344\niter:  7300 , fixed pt res:  tensor(0.0984) , ls:  1 , rel_err:  tensor(0.7685) , time:  0.002656698226928711\niter:  7350 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(0.7541) , time:  0.0026764869689941406\niter:  7400 , fixed pt res:  tensor(0.0967) , ls:  1 , rel_err:  tensor(0.7528) , time:  0.0027091503143310547\niter:  7450 , fixed pt res:  tensor(0.0977) , ls:  1 , rel_err:  tensor(0.7571) , time:  0.0026578903198242188\niter:  7500 , fixed pt res:  tensor(0.1019) , ls:  1 , rel_err:  tensor(0.7803) , time:  0.002628326416015625\niter:  7550 , fixed pt res:  tensor(0.0989) , ls:  1 , rel_err:  tensor(0.7855) , time:  0.002618551254272461\niter:  7600 , fixed pt res:  tensor(0.0959) , ls:  1 , rel_err:  tensor(0.7927) , time:  0.0026383399963378906\niter:  7650 , fixed pt res:  tensor(0.0991) , ls:  1 , rel_err:  tensor(0.8163) , time:  0.0029609203338623047\niter:  7700 , fixed pt res:  tensor(0.0986) , ls:  1 , rel_err:  tensor(0.8069) , time:  0.0026159286499023438\niter:  7750 , fixed pt res:  tensor(0.0966) , ls:  1 , rel_err:  tensor(0.8106) , time:  0.002648591995239258\niter:  7800 , fixed pt res:  tensor(0.0994) , ls:  1 , rel_err:  tensor(0.8216) , time:  0.002741098403930664\niter:  7850 , fixed pt res:  tensor(0.0960) , ls:  1 , rel_err:  tensor(0.8073) , time:  0.0026519298553466797\niter:  7900 , fixed pt res:  tensor(0.0990) , ls:  1 , rel_err:  tensor(0.7909) , time:  0.0027015209197998047\niter:  7950 , fixed pt res:  tensor(0.0944) , ls:  1 , rel_err:  tensor(0.7850) , time:  0.0027010440826416016\niter:  8000 , fixed pt res:  tensor(0.0987) , ls:  1 , rel_err:  tensor(0.7983) , time:  0.0026674270629882812\niter:  8050 , fixed pt res:  tensor(0.0946) , ls:  1 , rel_err:  tensor(0.8124) , time:  0.002661466598510742\niter:  8100 , fixed pt res:  tensor(0.0938) , ls:  1 , rel_err:  tensor(0.8342) , time:  0.0027573108673095703\niter:  8150 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(0.8350) , time:  0.0026941299438476562\niter:  8200 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(0.8280) , time:  0.0026400089263916016\niter:  8250 , fixed pt res:  tensor(0.0975) , ls:  1 , rel_err:  tensor(0.8259) , time:  0.0026302337646484375\niter:  8300 , fixed pt res:  tensor(0.1005) , ls:  1 , rel_err:  tensor(0.8353) , time:  0.0026967525482177734\niter:  8350 , fixed pt res:  tensor(0.0974) , ls:  1 , rel_err:  tensor(0.8341) , time:  0.0026950836181640625\niter:  8400 , fixed pt res:  tensor(0.0965) , ls:  1 , rel_err:  tensor(0.8350) , time:  0.00262451171875\niter:  8450 , fixed pt res:  tensor(0.0988) , ls:  1 , rel_err:  tensor(0.8283) , time:  0.002725839614868164\niter:  8500 , fixed pt res:  tensor(0.0975) , ls:  1 , rel_err:  tensor(0.8191) , time:  0.002711772918701172\niter:  8550 , fixed pt res:  tensor(0.0952) , ls:  1 , rel_err:  tensor(0.7979) , time:  0.002776622772216797\niter:  8600 , fixed pt res:  tensor(0.0939) , ls:  1 , rel_err:  tensor(0.8140) , time:  0.002679109573364258\niter:  8650 , fixed pt res:  tensor(0.0999) , ls:  1 , rel_err:  tensor(0.8250) , time:  0.0026099681854248047\niter:  8700 , fixed pt res:  tensor(0.0997) , ls:  1 , rel_err:  tensor(0.8035) , time:  0.002637147903442383\niter:  8750 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(0.7881) , time:  0.0026390552520751953\niter:  8800 , fixed pt res:  tensor(0.0932) , ls:  1 , rel_err:  tensor(0.8042) , time:  0.0029790401458740234\niter:  8850 , fixed pt res:  tensor(0.1018) , ls:  1 , rel_err:  tensor(0.7971) , time:  0.0026328563690185547\niter:  8900 , fixed pt res:  tensor(0.0981) , ls:  1 , rel_err:  tensor(0.7499) , time:  0.002802133560180664\niter:  8950 , fixed pt res:  tensor(0.0980) , ls:  1 , rel_err:  tensor(0.7480) , time:  0.0026078224182128906\niter:  9000 , fixed pt res:  tensor(0.0976) , ls:  1 , rel_err:  tensor(0.7709) , time:  0.002763032913208008\niter:  9050 , fixed pt res:  tensor(0.1001) , ls:  1 , rel_err:  tensor(0.7505) , time:  0.002651214599609375\niter:  9100 , fixed pt res:  tensor(0.0995) , ls:  1 , rel_err:  tensor(0.7414) , time:  0.0027337074279785156\niter:  9150 , fixed pt res:  tensor(0.1007) , ls:  1 , rel_err:  tensor(0.7507) , time:  0.0026307106018066406\niter:  9200 , fixed pt res:  tensor(0.0970) , ls:  1 , rel_err:  tensor(0.7687) , time:  0.0026504993438720703\niter:  9250 , fixed pt res:  tensor(0.0963) , ls:  1 , rel_err:  tensor(0.7512) , time:  0.0026214122772216797\niter:  9300 , fixed pt res:  tensor(0.1027) , ls:  1 , rel_err:  tensor(0.7331) , time:  0.0026297569274902344\niter:  9350 , fixed pt res:  tensor(0.1021) , ls:  1 , rel_err:  tensor(0.7549) , time:  0.0026335716247558594\niter:  9400 , fixed pt res:  tensor(0.0972) , ls:  1 , rel_err:  tensor(0.7413) , time:  0.0026237964630126953\niter:  9450 , fixed pt res:  tensor(0.1009) , ls:  1 , rel_err:  tensor(0.7578) , time:  0.0026702880859375\niter:  9500 , fixed pt res:  tensor(0.0990) , ls:  1 , rel_err:  tensor(0.7343) , time:  0.0026204586029052734\niter:  9550 , fixed pt res:  tensor(0.0995) , ls:  1 , rel_err:  tensor(0.7433) , time:  0.0026760101318359375\niter:  9600 , fixed pt res:  tensor(0.0988) , ls:  1 , rel_err:  tensor(0.7255) , time:  0.002622842788696289\niter:  9650 , fixed pt res:  tensor(0.0958) , ls:  1 , rel_err:  tensor(0.7154) , time:  0.002593994140625\niter:  9700 , fixed pt res:  tensor(0.1000) , ls:  1 , rel_err:  tensor(0.7179) , time:  0.0026009082794189453\niter:  9750 , fixed pt res:  tensor(0.0998) , ls:  1 , rel_err:  tensor(0.7104) , time:  0.0026895999908447266\niter:  9800 , fixed pt res:  tensor(0.0993) , ls:  1 , rel_err:  tensor(0.7094) , time:  0.002779722213745117\niter:  9850 , fixed pt res:  tensor(0.0990) , ls:  1 , rel_err:  tensor(0.6891) , time:  0.0026383399963378906\niter:  9900 , fixed pt res:  tensor(0.0974) , ls:  1 , rel_err:  tensor(0.7056) , time:  0.002614736557006836\niter:  9950 , fixed pt res:  tensor(0.1008) , ls:  1 , rel_err:  tensor(0.7106) , time:  0.002745389938354492\niter:  10000 , fixed pt res:  tensor(0.0996) , ls:  1 , rel_err:  tensor(0.7004) , time:  0.0027778148651123047\ntrial  1  finished after 27.69773554801941\n\n\n\n\n CHANGE, delta =  100\nnorm(rel_err_hist_temp - rel_err_lmm_hist_delta_array[sample_index,:]) =  tensor(0.)\n</pre> In\u00a0[\u00a0]: Copied! <pre>title_fontsize = 22\nfontsize       = 20\nfig1 = plt.figure()\nmy_blue = '#1f77b4'\nmy_orange = '#F97306'\n\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.semilogy(rel_err_lmm_hist_delta_array[0,:], linewidth=5, color=my_blue)\nax.semilogy(rel_err_lmm_hist_delta_array[1,:], linewidth=5, color='tab:green')\nax.semilogy(rel_err_lmm_hist_delta_array[2,:], linewidth=5, color='tab:purple')\nax.semilogy(rel_err_lmm_hist_delta_array[3,:], linewidth=5, color='tab:cyan')\nax.semilogy(rel_err_lmm_hist_delta_array[4,:], linewidth=5, color='tab:brown')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\n# ax.legend(['HJ-ADMM $\\delta=0.001$', 'HJ-ADMM $\\delta=0.01$', 'HJ-ADMM $\\delta=0.1$', 'HJ-ADMM $\\delta=1$', 'HJ-ADMM $\\delta=10$'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left')\nax.legend(['HJ-MM $\\delta=0.01$', 'HJ-MM $\\delta=0.1$', 'HJ-MM $\\delta=1$', 'HJ-MM $\\delta=10$', 'HJ-MM $\\delta=100$'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left')\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'ADMM_noisy_delta_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n\ntitle_str = 'samples =  ' + str(samples_for_varying_delta)\nax.set_title(title_str, fontsize=fontsize)\n</pre>  title_fontsize = 22 fontsize       = 20 fig1 = plt.figure() my_blue = '#1f77b4' my_orange = '#F97306'  fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.semilogy(rel_err_lmm_hist_delta_array[0,:], linewidth=5, color=my_blue) ax.semilogy(rel_err_lmm_hist_delta_array[1,:], linewidth=5, color='tab:green') ax.semilogy(rel_err_lmm_hist_delta_array[2,:], linewidth=5, color='tab:purple') ax.semilogy(rel_err_lmm_hist_delta_array[3,:], linewidth=5, color='tab:cyan') ax.semilogy(rel_err_lmm_hist_delta_array[4,:], linewidth=5, color='tab:brown')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) # ax.legend(['HJ-ADMM $\\delta=0.001$', 'HJ-ADMM $\\delta=0.01$', 'HJ-ADMM $\\delta=0.1$', 'HJ-ADMM $\\delta=1$', 'HJ-ADMM $\\delta=10$'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left') ax.legend(['HJ-MM $\\delta=0.01$', 'HJ-MM $\\delta=0.1$', 'HJ-MM $\\delta=1$', 'HJ-MM $\\delta=10$', 'HJ-MM $\\delta=100$'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left') ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'ADMM_noisy_delta_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)  title_str = 'samples =  ' + str(samples_for_varying_delta) ax.set_title(title_str, fontsize=fontsize) <pre>&lt;ipython-input-8-3304b89c7bc1&gt;:8: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> Out[\u00a0]: <pre>Text(0.5, 1.0, 'samples =  10000')</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>sample_array = [int(1), int(1e2), int(1e3), int(1e4)]\n\nxopt_HJ_lmm_sample_array = torch.zeros(len(sample_array), x_true.shape[0], x_true.shape[1])\nfk_HJ_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters)\nnorm_diff_HJ_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters)\nrel_err_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters)\nls_iters_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters)\n\n\ndelta_for_varying_samples = 10\nalpha_for_varying_samples = alpha_array[3]\n\nfor sample_index in range(len(sample_array)):\n  print('Number of Samples =', sample_array[sample_index])\n  for i in range(n_trials):\n    start_time_hj_lmm = time.time()\n    current_samples = sample_array[sample_index]\n    xopt_HJ_lmm_temp, fk_HJ_lmm_hist_temp, norm_diff_HJ_lmm_hist_temp, rel_err_hist_temp, ls_iters_hist_temp = hj_mm(x0, W, A, b, max_iters, \n                                                                                                  int_samples=current_samples, \n                                                                                                  delta=delta_for_varying_samples, \n                                                                                                  step_size=step_size,\n                                                                                                  lambd = lambd, \n                                                                                                  verbose=True, \n                                                                                                  print_freq=50,\n                                                                                                  x_true=x_true,\n                                                                                                  alpha=alpha_for_varying_samples)\n    end_time_hj_lmm = time.time()\n    time_hj_lmm = end_time_hj_lmm - start_time_hj_lmm\n    print('trial ', i+1, ' finished after', time_hj_lmm)\n      \n    if i==0:\n      xopt_HJ_lmm = xopt_HJ_lmm_temp\n      fk_HJ_lmm_hist = fk_HJ_lmm_hist_temp\n      norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist_temp\n      rel_err_hist = rel_err_hist_temp\n      ls_iters_hist = ls_iters_hist_temp\n    else:\n      xopt_HJ_lmm = xopt_HJ_lmm + xopt_HJ_lmm_temp\n      fk_HJ_lmm_hist = fk_HJ_lmm_hist + fk_HJ_lmm_hist_temp\n      norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist + norm_diff_HJ_lmm_hist_temp\n      rel_err_hist = rel_err_hist + rel_err_hist_temp\n      ls_iters_hist = ls_iters_hist + ls_iters_hist_temp\n\n\n  xopt_HJ_lmm_sample_array[sample_index, :, :] = xopt_HJ_lmm/n_trials\n  fk_HJ_lmm_hist_sample_array[sample_index, :] = fk_HJ_lmm_hist/n_trials\n  norm_diff_HJ_lmm_hist_sample_array[sample_index, :] = norm_diff_HJ_lmm_hist/n_trials\n  rel_err_lmm_hist_sample_array[sample_index, :] = rel_err_hist/n_trials \n  ls_iters_lmm_hist_sample_array[sample_index,:] = ls_iters_hist/n_trials\n  print('norm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) = ', torch.norm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]))\n</pre> sample_array = [int(1), int(1e2), int(1e3), int(1e4)]  xopt_HJ_lmm_sample_array = torch.zeros(len(sample_array), x_true.shape[0], x_true.shape[1]) fk_HJ_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters) norm_diff_HJ_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters) rel_err_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters) ls_iters_lmm_hist_sample_array = torch.zeros(len(sample_array), max_iters)   delta_for_varying_samples = 10 alpha_for_varying_samples = alpha_array[3]  for sample_index in range(len(sample_array)):   print('Number of Samples =', sample_array[sample_index])   for i in range(n_trials):     start_time_hj_lmm = time.time()     current_samples = sample_array[sample_index]     xopt_HJ_lmm_temp, fk_HJ_lmm_hist_temp, norm_diff_HJ_lmm_hist_temp, rel_err_hist_temp, ls_iters_hist_temp = hj_mm(x0, W, A, b, max_iters,                                                                                                    int_samples=current_samples,                                                                                                    delta=delta_for_varying_samples,                                                                                                    step_size=step_size,                                                                                                   lambd = lambd,                                                                                                    verbose=True,                                                                                                    print_freq=50,                                                                                                   x_true=x_true,                                                                                                   alpha=alpha_for_varying_samples)     end_time_hj_lmm = time.time()     time_hj_lmm = end_time_hj_lmm - start_time_hj_lmm     print('trial ', i+1, ' finished after', time_hj_lmm)            if i==0:       xopt_HJ_lmm = xopt_HJ_lmm_temp       fk_HJ_lmm_hist = fk_HJ_lmm_hist_temp       norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist_temp       rel_err_hist = rel_err_hist_temp       ls_iters_hist = ls_iters_hist_temp     else:       xopt_HJ_lmm = xopt_HJ_lmm + xopt_HJ_lmm_temp       fk_HJ_lmm_hist = fk_HJ_lmm_hist + fk_HJ_lmm_hist_temp       norm_diff_HJ_lmm_hist = norm_diff_HJ_lmm_hist + norm_diff_HJ_lmm_hist_temp       rel_err_hist = rel_err_hist + rel_err_hist_temp       ls_iters_hist = ls_iters_hist + ls_iters_hist_temp     xopt_HJ_lmm_sample_array[sample_index, :, :] = xopt_HJ_lmm/n_trials   fk_HJ_lmm_hist_sample_array[sample_index, :] = fk_HJ_lmm_hist/n_trials   norm_diff_HJ_lmm_hist_sample_array[sample_index, :] = norm_diff_HJ_lmm_hist/n_trials   rel_err_lmm_hist_sample_array[sample_index, :] = rel_err_hist/n_trials    ls_iters_lmm_hist_sample_array[sample_index,:] = ls_iters_hist/n_trials   print('norm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) = ', torch.norm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:])) <pre>Number of Samples = 1\niter:  50 , fixed pt res:  tensor(4.3492) , ls:  1 , rel_err:  tensor(22.0593) , time:  0.0012357234954833984\niter:  100 , fixed pt res:  tensor(4.2398) , ls:  1 , rel_err:  tensor(26.0788) , time:  0.0013756752014160156\niter:  150 , fixed pt res:  tensor(4.3122) , ls:  1 , rel_err:  tensor(29.7923) , time:  0.0012924671173095703\niter:  200 , fixed pt res:  tensor(4.2578) , ls:  1 , rel_err:  tensor(32.9060) , time:  0.001222848892211914\niter:  250 , fixed pt res:  tensor(4.2742) , ls:  1 , rel_err:  tensor(36.0638) , time:  0.001218557357788086\niter:  300 , fixed pt res:  tensor(4.2656) , ls:  1 , rel_err:  tensor(38.0925) , time:  0.001238107681274414\niter:  350 , fixed pt res:  tensor(4.3729) , ls:  1 , rel_err:  tensor(40.2829) , time:  0.0012290477752685547\niter:  400 , fixed pt res:  tensor(4.4421) , ls:  1 , rel_err:  tensor(42.0254) , time:  0.001237630844116211\niter:  450 , fixed pt res:  tensor(4.4611) , ls:  1 , rel_err:  tensor(43.8565) , time:  0.002003908157348633\niter:  500 , fixed pt res:  tensor(4.3654) , ls:  1 , rel_err:  tensor(46.0011) , time:  0.0012235641479492188\niter:  550 , fixed pt res:  tensor(4.4026) , ls:  1 , rel_err:  tensor(48.4161) , time:  0.0012052059173583984\niter:  600 , fixed pt res:  tensor(4.3892) , ls:  1 , rel_err:  tensor(50.3180) , time:  0.0013031959533691406\niter:  650 , fixed pt res:  tensor(4.4085) , ls:  1 , rel_err:  tensor(51.9762) , time:  0.0017383098602294922\niter:  700 , fixed pt res:  tensor(4.2235) , ls:  1 , rel_err:  tensor(53.8161) , time:  0.001260519027709961\niter:  750 , fixed pt res:  tensor(4.3299) , ls:  1 , rel_err:  tensor(55.5659) , time:  0.0012469291687011719\niter:  800 , fixed pt res:  tensor(4.3728) , ls:  1 , rel_err:  tensor(58.0084) , time:  0.0012285709381103516\niter:  850 , fixed pt res:  tensor(4.5146) , ls:  1 , rel_err:  tensor(59.5839) , time:  0.001222372055053711\niter:  900 , fixed pt res:  tensor(4.4009) , ls:  1 , rel_err:  tensor(61.2522) , time:  0.0012252330780029297\niter:  950 , fixed pt res:  tensor(4.3857) , ls:  1 , rel_err:  tensor(63.1436) , time:  0.0012290477752685547\niter:  1000 , fixed pt res:  tensor(4.3707) , ls:  1 , rel_err:  tensor(64.9713) , time:  0.001203775405883789\niter:  1050 , fixed pt res:  tensor(4.2621) , ls:  1 , rel_err:  tensor(66.0495) , time:  0.0012392997741699219\niter:  1100 , fixed pt res:  tensor(4.5444) , ls:  1 , rel_err:  tensor(67.6864) , time:  0.001298666000366211\niter:  1150 , fixed pt res:  tensor(4.2174) , ls:  1 , rel_err:  tensor(69.0120) , time:  0.0012073516845703125\niter:  1200 , fixed pt res:  tensor(4.3168) , ls:  1 , rel_err:  tensor(70.2632) , time:  0.0012478828430175781\niter:  1250 , fixed pt res:  tensor(4.5151) , ls:  1 , rel_err:  tensor(72.0217) , time:  0.0012123584747314453\niter:  1300 , fixed pt res:  tensor(4.4318) , ls:  1 , rel_err:  tensor(72.8153) , time:  0.0013761520385742188\niter:  1350 , fixed pt res:  tensor(4.4913) , ls:  1 , rel_err:  tensor(75.4307) , time:  0.0012369155883789062\niter:  1400 , fixed pt res:  tensor(4.3189) , ls:  1 , rel_err:  tensor(76.6560) , time:  0.001226186752319336\niter:  1450 , fixed pt res:  tensor(4.3683) , ls:  1 , rel_err:  tensor(76.9220) , time:  0.0021958351135253906\niter:  1500 , fixed pt res:  tensor(4.5245) , ls:  1 , rel_err:  tensor(78.3533) , time:  0.0012638568878173828\niter:  1550 , fixed pt res:  tensor(4.4940) , ls:  1 , rel_err:  tensor(79.2072) , time:  0.001207113265991211\niter:  1600 , fixed pt res:  tensor(4.4487) , ls:  1 , rel_err:  tensor(80.8733) , time:  0.0015423297882080078\niter:  1650 , fixed pt res:  tensor(4.5145) , ls:  1 , rel_err:  tensor(81.4984) , time:  0.0012214183807373047\niter:  1700 , fixed pt res:  tensor(4.3175) , ls:  1 , rel_err:  tensor(83.0772) , time:  0.0011968612670898438\niter:  1750 , fixed pt res:  tensor(4.4626) , ls:  1 , rel_err:  tensor(84.6571) , time:  0.0012164115905761719\niter:  1800 , fixed pt res:  tensor(4.5192) , ls:  1 , rel_err:  tensor(86.1078) , time:  0.001241445541381836\niter:  1850 , fixed pt res:  tensor(4.3068) , ls:  1 , rel_err:  tensor(87.2647) , time:  0.0012059211730957031\niter:  1900 , fixed pt res:  tensor(4.2968) , ls:  1 , rel_err:  tensor(88.8182) , time:  0.0011935234069824219\niter:  1950 , fixed pt res:  tensor(4.2597) , ls:  1 , rel_err:  tensor(90.1199) , time:  0.0012166500091552734\niter:  2000 , fixed pt res:  tensor(4.2799) , ls:  1 , rel_err:  tensor(91.2706) , time:  0.0015642642974853516\niter:  2050 , fixed pt res:  tensor(4.3968) , ls:  1 , rel_err:  tensor(93.1120) , time:  0.001207590103149414\niter:  2100 , fixed pt res:  tensor(4.2294) , ls:  1 , rel_err:  tensor(94.6409) , time:  0.0012409687042236328\niter:  2150 , fixed pt res:  tensor(4.1860) , ls:  1 , rel_err:  tensor(95.0320) , time:  0.0012357234954833984\niter:  2200 , fixed pt res:  tensor(4.3426) , ls:  1 , rel_err:  tensor(96.5111) , time:  0.0012042522430419922\niter:  2250 , fixed pt res:  tensor(4.3826) , ls:  1 , rel_err:  tensor(97.7978) , time:  0.001207590103149414\niter:  2300 , fixed pt res:  tensor(4.4400) , ls:  1 , rel_err:  tensor(99.7797) , time:  0.0012328624725341797\niter:  2350 , fixed pt res:  tensor(4.4654) , ls:  1 , rel_err:  tensor(101.4514) , time:  0.0012099742889404297\niter:  2400 , fixed pt res:  tensor(4.3189) , ls:  1 , rel_err:  tensor(102.1042) , time:  0.0012078285217285156\niter:  2450 , fixed pt res:  tensor(4.2428) , ls:  1 , rel_err:  tensor(103.2482) , time:  0.0012216567993164062\niter:  2500 , fixed pt res:  tensor(4.3893) , ls:  1 , rel_err:  tensor(103.7875) , time:  0.00119781494140625\niter:  2550 , fixed pt res:  tensor(4.3765) , ls:  1 , rel_err:  tensor(104.7699) , time:  0.0012710094451904297\niter:  2600 , fixed pt res:  tensor(4.3278) , ls:  1 , rel_err:  tensor(105.2396) , time:  0.001291513442993164\niter:  2650 , fixed pt res:  tensor(4.2415) , ls:  1 , rel_err:  tensor(105.4326) , time:  0.001216888427734375\niter:  2700 , fixed pt res:  tensor(4.1311) , ls:  1 , rel_err:  tensor(106.0025) , time:  0.001210927963256836\niter:  2750 , fixed pt res:  tensor(4.4455) , ls:  1 , rel_err:  tensor(106.8205) , time:  0.0012440681457519531\niter:  2800 , fixed pt res:  tensor(4.3838) , ls:  1 , rel_err:  tensor(108.9093) , time:  0.0015323162078857422\niter:  2850 , fixed pt res:  tensor(4.1581) , ls:  1 , rel_err:  tensor(110.2157) , time:  0.0012116432189941406\niter:  2900 , fixed pt res:  tensor(4.3265) , ls:  1 , rel_err:  tensor(110.9226) , time:  0.0012247562408447266\niter:  2950 , fixed pt res:  tensor(4.2206) , ls:  1 , rel_err:  tensor(111.6767) , time:  0.0012023448944091797\niter:  3000 , fixed pt res:  tensor(4.3502) , ls:  1 , rel_err:  tensor(112.5193) , time:  0.0012269020080566406\niter:  3050 , fixed pt res:  tensor(4.3318) , ls:  1 , rel_err:  tensor(112.9838) , time:  0.0012021064758300781\niter:  3100 , fixed pt res:  tensor(4.4128) , ls:  1 , rel_err:  tensor(114.0561) , time:  0.0012402534484863281\niter:  3150 , fixed pt res:  tensor(4.1856) , ls:  1 , rel_err:  tensor(114.3409) , time:  0.0012400150299072266\niter:  3200 , fixed pt res:  tensor(4.3584) , ls:  1 , rel_err:  tensor(115.2822) , time:  0.001224517822265625\niter:  3250 , fixed pt res:  tensor(4.1931) , ls:  1 , rel_err:  tensor(115.8058) , time:  0.0012483596801757812\niter:  3300 , fixed pt res:  tensor(4.3942) , ls:  1 , rel_err:  tensor(115.2320) , time:  0.0012700557708740234\niter:  3350 , fixed pt res:  tensor(4.4909) , ls:  1 , rel_err:  tensor(116.2544) , time:  0.0013701915740966797\niter:  3400 , fixed pt res:  tensor(4.3221) , ls:  1 , rel_err:  tensor(116.9406) , time:  0.0012536048889160156\niter:  3450 , fixed pt res:  tensor(4.2316) , ls:  1 , rel_err:  tensor(118.2200) , time:  0.001245260238647461\niter:  3500 , fixed pt res:  tensor(4.3480) , ls:  1 , rel_err:  tensor(119.6118) , time:  0.0012774467468261719\niter:  3550 , fixed pt res:  tensor(4.4444) , ls:  1 , rel_err:  tensor(120.3955) , time:  0.0012316703796386719\niter:  3600 , fixed pt res:  tensor(4.2887) , ls:  1 , rel_err:  tensor(121.2983) , time:  0.0012226104736328125\niter:  3650 , fixed pt res:  tensor(4.3580) , ls:  1 , rel_err:  tensor(122.7465) , time:  0.001253366470336914\niter:  3700 , fixed pt res:  tensor(4.3071) , ls:  1 , rel_err:  tensor(122.0843) , time:  0.001230478286743164\niter:  3750 , fixed pt res:  tensor(4.4815) , ls:  1 , rel_err:  tensor(122.9040) , time:  0.0012171268463134766\niter:  3800 , fixed pt res:  tensor(4.1557) , ls:  1 , rel_err:  tensor(123.1052) , time:  0.0012226104736328125\niter:  3850 , fixed pt res:  tensor(4.2987) , ls:  1 , rel_err:  tensor(123.6549) , time:  0.001209259033203125\niter:  3900 , fixed pt res:  tensor(4.3005) , ls:  1 , rel_err:  tensor(123.6455) , time:  0.0012559890747070312\niter:  3950 , fixed pt res:  tensor(4.4685) , ls:  1 , rel_err:  tensor(124.7504) , time:  0.0014450550079345703\niter:  4000 , fixed pt res:  tensor(4.3504) , ls:  1 , rel_err:  tensor(125.1232) , time:  0.0012197494506835938\niter:  4050 , fixed pt res:  tensor(4.2964) , ls:  1 , rel_err:  tensor(124.8335) , time:  0.0012235641479492188\niter:  4100 , fixed pt res:  tensor(4.4660) , ls:  1 , rel_err:  tensor(126.1516) , time:  0.001220703125\niter:  4150 , fixed pt res:  tensor(4.5462) , ls:  1 , rel_err:  tensor(127.2025) , time:  0.0012118816375732422\niter:  4200 , fixed pt res:  tensor(4.3123) , ls:  1 , rel_err:  tensor(126.9322) , time:  0.0012183189392089844\niter:  4250 , fixed pt res:  tensor(4.3521) , ls:  1 , rel_err:  tensor(127.3104) , time:  0.0012164115905761719\niter:  4300 , fixed pt res:  tensor(4.2757) , ls:  1 , rel_err:  tensor(128.1557) , time:  0.001264810562133789\niter:  4350 , fixed pt res:  tensor(4.3231) , ls:  1 , rel_err:  tensor(129.0909) , time:  0.0012233257293701172\niter:  4400 , fixed pt res:  tensor(4.3421) , ls:  1 , rel_err:  tensor(129.4120) , time:  0.0013189315795898438\niter:  4450 , fixed pt res:  tensor(4.5757) , ls:  1 , rel_err:  tensor(129.6437) , time:  0.0012159347534179688\niter:  4500 , fixed pt res:  tensor(4.3383) , ls:  1 , rel_err:  tensor(130.6270) , time:  0.0012118816375732422\niter:  4550 , fixed pt res:  tensor(4.2816) , ls:  1 , rel_err:  tensor(130.9382) , time:  0.0012242794036865234\niter:  4600 , fixed pt res:  tensor(4.5565) , ls:  1 , rel_err:  tensor(131.5833) , time:  0.001222848892211914\niter:  4650 , fixed pt res:  tensor(4.3938) , ls:  1 , rel_err:  tensor(132.9198) , time:  0.0012316703796386719\niter:  4700 , fixed pt res:  tensor(4.1798) , ls:  1 , rel_err:  tensor(134.1844) , time:  0.0013203620910644531\niter:  4750 , fixed pt res:  tensor(4.2626) , ls:  1 , rel_err:  tensor(134.6126) , time:  0.0012254714965820312\niter:  4800 , fixed pt res:  tensor(4.3756) , ls:  1 , rel_err:  tensor(135.4791) , time:  0.0012345314025878906\niter:  4850 , fixed pt res:  tensor(4.2080) , ls:  1 , rel_err:  tensor(137.6846) , time:  0.0015499591827392578\niter:  4900 , fixed pt res:  tensor(4.5486) , ls:  1 , rel_err:  tensor(137.8125) , time:  0.0012052059173583984\niter:  4950 , fixed pt res:  tensor(4.4195) , ls:  1 , rel_err:  tensor(138.8419) , time:  0.0012307167053222656\niter:  5000 , fixed pt res:  tensor(4.4447) , ls:  1 , rel_err:  tensor(139.9588) , time:  0.0012805461883544922\niter:  5050 , fixed pt res:  tensor(4.4724) , ls:  1 , rel_err:  tensor(140.3710) , time:  0.0012123584747314453\niter:  5100 , fixed pt res:  tensor(4.3861) , ls:  1 , rel_err:  tensor(141.2079) , time:  0.0012962818145751953\niter:  5150 , fixed pt res:  tensor(4.2526) , ls:  1 , rel_err:  tensor(143.0183) , time:  0.0012211799621582031\niter:  5200 , fixed pt res:  tensor(4.4316) , ls:  1 , rel_err:  tensor(143.8309) , time:  0.0012254714965820312\niter:  5250 , fixed pt res:  tensor(4.3292) , ls:  1 , rel_err:  tensor(144.8065) , time:  0.0012087821960449219\niter:  5300 , fixed pt res:  tensor(4.1978) , ls:  1 , rel_err:  tensor(145.1760) , time:  0.0012331008911132812\niter:  5350 , fixed pt res:  tensor(4.3954) , ls:  1 , rel_err:  tensor(145.9453) , time:  0.0012140274047851562\niter:  5400 , fixed pt res:  tensor(4.5053) , ls:  1 , rel_err:  tensor(148.0731) , time:  0.0012247562408447266\niter:  5450 , fixed pt res:  tensor(4.4561) , ls:  1 , rel_err:  tensor(148.3923) , time:  0.0014989376068115234\niter:  5500 , fixed pt res:  tensor(4.5518) , ls:  1 , rel_err:  tensor(147.9458) , time:  0.001608133316040039\niter:  5550 , fixed pt res:  tensor(4.3144) , ls:  1 , rel_err:  tensor(148.8063) , time:  0.0012576580047607422\niter:  5600 , fixed pt res:  tensor(4.3206) , ls:  1 , rel_err:  tensor(149.4920) , time:  0.0016512870788574219\niter:  5650 , fixed pt res:  tensor(4.4863) , ls:  1 , rel_err:  tensor(149.8737) , time:  0.001215219497680664\niter:  5700 , fixed pt res:  tensor(4.4126) , ls:  1 , rel_err:  tensor(150.2984) , time:  0.0012290477752685547\niter:  5750 , fixed pt res:  tensor(4.5650) , ls:  1 , rel_err:  tensor(151.4765) , time:  0.0012562274932861328\niter:  5800 , fixed pt res:  tensor(4.2554) , ls:  1 , rel_err:  tensor(150.7308) , time:  0.0012602806091308594\niter:  5850 , fixed pt res:  tensor(4.2354) , ls:  1 , rel_err:  tensor(151.0924) , time:  0.0012059211730957031\niter:  5900 , fixed pt res:  tensor(4.4356) , ls:  1 , rel_err:  tensor(152.0713) , time:  0.0012755393981933594\niter:  5950 , fixed pt res:  tensor(4.4027) , ls:  1 , rel_err:  tensor(152.7037) , time:  0.001271963119506836\niter:  6000 , fixed pt res:  tensor(4.1286) , ls:  1 , rel_err:  tensor(154.0682) , time:  0.0012352466583251953\niter:  6050 , fixed pt res:  tensor(4.4555) , ls:  1 , rel_err:  tensor(155.5801) , time:  0.001233816146850586\niter:  6100 , fixed pt res:  tensor(4.1264) , ls:  1 , rel_err:  tensor(155.5533) , time:  0.0012335777282714844\niter:  6150 , fixed pt res:  tensor(4.3133) , ls:  1 , rel_err:  tensor(155.6941) , time:  0.0012552738189697266\niter:  6200 , fixed pt res:  tensor(4.1991) , ls:  1 , rel_err:  tensor(155.8660) , time:  0.0012211799621582031\niter:  6250 , fixed pt res:  tensor(4.1847) , ls:  1 , rel_err:  tensor(155.8810) , time:  0.0012273788452148438\niter:  6300 , fixed pt res:  tensor(4.3835) , ls:  1 , rel_err:  tensor(157.5197) , time:  0.0012090206146240234\niter:  6350 , fixed pt res:  tensor(4.4773) , ls:  1 , rel_err:  tensor(158.0135) , time:  0.0012416839599609375\niter:  6400 , fixed pt res:  tensor(4.2756) , ls:  1 , rel_err:  tensor(158.2304) , time:  0.001211404800415039\niter:  6450 , fixed pt res:  tensor(4.3285) , ls:  1 , rel_err:  tensor(158.2862) , time:  0.0012767314910888672\niter:  6500 , fixed pt res:  tensor(4.3430) , ls:  1 , rel_err:  tensor(158.4957) , time:  0.0012328624725341797\niter:  6550 , fixed pt res:  tensor(4.4024) , ls:  1 , rel_err:  tensor(158.7941) , time:  0.001210927963256836\niter:  6600 , fixed pt res:  tensor(4.3154) , ls:  1 , rel_err:  tensor(160.0966) , time:  0.0012059211730957031\niter:  6650 , fixed pt res:  tensor(4.3362) , ls:  1 , rel_err:  tensor(161.1296) , time:  0.0012753009796142578\niter:  6700 , fixed pt res:  tensor(4.2554) , ls:  1 , rel_err:  tensor(161.2044) , time:  0.0012421607971191406\niter:  6750 , fixed pt res:  tensor(4.3534) , ls:  1 , rel_err:  tensor(161.5621) , time:  0.0020461082458496094\niter:  6800 , fixed pt res:  tensor(4.4202) , ls:  1 , rel_err:  tensor(162.2499) , time:  0.0012614727020263672\niter:  6850 , fixed pt res:  tensor(4.3849) , ls:  1 , rel_err:  tensor(162.1226) , time:  0.0012538433074951172\niter:  6900 , fixed pt res:  tensor(4.4920) , ls:  1 , rel_err:  tensor(163.0170) , time:  0.001508951187133789\niter:  6950 , fixed pt res:  tensor(4.3237) , ls:  1 , rel_err:  tensor(163.7699) , time:  0.001219034194946289\niter:  7000 , fixed pt res:  tensor(4.3307) , ls:  1 , rel_err:  tensor(164.7055) , time:  0.001251220703125\niter:  7050 , fixed pt res:  tensor(4.3875) , ls:  1 , rel_err:  tensor(166.1488) , time:  0.001219034194946289\niter:  7100 , fixed pt res:  tensor(4.2454) , ls:  1 , rel_err:  tensor(166.5173) , time:  0.0012180805206298828\niter:  7150 , fixed pt res:  tensor(4.5403) , ls:  1 , rel_err:  tensor(166.6101) , time:  0.0012042522430419922\niter:  7200 , fixed pt res:  tensor(4.3249) , ls:  1 , rel_err:  tensor(166.7866) , time:  0.0011980533599853516\niter:  7250 , fixed pt res:  tensor(4.2379) , ls:  1 , rel_err:  tensor(166.9070) , time:  0.001207113265991211\niter:  7300 , fixed pt res:  tensor(4.1400) , ls:  1 , rel_err:  tensor(166.6404) , time:  0.001207113265991211\niter:  7350 , fixed pt res:  tensor(4.3063) , ls:  1 , rel_err:  tensor(167.2403) , time:  0.0011966228485107422\niter:  7400 , fixed pt res:  tensor(4.3218) , ls:  1 , rel_err:  tensor(167.5425) , time:  0.001191854476928711\niter:  7450 , fixed pt res:  tensor(4.4948) , ls:  1 , rel_err:  tensor(169.0356) , time:  0.0011944770812988281\niter:  7500 , fixed pt res:  tensor(4.3100) , ls:  1 , rel_err:  tensor(168.2851) , time:  0.001407623291015625\niter:  7550 , fixed pt res:  tensor(4.2834) , ls:  1 , rel_err:  tensor(169.4251) , time:  0.0013039112091064453\niter:  7600 , fixed pt res:  tensor(4.3020) , ls:  1 , rel_err:  tensor(170.3145) , time:  0.001260519027709961\niter:  7650 , fixed pt res:  tensor(4.1987) , ls:  1 , rel_err:  tensor(170.9172) , time:  0.0012359619140625\niter:  7700 , fixed pt res:  tensor(4.2722) , ls:  1 , rel_err:  tensor(171.9099) , time:  0.0012178421020507812\niter:  7750 , fixed pt res:  tensor(4.3431) , ls:  1 , rel_err:  tensor(172.2238) , time:  0.0012478828430175781\niter:  7800 , fixed pt res:  tensor(4.4537) , ls:  1 , rel_err:  tensor(172.2792) , time:  0.0012288093566894531\niter:  7850 , fixed pt res:  tensor(4.2815) , ls:  1 , rel_err:  tensor(172.2619) , time:  0.0012218952178955078\niter:  7900 , fixed pt res:  tensor(4.4923) , ls:  1 , rel_err:  tensor(171.8362) , time:  0.001215219497680664\niter:  7950 , fixed pt res:  tensor(4.1887) , ls:  1 , rel_err:  tensor(172.1641) , time:  0.0014383792877197266\niter:  8000 , fixed pt res:  tensor(4.1604) , ls:  1 , rel_err:  tensor(171.9559) , time:  0.0012226104736328125\niter:  8050 , fixed pt res:  tensor(4.5022) , ls:  1 , rel_err:  tensor(172.6269) , time:  0.0012369155883789062\niter:  8100 , fixed pt res:  tensor(4.3863) , ls:  1 , rel_err:  tensor(172.6648) , time:  0.0012516975402832031\niter:  8150 , fixed pt res:  tensor(4.5391) , ls:  1 , rel_err:  tensor(172.7342) , time:  0.0012407302856445312\niter:  8200 , fixed pt res:  tensor(4.3726) , ls:  1 , rel_err:  tensor(174.2308) , time:  0.0012116432189941406\niter:  8250 , fixed pt res:  tensor(4.4113) , ls:  1 , rel_err:  tensor(174.1882) , time:  0.001323699951171875\niter:  8300 , fixed pt res:  tensor(4.3925) , ls:  1 , rel_err:  tensor(174.1840) , time:  0.0012085437774658203\niter:  8350 , fixed pt res:  tensor(4.4766) , ls:  1 , rel_err:  tensor(174.4624) , time:  0.0012044906616210938\niter:  8400 , fixed pt res:  tensor(4.3198) , ls:  1 , rel_err:  tensor(174.3825) , time:  0.0013380050659179688\niter:  8450 , fixed pt res:  tensor(4.2532) , ls:  1 , rel_err:  tensor(175.6964) , time:  0.001226663589477539\niter:  8500 , fixed pt res:  tensor(4.1973) , ls:  1 , rel_err:  tensor(175.1025) , time:  0.0020666122436523438\niter:  8550 , fixed pt res:  tensor(4.2542) , ls:  1 , rel_err:  tensor(175.3418) , time:  0.0012395381927490234\niter:  8600 , fixed pt res:  tensor(4.3963) , ls:  1 , rel_err:  tensor(175.6121) , time:  0.001481771469116211\niter:  8650 , fixed pt res:  tensor(4.5053) , ls:  1 , rel_err:  tensor(175.6718) , time:  0.0012290477752685547\niter:  8700 , fixed pt res:  tensor(4.5122) , ls:  1 , rel_err:  tensor(175.7919) , time:  0.0012845993041992188\niter:  8750 , fixed pt res:  tensor(4.5139) , ls:  1 , rel_err:  tensor(177.0038) , time:  0.001233816146850586\niter:  8800 , fixed pt res:  tensor(4.4545) , ls:  1 , rel_err:  tensor(177.6089) , time:  0.001232147216796875\niter:  8850 , fixed pt res:  tensor(4.4173) , ls:  1 , rel_err:  tensor(178.6840) , time:  0.001413106918334961\niter:  8900 , fixed pt res:  tensor(4.3516) , ls:  1 , rel_err:  tensor(179.5216) , time:  0.0012238025665283203\niter:  8950 , fixed pt res:  tensor(4.4677) , ls:  1 , rel_err:  tensor(180.7708) , time:  0.0012068748474121094\niter:  9000 , fixed pt res:  tensor(4.1992) , ls:  1 , rel_err:  tensor(180.7370) , time:  0.0012822151184082031\niter:  9050 , fixed pt res:  tensor(4.5322) , ls:  1 , rel_err:  tensor(181.2392) , time:  0.0012969970703125\niter:  9100 , fixed pt res:  tensor(4.4024) , ls:  1 , rel_err:  tensor(181.9343) , time:  0.0012459754943847656\niter:  9150 , fixed pt res:  tensor(4.2635) , ls:  1 , rel_err:  tensor(183.3682) , time:  0.0014431476593017578\niter:  9200 , fixed pt res:  tensor(4.3862) , ls:  1 , rel_err:  tensor(183.9166) , time:  0.0012183189392089844\niter:  9250 , fixed pt res:  tensor(4.4897) , ls:  1 , rel_err:  tensor(185.5516) , time:  0.0012104511260986328\niter:  9300 , fixed pt res:  tensor(4.3664) , ls:  1 , rel_err:  tensor(186.3082) , time:  0.001222848892211914\niter:  9350 , fixed pt res:  tensor(4.2656) , ls:  1 , rel_err:  tensor(186.6163) , time:  0.0011990070343017578\niter:  9400 , fixed pt res:  tensor(4.2133) , ls:  1 , rel_err:  tensor(187.3418) , time:  0.001234292984008789\niter:  9450 , fixed pt res:  tensor(4.4000) , ls:  1 , rel_err:  tensor(188.1650) , time:  0.0012516975402832031\niter:  9500 , fixed pt res:  tensor(4.3824) , ls:  1 , rel_err:  tensor(188.9037) , time:  0.0012440681457519531\niter:  9550 , fixed pt res:  tensor(4.3504) , ls:  1 , rel_err:  tensor(189.1673) , time:  0.00121307373046875\niter:  9600 , fixed pt res:  tensor(4.5031) , ls:  1 , rel_err:  tensor(190.2241) , time:  0.0012161731719970703\niter:  9650 , fixed pt res:  tensor(4.3399) , ls:  1 , rel_err:  tensor(190.3523) , time:  0.0012121200561523438\niter:  9700 , fixed pt res:  tensor(4.4984) , ls:  1 , rel_err:  tensor(191.1164) , time:  0.0013153553009033203\niter:  9750 , fixed pt res:  tensor(4.3649) , ls:  1 , rel_err:  tensor(192.1975) , time:  0.001260995864868164\niter:  9800 , fixed pt res:  tensor(4.3691) , ls:  1 , rel_err:  tensor(191.9936) , time:  0.0012807846069335938\niter:  9850 , fixed pt res:  tensor(4.4353) , ls:  1 , rel_err:  tensor(192.7367) , time:  0.0012423992156982422\niter:  9900 , fixed pt res:  tensor(4.4677) , ls:  1 , rel_err:  tensor(193.7720) , time:  0.0012576580047607422\niter:  9950 , fixed pt res:  tensor(4.3881) , ls:  1 , rel_err:  tensor(193.7817) , time:  0.0018002986907958984\niter:  10000 , fixed pt res:  tensor(4.2635) , ls:  1 , rel_err:  tensor(194.5954) , time:  0.0012183189392089844\ntrial  1  finished after 13.358325004577637\nnorm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) =  tensor(0.)\nNumber of Samples = 100\niter:  50 , fixed pt res:  tensor(0.7745) , ls:  1 , rel_err:  tensor(15.3021) , time:  0.001310110092163086\niter:  100 , fixed pt res:  tensor(0.5291) , ls:  1 , rel_err:  tensor(14.1823) , time:  0.001262664794921875\niter:  150 , fixed pt res:  tensor(0.4858) , ls:  1 , rel_err:  tensor(13.4265) , time:  0.001257181167602539\niter:  200 , fixed pt res:  tensor(0.4850) , ls:  1 , rel_err:  tensor(12.6152) , time:  0.0014407634735107422\niter:  250 , fixed pt res:  tensor(0.4468) , ls:  1 , rel_err:  tensor(11.8486) , time:  0.00128173828125\niter:  300 , fixed pt res:  tensor(0.4460) , ls:  1 , rel_err:  tensor(11.1918) , time:  0.0014660358428955078\niter:  350 , fixed pt res:  tensor(0.4499) , ls:  1 , rel_err:  tensor(10.4513) , time:  0.0012519359588623047\niter:  400 , fixed pt res:  tensor(0.4664) , ls:  1 , rel_err:  tensor(10.0025) , time:  0.0012450218200683594\niter:  450 , fixed pt res:  tensor(0.4562) , ls:  1 , rel_err:  tensor(9.3706) , time:  0.0014846324920654297\niter:  500 , fixed pt res:  tensor(0.4679) , ls:  1 , rel_err:  tensor(8.8386) , time:  0.0012602806091308594\niter:  550 , fixed pt res:  tensor(0.4514) , ls:  1 , rel_err:  tensor(8.2698) , time:  0.001310586929321289\niter:  600 , fixed pt res:  tensor(0.4350) , ls:  1 , rel_err:  tensor(7.8019) , time:  0.0014019012451171875\niter:  650 , fixed pt res:  tensor(0.4584) , ls:  1 , rel_err:  tensor(7.3331) , time:  0.001260519027709961\niter:  700 , fixed pt res:  tensor(0.4525) , ls:  1 , rel_err:  tensor(7.0093) , time:  0.0012497901916503906\niter:  750 , fixed pt res:  tensor(0.4378) , ls:  1 , rel_err:  tensor(6.7379) , time:  0.002296924591064453\niter:  800 , fixed pt res:  tensor(0.4329) , ls:  1 , rel_err:  tensor(6.3145) , time:  0.0013031959533691406\niter:  850 , fixed pt res:  tensor(0.4491) , ls:  1 , rel_err:  tensor(5.9935) , time:  0.0012462139129638672\niter:  900 , fixed pt res:  tensor(0.4482) , ls:  1 , rel_err:  tensor(5.6870) , time:  0.0012958049774169922\niter:  950 , fixed pt res:  tensor(0.4573) , ls:  1 , rel_err:  tensor(5.4872) , time:  0.0013692378997802734\niter:  1000 , fixed pt res:  tensor(0.4454) , ls:  1 , rel_err:  tensor(5.2836) , time:  0.001262664794921875\niter:  1050 , fixed pt res:  tensor(0.4282) , ls:  1 , rel_err:  tensor(5.1239) , time:  0.002058744430541992\niter:  1100 , fixed pt res:  tensor(0.4601) , ls:  1 , rel_err:  tensor(4.8779) , time:  0.0012831687927246094\niter:  1150 , fixed pt res:  tensor(0.4569) , ls:  1 , rel_err:  tensor(4.7101) , time:  0.0012745857238769531\niter:  1200 , fixed pt res:  tensor(0.4447) , ls:  1 , rel_err:  tensor(4.3678) , time:  0.0012636184692382812\niter:  1250 , fixed pt res:  tensor(0.4372) , ls:  1 , rel_err:  tensor(4.1949) , time:  0.0012631416320800781\niter:  1300 , fixed pt res:  tensor(0.4548) , ls:  1 , rel_err:  tensor(4.1029) , time:  0.0012526512145996094\niter:  1350 , fixed pt res:  tensor(0.4440) , ls:  1 , rel_err:  tensor(3.9807) , time:  0.0013229846954345703\niter:  1400 , fixed pt res:  tensor(0.4486) , ls:  1 , rel_err:  tensor(3.8899) , time:  0.0012824535369873047\niter:  1450 , fixed pt res:  tensor(0.4442) , ls:  1 , rel_err:  tensor(3.7541) , time:  0.00128936767578125\niter:  1500 , fixed pt res:  tensor(0.4513) , ls:  1 , rel_err:  tensor(3.5777) , time:  0.0012822151184082031\niter:  1550 , fixed pt res:  tensor(0.4171) , ls:  1 , rel_err:  tensor(3.4925) , time:  0.0012974739074707031\niter:  1600 , fixed pt res:  tensor(0.4389) , ls:  1 , rel_err:  tensor(3.2979) , time:  0.0012981891632080078\niter:  1650 , fixed pt res:  tensor(0.4353) , ls:  1 , rel_err:  tensor(3.1825) , time:  0.0013427734375\niter:  1700 , fixed pt res:  tensor(0.4445) , ls:  1 , rel_err:  tensor(3.1297) , time:  0.0012636184692382812\niter:  1750 , fixed pt res:  tensor(0.4608) , ls:  1 , rel_err:  tensor(3.1012) , time:  0.002191781997680664\niter:  1800 , fixed pt res:  tensor(0.4407) , ls:  1 , rel_err:  tensor(2.9704) , time:  0.0013363361358642578\niter:  1850 , fixed pt res:  tensor(0.4530) , ls:  1 , rel_err:  tensor(3.0412) , time:  0.0012786388397216797\niter:  1900 , fixed pt res:  tensor(0.4420) , ls:  1 , rel_err:  tensor(2.9323) , time:  0.0013391971588134766\niter:  1950 , fixed pt res:  tensor(0.4544) , ls:  1 , rel_err:  tensor(2.9978) , time:  0.0013275146484375\niter:  2000 , fixed pt res:  tensor(0.4489) , ls:  1 , rel_err:  tensor(2.9866) , time:  0.0012645721435546875\niter:  2050 , fixed pt res:  tensor(0.4557) , ls:  1 , rel_err:  tensor(2.8863) , time:  0.0012743473052978516\niter:  2100 , fixed pt res:  tensor(0.4534) , ls:  1 , rel_err:  tensor(2.8482) , time:  0.001253366470336914\niter:  2150 , fixed pt res:  tensor(0.4365) , ls:  1 , rel_err:  tensor(2.8268) , time:  0.0012631416320800781\niter:  2200 , fixed pt res:  tensor(0.4519) , ls:  1 , rel_err:  tensor(2.8113) , time:  0.002457141876220703\niter:  2250 , fixed pt res:  tensor(0.4497) , ls:  1 , rel_err:  tensor(2.8356) , time:  0.0012688636779785156\niter:  2300 , fixed pt res:  tensor(0.4532) , ls:  1 , rel_err:  tensor(2.8252) , time:  0.0012612342834472656\niter:  2350 , fixed pt res:  tensor(0.4499) , ls:  1 , rel_err:  tensor(2.7863) , time:  0.0012767314910888672\niter:  2400 , fixed pt res:  tensor(0.4548) , ls:  1 , rel_err:  tensor(2.6750) , time:  0.0012617111206054688\niter:  2450 , fixed pt res:  tensor(0.4557) , ls:  1 , rel_err:  tensor(2.6320) , time:  0.001291513442993164\niter:  2500 , fixed pt res:  tensor(0.4548) , ls:  1 , rel_err:  tensor(2.5933) , time:  0.0012500286102294922\niter:  2550 , fixed pt res:  tensor(0.4298) , ls:  1 , rel_err:  tensor(2.5141) , time:  0.00127410888671875\niter:  2600 , fixed pt res:  tensor(0.4316) , ls:  1 , rel_err:  tensor(2.5273) , time:  0.0012772083282470703\niter:  2650 , fixed pt res:  tensor(0.4303) , ls:  1 , rel_err:  tensor(2.5612) , time:  0.0012912750244140625\niter:  2700 , fixed pt res:  tensor(0.4467) , ls:  1 , rel_err:  tensor(2.4864) , time:  0.0012738704681396484\niter:  2750 , fixed pt res:  tensor(0.4455) , ls:  1 , rel_err:  tensor(2.5092) , time:  0.001268625259399414\niter:  2800 , fixed pt res:  tensor(0.4444) , ls:  1 , rel_err:  tensor(2.4727) , time:  0.0013165473937988281\niter:  2850 , fixed pt res:  tensor(0.4379) , ls:  1 , rel_err:  tensor(2.5988) , time:  0.0015835762023925781\niter:  2900 , fixed pt res:  tensor(0.4466) , ls:  1 , rel_err:  tensor(2.4992) , time:  0.0012874603271484375\niter:  2950 , fixed pt res:  tensor(0.4663) , ls:  1 , rel_err:  tensor(2.4649) , time:  0.0013229846954345703\niter:  3000 , fixed pt res:  tensor(0.4610) , ls:  1 , rel_err:  tensor(2.3884) , time:  0.0015511512756347656\niter:  3050 , fixed pt res:  tensor(0.4496) , ls:  1 , rel_err:  tensor(2.4362) , time:  0.0012707710266113281\niter:  3100 , fixed pt res:  tensor(0.4613) , ls:  1 , rel_err:  tensor(2.4918) , time:  0.0012714862823486328\niter:  3150 , fixed pt res:  tensor(0.4323) , ls:  1 , rel_err:  tensor(2.5321) , time:  0.0016469955444335938\niter:  3200 , fixed pt res:  tensor(0.4321) , ls:  1 , rel_err:  tensor(2.5537) , time:  0.001306772232055664\niter:  3250 , fixed pt res:  tensor(0.4411) , ls:  1 , rel_err:  tensor(2.5134) , time:  0.0013120174407958984\niter:  3300 , fixed pt res:  tensor(0.4662) , ls:  1 , rel_err:  tensor(2.4812) , time:  0.0013124942779541016\niter:  3350 , fixed pt res:  tensor(0.4527) , ls:  1 , rel_err:  tensor(2.5300) , time:  0.0012688636779785156\niter:  3400 , fixed pt res:  tensor(0.4342) , ls:  1 , rel_err:  tensor(2.5346) , time:  0.0013089179992675781\niter:  3450 , fixed pt res:  tensor(0.4434) , ls:  1 , rel_err:  tensor(2.5757) , time:  0.001308441162109375\niter:  3500 , fixed pt res:  tensor(0.4403) , ls:  1 , rel_err:  tensor(2.5628) , time:  0.0012698173522949219\niter:  3550 , fixed pt res:  tensor(0.4538) , ls:  1 , rel_err:  tensor(2.5536) , time:  0.0012412071228027344\niter:  3600 , fixed pt res:  tensor(0.4477) , ls:  1 , rel_err:  tensor(2.5987) , time:  0.001482248306274414\niter:  3650 , fixed pt res:  tensor(0.4369) , ls:  1 , rel_err:  tensor(2.5586) , time:  0.0013012886047363281\niter:  3700 , fixed pt res:  tensor(0.4333) , ls:  1 , rel_err:  tensor(2.5921) , time:  0.001262664794921875\niter:  3750 , fixed pt res:  tensor(0.4608) , ls:  1 , rel_err:  tensor(2.6525) , time:  0.0014340877532958984\niter:  3800 , fixed pt res:  tensor(0.4732) , ls:  1 , rel_err:  tensor(2.5588) , time:  0.0012569427490234375\niter:  3850 , fixed pt res:  tensor(0.4544) , ls:  1 , rel_err:  tensor(2.4464) , time:  0.001260995864868164\niter:  3900 , fixed pt res:  tensor(0.4411) , ls:  1 , rel_err:  tensor(2.4579) , time:  0.0020532608032226562\niter:  3950 , fixed pt res:  tensor(0.4562) , ls:  1 , rel_err:  tensor(2.4835) , time:  0.0012850761413574219\niter:  4000 , fixed pt res:  tensor(0.4672) , ls:  1 , rel_err:  tensor(2.5577) , time:  0.0012614727020263672\niter:  4050 , fixed pt res:  tensor(0.4457) , ls:  1 , rel_err:  tensor(2.6432) , time:  0.0012993812561035156\niter:  4100 , fixed pt res:  tensor(0.4429) , ls:  1 , rel_err:  tensor(2.6017) , time:  0.0014777183532714844\niter:  4150 , fixed pt res:  tensor(0.4509) , ls:  1 , rel_err:  tensor(2.6780) , time:  0.0012485980987548828\niter:  4200 , fixed pt res:  tensor(0.4659) , ls:  1 , rel_err:  tensor(2.7382) , time:  0.0015103816986083984\niter:  4250 , fixed pt res:  tensor(0.4457) , ls:  1 , rel_err:  tensor(2.8506) , time:  0.0012941360473632812\niter:  4300 , fixed pt res:  tensor(0.4542) , ls:  1 , rel_err:  tensor(2.8595) , time:  0.0012731552124023438\niter:  4350 , fixed pt res:  tensor(0.4522) , ls:  1 , rel_err:  tensor(2.7833) , time:  0.0013074874877929688\niter:  4400 , fixed pt res:  tensor(0.4330) , ls:  1 , rel_err:  tensor(2.7281) , time:  0.0012753009796142578\niter:  4450 , fixed pt res:  tensor(0.4533) , ls:  1 , rel_err:  tensor(2.6754) , time:  0.0012965202331542969\niter:  4500 , fixed pt res:  tensor(0.4516) , ls:  1 , rel_err:  tensor(2.7161) , time:  0.0012755393981933594\niter:  4550 , fixed pt res:  tensor(0.4267) , ls:  1 , rel_err:  tensor(2.6371) , time:  0.001272439956665039\niter:  4600 , fixed pt res:  tensor(0.4389) , ls:  1 , rel_err:  tensor(2.6671) , time:  0.0013155937194824219\niter:  4650 , fixed pt res:  tensor(0.4410) , ls:  1 , rel_err:  tensor(2.7035) , time:  0.002562284469604492\niter:  4700 , fixed pt res:  tensor(0.4573) , ls:  1 , rel_err:  tensor(2.7827) , time:  0.0012750625610351562\niter:  4750 , fixed pt res:  tensor(0.4588) , ls:  1 , rel_err:  tensor(2.7491) , time:  0.001306295394897461\niter:  4800 , fixed pt res:  tensor(0.4312) , ls:  1 , rel_err:  tensor(2.7217) , time:  0.001256704330444336\niter:  4850 , fixed pt res:  tensor(0.4261) , ls:  1 , rel_err:  tensor(2.6792) , time:  0.0013720989227294922\niter:  4900 , fixed pt res:  tensor(0.4446) , ls:  1 , rel_err:  tensor(2.6511) , time:  0.0012812614440917969\niter:  4950 , fixed pt res:  tensor(0.4327) , ls:  1 , rel_err:  tensor(2.6247) , time:  0.0013003349304199219\niter:  5000 , fixed pt res:  tensor(0.4393) , ls:  1 , rel_err:  tensor(2.7084) , time:  0.0012722015380859375\niter:  5050 , fixed pt res:  tensor(0.4415) , ls:  1 , rel_err:  tensor(2.6556) , time:  0.0012764930725097656\niter:  5100 , fixed pt res:  tensor(0.4376) , ls:  1 , rel_err:  tensor(2.6374) , time:  0.00128936767578125\niter:  5150 , fixed pt res:  tensor(0.4451) , ls:  1 , rel_err:  tensor(2.6773) , time:  0.0012967586517333984\niter:  5200 , fixed pt res:  tensor(0.4329) , ls:  1 , rel_err:  tensor(2.6425) , time:  0.0012586116790771484\niter:  5250 , fixed pt res:  tensor(0.4457) , ls:  1 , rel_err:  tensor(2.6239) , time:  0.0014810562133789062\niter:  5300 , fixed pt res:  tensor(0.4464) , ls:  1 , rel_err:  tensor(2.5870) , time:  0.0012464523315429688\niter:  5350 , fixed pt res:  tensor(0.4333) , ls:  1 , rel_err:  tensor(2.5976) , time:  0.0012700557708740234\niter:  5400 , fixed pt res:  tensor(0.4657) , ls:  1 , rel_err:  tensor(2.6095) , time:  0.002093791961669922\niter:  5450 , fixed pt res:  tensor(0.4228) , ls:  1 , rel_err:  tensor(2.6575) , time:  0.0012738704681396484\niter:  5500 , fixed pt res:  tensor(0.4472) , ls:  1 , rel_err:  tensor(2.6417) , time:  0.001249551773071289\niter:  5550 , fixed pt res:  tensor(0.4502) , ls:  1 , rel_err:  tensor(2.6688) , time:  0.0013189315795898438\niter:  5600 , fixed pt res:  tensor(0.4398) , ls:  1 , rel_err:  tensor(2.5957) , time:  0.0012636184692382812\niter:  5650 , fixed pt res:  tensor(0.4403) , ls:  1 , rel_err:  tensor(2.7314) , time:  0.0015289783477783203\niter:  5700 , fixed pt res:  tensor(0.4475) , ls:  1 , rel_err:  tensor(2.7141) , time:  0.0012578964233398438\niter:  5750 , fixed pt res:  tensor(0.4478) , ls:  1 , rel_err:  tensor(2.5837) , time:  0.0012476444244384766\niter:  5800 , fixed pt res:  tensor(0.4301) , ls:  1 , rel_err:  tensor(2.5068) , time:  0.0012676715850830078\niter:  5850 , fixed pt res:  tensor(0.4321) , ls:  1 , rel_err:  tensor(2.5192) , time:  0.0021185874938964844\niter:  5900 , fixed pt res:  tensor(0.4248) , ls:  1 , rel_err:  tensor(2.5974) , time:  0.0012679100036621094\niter:  5950 , fixed pt res:  tensor(0.4331) , ls:  1 , rel_err:  tensor(2.5246) , time:  0.0012791156768798828\niter:  6000 , fixed pt res:  tensor(0.4590) , ls:  1 , rel_err:  tensor(2.4553) , time:  0.0012676715850830078\niter:  6050 , fixed pt res:  tensor(0.4304) , ls:  1 , rel_err:  tensor(2.4796) , time:  0.0013103485107421875\niter:  6100 , fixed pt res:  tensor(0.4495) , ls:  1 , rel_err:  tensor(2.4144) , time:  0.001794576644897461\niter:  6150 , fixed pt res:  tensor(0.4649) , ls:  1 , rel_err:  tensor(2.4198) , time:  0.0014438629150390625\niter:  6200 , fixed pt res:  tensor(0.4218) , ls:  1 , rel_err:  tensor(2.4917) , time:  0.0012674331665039062\niter:  6250 , fixed pt res:  tensor(0.4481) , ls:  1 , rel_err:  tensor(2.3632) , time:  0.0012516975402832031\niter:  6300 , fixed pt res:  tensor(0.4243) , ls:  1 , rel_err:  tensor(2.4195) , time:  0.0013699531555175781\niter:  6350 , fixed pt res:  tensor(0.4402) , ls:  1 , rel_err:  tensor(2.4351) , time:  0.0012640953063964844\niter:  6400 , fixed pt res:  tensor(0.4558) , ls:  1 , rel_err:  tensor(2.4017) , time:  0.0012509822845458984\niter:  6450 , fixed pt res:  tensor(0.4455) , ls:  1 , rel_err:  tensor(2.4357) , time:  0.0012545585632324219\niter:  6500 , fixed pt res:  tensor(0.4350) , ls:  1 , rel_err:  tensor(2.5407) , time:  0.0012562274932861328\niter:  6550 , fixed pt res:  tensor(0.4334) , ls:  1 , rel_err:  tensor(2.5926) , time:  0.0013165473937988281\niter:  6600 , fixed pt res:  tensor(0.4355) , ls:  1 , rel_err:  tensor(2.5967) , time:  0.0013005733489990234\niter:  6650 , fixed pt res:  tensor(0.4348) , ls:  1 , rel_err:  tensor(2.5459) , time:  0.001241922378540039\niter:  6700 , fixed pt res:  tensor(0.4418) , ls:  1 , rel_err:  tensor(2.4853) , time:  0.0012357234954833984\niter:  6750 , fixed pt res:  tensor(0.4555) , ls:  1 , rel_err:  tensor(2.4952) , time:  0.002100229263305664\niter:  6800 , fixed pt res:  tensor(0.4577) , ls:  1 , rel_err:  tensor(2.5541) , time:  0.001260519027709961\niter:  6850 , fixed pt res:  tensor(0.4522) , ls:  1 , rel_err:  tensor(2.5946) , time:  0.0012519359588623047\niter:  6900 , fixed pt res:  tensor(0.4356) , ls:  1 , rel_err:  tensor(2.6092) , time:  0.0017650127410888672\niter:  6950 , fixed pt res:  tensor(0.4543) , ls:  1 , rel_err:  tensor(2.7244) , time:  0.0012505054473876953\niter:  7000 , fixed pt res:  tensor(0.4458) , ls:  1 , rel_err:  tensor(2.6772) , time:  0.0012483596801757812\niter:  7050 , fixed pt res:  tensor(0.4605) , ls:  1 , rel_err:  tensor(2.6311) , time:  0.0019910335540771484\niter:  7100 , fixed pt res:  tensor(0.4489) , ls:  1 , rel_err:  tensor(2.6301) , time:  0.001264333724975586\niter:  7150 , fixed pt res:  tensor(0.4489) , ls:  1 , rel_err:  tensor(2.6015) , time:  0.0012781620025634766\niter:  7200 , fixed pt res:  tensor(0.4505) , ls:  1 , rel_err:  tensor(2.5872) , time:  0.0012555122375488281\niter:  7250 , fixed pt res:  tensor(0.4641) , ls:  1 , rel_err:  tensor(2.5395) , time:  0.0012531280517578125\niter:  7300 , fixed pt res:  tensor(0.4527) , ls:  1 , rel_err:  tensor(2.5581) , time:  0.001360177993774414\niter:  7350 , fixed pt res:  tensor(0.4420) , ls:  1 , rel_err:  tensor(2.4711) , time:  0.0014126300811767578\niter:  7400 , fixed pt res:  tensor(0.4186) , ls:  1 , rel_err:  tensor(2.4286) , time:  0.001264810562133789\niter:  7450 , fixed pt res:  tensor(0.4505) , ls:  1 , rel_err:  tensor(2.4745) , time:  0.0012433528900146484\niter:  7500 , fixed pt res:  tensor(0.4584) , ls:  1 , rel_err:  tensor(2.4456) , time:  0.0012326240539550781\niter:  7550 , fixed pt res:  tensor(0.4400) , ls:  1 , rel_err:  tensor(2.4178) , time:  0.0012383460998535156\niter:  7600 , fixed pt res:  tensor(0.4476) , ls:  1 , rel_err:  tensor(2.5011) , time:  0.0012450218200683594\niter:  7650 , fixed pt res:  tensor(0.4579) , ls:  1 , rel_err:  tensor(2.6409) , time:  0.0012357234954833984\niter:  7700 , fixed pt res:  tensor(0.4439) , ls:  1 , rel_err:  tensor(2.6166) , time:  0.0012264251708984375\niter:  7750 , fixed pt res:  tensor(0.4443) , ls:  1 , rel_err:  tensor(2.5579) , time:  0.0012443065643310547\niter:  7800 , fixed pt res:  tensor(0.4565) , ls:  1 , rel_err:  tensor(2.5625) , time:  0.0012531280517578125\niter:  7850 , fixed pt res:  tensor(0.4612) , ls:  1 , rel_err:  tensor(2.5585) , time:  0.0012328624725341797\niter:  7900 , fixed pt res:  tensor(0.4464) , ls:  1 , rel_err:  tensor(2.5860) , time:  0.0012888908386230469\niter:  7950 , fixed pt res:  tensor(0.4675) , ls:  1 , rel_err:  tensor(2.6191) , time:  0.0012793540954589844\niter:  8000 , fixed pt res:  tensor(0.4551) , ls:  1 , rel_err:  tensor(2.6183) , time:  0.0012764930725097656\niter:  8050 , fixed pt res:  tensor(0.4404) , ls:  1 , rel_err:  tensor(2.5896) , time:  0.001256704330444336\niter:  8100 , fixed pt res:  tensor(0.4297) , ls:  1 , rel_err:  tensor(2.5343) , time:  0.001226186752319336\niter:  8150 , fixed pt res:  tensor(0.4416) , ls:  1 , rel_err:  tensor(2.5102) , time:  0.0018901824951171875\niter:  8200 , fixed pt res:  tensor(0.4591) , ls:  1 , rel_err:  tensor(2.5327) , time:  0.0012922286987304688\niter:  8250 , fixed pt res:  tensor(0.4611) , ls:  1 , rel_err:  tensor(2.5747) , time:  0.0012788772583007812\niter:  8300 , fixed pt res:  tensor(0.4653) , ls:  1 , rel_err:  tensor(2.5335) , time:  0.0013616085052490234\niter:  8350 , fixed pt res:  tensor(0.4489) , ls:  1 , rel_err:  tensor(2.4418) , time:  0.0012996196746826172\niter:  8400 , fixed pt res:  tensor(0.4395) , ls:  1 , rel_err:  tensor(2.4722) , time:  0.0012898445129394531\niter:  8450 , fixed pt res:  tensor(0.4424) , ls:  1 , rel_err:  tensor(2.6027) , time:  0.0013608932495117188\niter:  8500 , fixed pt res:  tensor(0.4472) , ls:  1 , rel_err:  tensor(2.6112) , time:  0.0013065338134765625\niter:  8550 , fixed pt res:  tensor(0.4407) , ls:  1 , rel_err:  tensor(2.5731) , time:  0.0012345314025878906\niter:  8600 , fixed pt res:  tensor(0.4375) , ls:  1 , rel_err:  tensor(2.5217) , time:  0.0013403892517089844\niter:  8650 , fixed pt res:  tensor(0.4432) , ls:  1 , rel_err:  tensor(2.4493) , time:  0.0012629032135009766\niter:  8700 , fixed pt res:  tensor(0.4439) , ls:  1 , rel_err:  tensor(2.4075) , time:  0.0012497901916503906\niter:  8750 , fixed pt res:  tensor(0.4542) , ls:  1 , rel_err:  tensor(2.5005) , time:  0.0014042854309082031\niter:  8800 , fixed pt res:  tensor(0.4657) , ls:  1 , rel_err:  tensor(2.4351) , time:  0.001285552978515625\niter:  8850 , fixed pt res:  tensor(0.4505) , ls:  1 , rel_err:  tensor(2.4636) , time:  0.0013206005096435547\niter:  8900 , fixed pt res:  tensor(0.4628) , ls:  1 , rel_err:  tensor(2.4797) , time:  0.0013439655303955078\niter:  8950 , fixed pt res:  tensor(0.4455) , ls:  1 , rel_err:  tensor(2.5193) , time:  0.0012857913970947266\niter:  9000 , fixed pt res:  tensor(0.4604) , ls:  1 , rel_err:  tensor(2.4887) , time:  0.0012402534484863281\niter:  9050 , fixed pt res:  tensor(0.4510) , ls:  1 , rel_err:  tensor(2.4719) , time:  0.0016787052154541016\niter:  9100 , fixed pt res:  tensor(0.4549) , ls:  1 , rel_err:  tensor(2.5755) , time:  0.0013275146484375\niter:  9150 , fixed pt res:  tensor(0.4400) , ls:  1 , rel_err:  tensor(2.5101) , time:  0.0013310909271240234\niter:  9200 , fixed pt res:  tensor(0.4531) , ls:  1 , rel_err:  tensor(2.5554) , time:  0.001753091812133789\niter:  9250 , fixed pt res:  tensor(0.4451) , ls:  1 , rel_err:  tensor(2.5776) , time:  0.0015501976013183594\niter:  9300 , fixed pt res:  tensor(0.4418) , ls:  1 , rel_err:  tensor(2.5312) , time:  0.0012629032135009766\niter:  9350 , fixed pt res:  tensor(0.4620) , ls:  1 , rel_err:  tensor(2.5556) , time:  0.0012884140014648438\niter:  9400 , fixed pt res:  tensor(0.4415) , ls:  1 , rel_err:  tensor(2.6350) , time:  0.0013172626495361328\niter:  9450 , fixed pt res:  tensor(0.4341) , ls:  1 , rel_err:  tensor(2.7121) , time:  0.0012619495391845703\niter:  9500 , fixed pt res:  tensor(0.4464) , ls:  1 , rel_err:  tensor(2.7205) , time:  0.001325845718383789\niter:  9550 , fixed pt res:  tensor(0.4657) , ls:  1 , rel_err:  tensor(2.6309) , time:  0.0012462139129638672\niter:  9600 , fixed pt res:  tensor(0.4424) , ls:  1 , rel_err:  tensor(2.5812) , time:  0.0012547969818115234\niter:  9650 , fixed pt res:  tensor(0.4499) , ls:  1 , rel_err:  tensor(2.5472) , time:  0.0013298988342285156\niter:  9700 , fixed pt res:  tensor(0.4457) , ls:  1 , rel_err:  tensor(2.5958) , time:  0.0012683868408203125\niter:  9750 , fixed pt res:  tensor(0.4490) , ls:  1 , rel_err:  tensor(2.5856) , time:  0.0012929439544677734\niter:  9800 , fixed pt res:  tensor(0.4406) , ls:  1 , rel_err:  tensor(2.5817) , time:  0.0021517276763916016\niter:  9850 , fixed pt res:  tensor(0.4568) , ls:  1 , rel_err:  tensor(2.5975) , time:  0.0012955665588378906\niter:  9900 , fixed pt res:  tensor(0.4475) , ls:  1 , rel_err:  tensor(2.5970) , time:  0.0013790130615234375\niter:  9950 , fixed pt res:  tensor(0.4553) , ls:  1 , rel_err:  tensor(2.6232) , time:  0.001971006393432617\niter:  10000 , fixed pt res:  tensor(0.4416) , ls:  1 , rel_err:  tensor(2.7439) , time:  0.0013000965118408203\ntrial  1  finished after 13.767562627792358\nnorm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) =  tensor(0.)\nNumber of Samples = 1000\niter:  50 , fixed pt res:  tensor(0.6200) , ls:  1 , rel_err:  tensor(15.2804) , time:  0.0013267993927001953\niter:  100 , fixed pt res:  tensor(0.2911) , ls:  1 , rel_err:  tensor(14.1417) , time:  0.001394510269165039\niter:  150 , fixed pt res:  tensor(0.1899) , ls:  1 , rel_err:  tensor(13.2434) , time:  0.0013072490692138672\niter:  200 , fixed pt res:  tensor(0.1576) , ls:  1 , rel_err:  tensor(12.3547) , time:  0.0013120174407958984\niter:  250 , fixed pt res:  tensor(0.1532) , ls:  1 , rel_err:  tensor(11.5270) , time:  0.0013427734375\niter:  300 , fixed pt res:  tensor(0.1436) , ls:  1 , rel_err:  tensor(10.7576) , time:  0.0013353824615478516\niter:  350 , fixed pt res:  tensor(0.1472) , ls:  1 , rel_err:  tensor(10.0357) , time:  0.0013246536254882812\niter:  400 , fixed pt res:  tensor(0.1415) , ls:  1 , rel_err:  tensor(9.3400) , time:  0.0013191699981689453\niter:  450 , fixed pt res:  tensor(0.1464) , ls:  1 , rel_err:  tensor(8.6775) , time:  0.0013461112976074219\niter:  500 , fixed pt res:  tensor(0.1451) , ls:  1 , rel_err:  tensor(8.0616) , time:  0.0013186931610107422\niter:  550 , fixed pt res:  tensor(0.1401) , ls:  1 , rel_err:  tensor(7.5455) , time:  0.0013468265533447266\niter:  600 , fixed pt res:  tensor(0.1464) , ls:  1 , rel_err:  tensor(7.0520) , time:  0.0013208389282226562\niter:  650 , fixed pt res:  tensor(0.1461) , ls:  1 , rel_err:  tensor(6.6107) , time:  0.0013234615325927734\niter:  700 , fixed pt res:  tensor(0.1416) , ls:  1 , rel_err:  tensor(6.1561) , time:  0.0013158321380615234\niter:  750 , fixed pt res:  tensor(0.1482) , ls:  1 , rel_err:  tensor(5.7341) , time:  0.0013077259063720703\niter:  800 , fixed pt res:  tensor(0.1493) , ls:  1 , rel_err:  tensor(5.3443) , time:  0.0013120174407958984\niter:  850 , fixed pt res:  tensor(0.1430) , ls:  1 , rel_err:  tensor(4.9980) , time:  0.001325845718383789\niter:  900 , fixed pt res:  tensor(0.1422) , ls:  1 , rel_err:  tensor(4.6833) , time:  0.0013217926025390625\niter:  950 , fixed pt res:  tensor(0.1458) , ls:  1 , rel_err:  tensor(4.3519) , time:  0.0013098716735839844\niter:  1000 , fixed pt res:  tensor(0.1456) , ls:  1 , rel_err:  tensor(4.0684) , time:  0.0013206005096435547\niter:  1050 , fixed pt res:  tensor(0.1501) , ls:  1 , rel_err:  tensor(3.8478) , time:  0.0013120174407958984\niter:  1100 , fixed pt res:  tensor(0.1433) , ls:  1 , rel_err:  tensor(3.5528) , time:  0.0013175010681152344\niter:  1150 , fixed pt res:  tensor(0.1389) , ls:  1 , rel_err:  tensor(3.3633) , time:  0.0013332366943359375\niter:  1200 , fixed pt res:  tensor(0.1424) , ls:  1 , rel_err:  tensor(3.1406) , time:  0.0016374588012695312\niter:  1250 , fixed pt res:  tensor(0.1448) , ls:  1 , rel_err:  tensor(2.9578) , time:  0.0013070106506347656\niter:  1300 , fixed pt res:  tensor(0.1426) , ls:  1 , rel_err:  tensor(2.8013) , time:  0.001321554183959961\niter:  1350 , fixed pt res:  tensor(0.1404) , ls:  1 , rel_err:  tensor(2.6524) , time:  0.0013594627380371094\niter:  1400 , fixed pt res:  tensor(0.1420) , ls:  1 , rel_err:  tensor(2.4768) , time:  0.0013468265533447266\niter:  1450 , fixed pt res:  tensor(0.1411) , ls:  1 , rel_err:  tensor(2.3400) , time:  0.0013494491577148438\niter:  1500 , fixed pt res:  tensor(0.1338) , ls:  1 , rel_err:  tensor(2.1864) , time:  0.0013415813446044922\niter:  1550 , fixed pt res:  tensor(0.1412) , ls:  1 , rel_err:  tensor(2.0526) , time:  0.0012879371643066406\niter:  1600 , fixed pt res:  tensor(0.1430) , ls:  1 , rel_err:  tensor(1.9605) , time:  0.0013277530670166016\niter:  1650 , fixed pt res:  tensor(0.1379) , ls:  1 , rel_err:  tensor(1.8693) , time:  0.0013251304626464844\niter:  1700 , fixed pt res:  tensor(0.1475) , ls:  1 , rel_err:  tensor(1.7646) , time:  0.0013089179992675781\niter:  1750 , fixed pt res:  tensor(0.1407) , ls:  1 , rel_err:  tensor(1.6703) , time:  0.0013682842254638672\niter:  1800 , fixed pt res:  tensor(0.1371) , ls:  1 , rel_err:  tensor(1.5463) , time:  0.0013401508331298828\niter:  1850 , fixed pt res:  tensor(0.1418) , ls:  1 , rel_err:  tensor(1.4633) , time:  0.0013346672058105469\niter:  1900 , fixed pt res:  tensor(0.1449) , ls:  1 , rel_err:  tensor(1.3959) , time:  0.001359701156616211\niter:  1950 , fixed pt res:  tensor(0.1457) , ls:  1 , rel_err:  tensor(1.3546) , time:  0.0013265609741210938\niter:  2000 , fixed pt res:  tensor(0.1362) , ls:  1 , rel_err:  tensor(1.2826) , time:  0.0013346672058105469\niter:  2050 , fixed pt res:  tensor(0.1465) , ls:  1 , rel_err:  tensor(1.2340) , time:  0.00138092041015625\niter:  2100 , fixed pt res:  tensor(0.1402) , ls:  1 , rel_err:  tensor(1.1610) , time:  0.0013661384582519531\niter:  2150 , fixed pt res:  tensor(0.1354) , ls:  1 , rel_err:  tensor(1.1367) , time:  0.0012798309326171875\niter:  2200 , fixed pt res:  tensor(0.1405) , ls:  1 , rel_err:  tensor(1.1296) , time:  0.001314401626586914\niter:  2250 , fixed pt res:  tensor(0.1388) , ls:  1 , rel_err:  tensor(1.0809) , time:  0.0013225078582763672\niter:  2300 , fixed pt res:  tensor(0.1445) , ls:  1 , rel_err:  tensor(1.0908) , time:  0.0013470649719238281\niter:  2350 , fixed pt res:  tensor(0.1458) , ls:  1 , rel_err:  tensor(1.0808) , time:  0.0013251304626464844\niter:  2400 , fixed pt res:  tensor(0.1373) , ls:  1 , rel_err:  tensor(1.0571) , time:  0.0016121864318847656\niter:  2450 , fixed pt res:  tensor(0.1444) , ls:  1 , rel_err:  tensor(1.0480) , time:  0.0013060569763183594\niter:  2500 , fixed pt res:  tensor(0.1383) , ls:  1 , rel_err:  tensor(1.0257) , time:  0.0013158321380615234\niter:  2550 , fixed pt res:  tensor(0.1422) , ls:  1 , rel_err:  tensor(0.9971) , time:  0.0013117790222167969\niter:  2600 , fixed pt res:  tensor(0.1411) , ls:  1 , rel_err:  tensor(0.9783) , time:  0.001316070556640625\niter:  2650 , fixed pt res:  tensor(0.1514) , ls:  1 , rel_err:  tensor(0.9526) , time:  0.0013360977172851562\niter:  2700 , fixed pt res:  tensor(0.1430) , ls:  1 , rel_err:  tensor(0.9029) , time:  0.001321554183959961\niter:  2750 , fixed pt res:  tensor(0.1389) , ls:  1 , rel_err:  tensor(0.8754) , time:  0.0013165473937988281\niter:  2800 , fixed pt res:  tensor(0.1417) , ls:  1 , rel_err:  tensor(0.8571) , time:  0.0013239383697509766\niter:  2850 , fixed pt res:  tensor(0.1427) , ls:  1 , rel_err:  tensor(0.8450) , time:  0.0015385150909423828\niter:  2900 , fixed pt res:  tensor(0.1392) , ls:  1 , rel_err:  tensor(0.8497) , time:  0.0013189315795898438\niter:  2950 , fixed pt res:  tensor(0.1374) , ls:  1 , rel_err:  tensor(0.8491) , time:  0.0013012886047363281\niter:  3000 , fixed pt res:  tensor(0.1415) , ls:  1 , rel_err:  tensor(0.8551) , time:  0.0013537406921386719\niter:  3050 , fixed pt res:  tensor(0.1446) , ls:  1 , rel_err:  tensor(0.8554) , time:  0.0013756752014160156\niter:  3100 , fixed pt res:  tensor(0.1413) , ls:  1 , rel_err:  tensor(0.8232) , time:  0.0013523101806640625\niter:  3150 , fixed pt res:  tensor(0.1374) , ls:  1 , rel_err:  tensor(0.7949) , time:  0.0013320446014404297\niter:  3200 , fixed pt res:  tensor(0.1393) , ls:  1 , rel_err:  tensor(0.8140) , time:  0.0013515949249267578\niter:  3250 , fixed pt res:  tensor(0.1373) , ls:  1 , rel_err:  tensor(0.7867) , time:  0.0013611316680908203\niter:  3300 , fixed pt res:  tensor(0.1399) , ls:  1 , rel_err:  tensor(0.7978) , time:  0.0013480186462402344\niter:  3350 , fixed pt res:  tensor(0.1426) , ls:  1 , rel_err:  tensor(0.7789) , time:  0.0013136863708496094\niter:  3400 , fixed pt res:  tensor(0.1410) , ls:  1 , rel_err:  tensor(0.7430) , time:  0.0014259815216064453\niter:  3450 , fixed pt res:  tensor(0.1390) , ls:  1 , rel_err:  tensor(0.7700) , time:  0.001317739486694336\niter:  3500 , fixed pt res:  tensor(0.1388) , ls:  1 , rel_err:  tensor(0.7716) , time:  0.0013110637664794922\niter:  3550 , fixed pt res:  tensor(0.1428) , ls:  1 , rel_err:  tensor(0.7730) , time:  0.0013706684112548828\niter:  3600 , fixed pt res:  tensor(0.1406) , ls:  1 , rel_err:  tensor(0.7427) , time:  0.0013256072998046875\niter:  3650 , fixed pt res:  tensor(0.1371) , ls:  1 , rel_err:  tensor(0.7262) , time:  0.001313924789428711\niter:  3700 , fixed pt res:  tensor(0.1399) , ls:  1 , rel_err:  tensor(0.7157) , time:  0.0013587474822998047\niter:  3750 , fixed pt res:  tensor(0.1349) , ls:  1 , rel_err:  tensor(0.7001) , time:  0.0013885498046875\niter:  3800 , fixed pt res:  tensor(0.1397) , ls:  1 , rel_err:  tensor(0.7020) , time:  0.001420736312866211\niter:  3850 , fixed pt res:  tensor(0.1456) , ls:  1 , rel_err:  tensor(0.7235) , time:  0.0013663768768310547\niter:  3900 , fixed pt res:  tensor(0.1397) , ls:  1 , rel_err:  tensor(0.7402) , time:  0.0013508796691894531\niter:  3950 , fixed pt res:  tensor(0.1425) , ls:  1 , rel_err:  tensor(0.7389) , time:  0.0018417835235595703\niter:  4000 , fixed pt res:  tensor(0.1436) , ls:  1 , rel_err:  tensor(0.7703) , time:  0.0014348030090332031\niter:  4050 , fixed pt res:  tensor(0.1337) , ls:  1 , rel_err:  tensor(0.7420) , time:  0.0013256072998046875\niter:  4100 , fixed pt res:  tensor(0.1397) , ls:  1 , rel_err:  tensor(0.7171) , time:  0.0014235973358154297\niter:  4150 , fixed pt res:  tensor(0.1453) , ls:  1 , rel_err:  tensor(0.7282) , time:  0.0013887882232666016\niter:  4200 , fixed pt res:  tensor(0.1385) , ls:  1 , rel_err:  tensor(0.7112) , time:  0.0013659000396728516\niter:  4250 , fixed pt res:  tensor(0.1352) , ls:  1 , rel_err:  tensor(0.7160) , time:  0.0013580322265625\niter:  4300 , fixed pt res:  tensor(0.1392) , ls:  1 , rel_err:  tensor(0.7100) , time:  0.0013353824615478516\niter:  4350 , fixed pt res:  tensor(0.1354) , ls:  1 , rel_err:  tensor(0.6963) , time:  0.001379251480102539\niter:  4400 , fixed pt res:  tensor(0.1355) , ls:  1 , rel_err:  tensor(0.7218) , time:  0.0014262199401855469\niter:  4450 , fixed pt res:  tensor(0.1435) , ls:  1 , rel_err:  tensor(0.7312) , time:  0.0013265609741210938\niter:  4500 , fixed pt res:  tensor(0.1412) , ls:  1 , rel_err:  tensor(0.7417) , time:  0.001306295394897461\niter:  4550 , fixed pt res:  tensor(0.1381) , ls:  1 , rel_err:  tensor(0.7293) , time:  0.001348257064819336\niter:  4600 , fixed pt res:  tensor(0.1438) , ls:  1 , rel_err:  tensor(0.7312) , time:  0.0012989044189453125\niter:  4650 , fixed pt res:  tensor(0.1411) , ls:  1 , rel_err:  tensor(0.7336) , time:  0.001322031021118164\niter:  4700 , fixed pt res:  tensor(0.1406) , ls:  1 , rel_err:  tensor(0.7303) , time:  0.0013480186462402344\niter:  4750 , fixed pt res:  tensor(0.1405) , ls:  1 , rel_err:  tensor(0.7269) , time:  0.0015642642974853516\niter:  4800 , fixed pt res:  tensor(0.1401) , ls:  1 , rel_err:  tensor(0.7372) , time:  0.0012898445129394531\niter:  4850 , fixed pt res:  tensor(0.1392) , ls:  1 , rel_err:  tensor(0.7530) , time:  0.0013241767883300781\niter:  4900 , fixed pt res:  tensor(0.1426) , ls:  1 , rel_err:  tensor(0.7443) , time:  0.0013282299041748047\niter:  4950 , fixed pt res:  tensor(0.1415) , ls:  1 , rel_err:  tensor(0.7270) , time:  0.0013480186462402344\niter:  5000 , fixed pt res:  tensor(0.1400) , ls:  1 , rel_err:  tensor(0.7463) , time:  0.002387523651123047\niter:  5050 , fixed pt res:  tensor(0.1389) , ls:  1 , rel_err:  tensor(0.7224) , time:  0.001508951187133789\niter:  5100 , fixed pt res:  tensor(0.1411) , ls:  1 , rel_err:  tensor(0.7328) , time:  0.0013210773468017578\niter:  5150 , fixed pt res:  tensor(0.1442) , ls:  1 , rel_err:  tensor(0.7383) , time:  0.0013167858123779297\niter:  5200 , fixed pt res:  tensor(0.1433) , ls:  1 , rel_err:  tensor(0.7134) , time:  0.0013079643249511719\niter:  5250 , fixed pt res:  tensor(0.1407) , ls:  1 , rel_err:  tensor(0.7117) , time:  0.0013206005096435547\niter:  5300 , fixed pt res:  tensor(0.1411) , ls:  1 , rel_err:  tensor(0.7247) , time:  0.001340627670288086\niter:  5350 , fixed pt res:  tensor(0.1418) , ls:  1 , rel_err:  tensor(0.7424) , time:  0.0013110637664794922\niter:  5400 , fixed pt res:  tensor(0.1416) , ls:  1 , rel_err:  tensor(0.7371) , time:  0.0013244152069091797\niter:  5450 , fixed pt res:  tensor(0.1425) , ls:  1 , rel_err:  tensor(0.7402) , time:  0.0013208389282226562\niter:  5500 , fixed pt res:  tensor(0.1421) , ls:  1 , rel_err:  tensor(0.7102) , time:  0.0013213157653808594\niter:  5550 , fixed pt res:  tensor(0.1387) , ls:  1 , rel_err:  tensor(0.7229) , time:  0.0013065338134765625\niter:  5600 , fixed pt res:  tensor(0.1406) , ls:  1 , rel_err:  tensor(0.6984) , time:  0.001306772232055664\niter:  5650 , fixed pt res:  tensor(0.1352) , ls:  1 , rel_err:  tensor(0.6988) , time:  0.001354217529296875\niter:  5700 , fixed pt res:  tensor(0.1405) , ls:  1 , rel_err:  tensor(0.7207) , time:  0.0013785362243652344\niter:  5750 , fixed pt res:  tensor(0.1384) , ls:  1 , rel_err:  tensor(0.7091) , time:  0.0013396739959716797\niter:  5800 , fixed pt res:  tensor(0.1351) , ls:  1 , rel_err:  tensor(0.7164) , time:  0.001318216323852539\niter:  5850 , fixed pt res:  tensor(0.1448) , ls:  1 , rel_err:  tensor(0.7072) , time:  0.0013074874877929688\niter:  5900 , fixed pt res:  tensor(0.1397) , ls:  1 , rel_err:  tensor(0.7139) , time:  0.0013289451599121094\niter:  5950 , fixed pt res:  tensor(0.1380) , ls:  1 , rel_err:  tensor(0.7105) , time:  0.0013780593872070312\niter:  6000 , fixed pt res:  tensor(0.1332) , ls:  1 , rel_err:  tensor(0.7013) , time:  0.0013089179992675781\niter:  6050 , fixed pt res:  tensor(0.1376) , ls:  1 , rel_err:  tensor(0.7175) , time:  0.0012922286987304688\niter:  6100 , fixed pt res:  tensor(0.1384) , ls:  1 , rel_err:  tensor(0.7122) , time:  0.0013475418090820312\niter:  6150 , fixed pt res:  tensor(0.1434) , ls:  1 , rel_err:  tensor(0.7273) , time:  0.0012962818145751953\niter:  6200 , fixed pt res:  tensor(0.1402) , ls:  1 , rel_err:  tensor(0.7510) , time:  0.001360177993774414\niter:  6250 , fixed pt res:  tensor(0.1441) , ls:  1 , rel_err:  tensor(0.7371) , time:  0.001276254653930664\niter:  6300 , fixed pt res:  tensor(0.1403) , ls:  1 , rel_err:  tensor(0.7318) , time:  0.0013804435729980469\niter:  6350 , fixed pt res:  tensor(0.1406) , ls:  1 , rel_err:  tensor(0.7090) , time:  0.0012996196746826172\niter:  6400 , fixed pt res:  tensor(0.1324) , ls:  1 , rel_err:  tensor(0.7121) , time:  0.001295328140258789\niter:  6450 , fixed pt res:  tensor(0.1376) , ls:  1 , rel_err:  tensor(0.7380) , time:  0.0013594627380371094\niter:  6500 , fixed pt res:  tensor(0.1328) , ls:  1 , rel_err:  tensor(0.7118) , time:  0.001314401626586914\niter:  6550 , fixed pt res:  tensor(0.1424) , ls:  1 , rel_err:  tensor(0.6888) , time:  0.0013668537139892578\niter:  6600 , fixed pt res:  tensor(0.1386) , ls:  1 , rel_err:  tensor(0.6796) , time:  0.0013508796691894531\niter:  6650 , fixed pt res:  tensor(0.1440) , ls:  1 , rel_err:  tensor(0.6752) , time:  0.0013365745544433594\niter:  6700 , fixed pt res:  tensor(0.1395) , ls:  1 , rel_err:  tensor(0.6984) , time:  0.0013523101806640625\niter:  6750 , fixed pt res:  tensor(0.1383) , ls:  1 , rel_err:  tensor(0.6993) , time:  0.0013263225555419922\niter:  6800 , fixed pt res:  tensor(0.1401) , ls:  1 , rel_err:  tensor(0.6909) , time:  0.0013306140899658203\niter:  6850 , fixed pt res:  tensor(0.1416) , ls:  1 , rel_err:  tensor(0.6914) , time:  0.0013840198516845703\niter:  6900 , fixed pt res:  tensor(0.1435) , ls:  1 , rel_err:  tensor(0.6869) , time:  0.0013513565063476562\niter:  6950 , fixed pt res:  tensor(0.1434) , ls:  1 , rel_err:  tensor(0.7111) , time:  0.0012936592102050781\niter:  7000 , fixed pt res:  tensor(0.1376) , ls:  1 , rel_err:  tensor(0.6947) , time:  0.0013315677642822266\niter:  7050 , fixed pt res:  tensor(0.1412) , ls:  1 , rel_err:  tensor(0.6983) , time:  0.0012993812561035156\niter:  7100 , fixed pt res:  tensor(0.1369) , ls:  1 , rel_err:  tensor(0.7071) , time:  0.0013473033905029297\niter:  7150 , fixed pt res:  tensor(0.1388) , ls:  1 , rel_err:  tensor(0.7188) , time:  0.0013604164123535156\niter:  7200 , fixed pt res:  tensor(0.1369) , ls:  1 , rel_err:  tensor(0.7448) , time:  0.0013170242309570312\niter:  7250 , fixed pt res:  tensor(0.1319) , ls:  1 , rel_err:  tensor(0.7368) , time:  0.0013206005096435547\niter:  7300 , fixed pt res:  tensor(0.1384) , ls:  1 , rel_err:  tensor(0.7549) , time:  0.0013265609741210938\niter:  7350 , fixed pt res:  tensor(0.1407) , ls:  1 , rel_err:  tensor(0.7553) , time:  0.0013527870178222656\niter:  7400 , fixed pt res:  tensor(0.1432) , ls:  1 , rel_err:  tensor(0.7565) , time:  0.0013544559478759766\niter:  7450 , fixed pt res:  tensor(0.1406) , ls:  1 , rel_err:  tensor(0.7565) , time:  0.0013697147369384766\niter:  7500 , fixed pt res:  tensor(0.1371) , ls:  1 , rel_err:  tensor(0.7860) , time:  0.0013203620910644531\niter:  7550 , fixed pt res:  tensor(0.1376) , ls:  1 , rel_err:  tensor(0.7820) , time:  0.0013303756713867188\niter:  7600 , fixed pt res:  tensor(0.1436) , ls:  1 , rel_err:  tensor(0.7663) , time:  0.0013909339904785156\niter:  7650 , fixed pt res:  tensor(0.1442) , ls:  1 , rel_err:  tensor(0.7851) , time:  0.0013649463653564453\niter:  7700 , fixed pt res:  tensor(0.1420) , ls:  1 , rel_err:  tensor(0.7762) , time:  0.0013232231140136719\niter:  7750 , fixed pt res:  tensor(0.1393) , ls:  1 , rel_err:  tensor(0.7632) , time:  0.0013110637664794922\niter:  7800 , fixed pt res:  tensor(0.1449) , ls:  1 , rel_err:  tensor(0.7567) , time:  0.0013320446014404297\niter:  7850 , fixed pt res:  tensor(0.1384) , ls:  1 , rel_err:  tensor(0.7296) , time:  0.001306772232055664\niter:  7900 , fixed pt res:  tensor(0.1419) , ls:  1 , rel_err:  tensor(0.7354) , time:  0.0013387203216552734\niter:  7950 , fixed pt res:  tensor(0.1383) , ls:  1 , rel_err:  tensor(0.7613) , time:  0.0013384819030761719\niter:  8000 , fixed pt res:  tensor(0.1419) , ls:  1 , rel_err:  tensor(0.7467) , time:  0.0013229846954345703\niter:  8050 , fixed pt res:  tensor(0.1452) , ls:  1 , rel_err:  tensor(0.7224) , time:  0.0013377666473388672\niter:  8100 , fixed pt res:  tensor(0.1356) , ls:  1 , rel_err:  tensor(0.7609) , time:  0.0013251304626464844\niter:  8150 , fixed pt res:  tensor(0.1378) , ls:  1 , rel_err:  tensor(0.7480) , time:  0.0013353824615478516\niter:  8200 , fixed pt res:  tensor(0.1463) , ls:  1 , rel_err:  tensor(0.7545) , time:  0.001306772232055664\niter:  8250 , fixed pt res:  tensor(0.1358) , ls:  1 , rel_err:  tensor(0.7275) , time:  0.0013210773468017578\niter:  8300 , fixed pt res:  tensor(0.1417) , ls:  1 , rel_err:  tensor(0.7226) , time:  0.0013229846954345703\niter:  8350 , fixed pt res:  tensor(0.1443) , ls:  1 , rel_err:  tensor(0.7175) , time:  0.0012788772583007812\niter:  8400 , fixed pt res:  tensor(0.1343) , ls:  1 , rel_err:  tensor(0.6982) , time:  0.001321554183959961\niter:  8450 , fixed pt res:  tensor(0.1443) , ls:  1 , rel_err:  tensor(0.6652) , time:  0.0013155937194824219\niter:  8500 , fixed pt res:  tensor(0.1454) , ls:  1 , rel_err:  tensor(0.6660) , time:  0.0013110637664794922\niter:  8550 , fixed pt res:  tensor(0.1424) , ls:  1 , rel_err:  tensor(0.6580) , time:  0.001312255859375\niter:  8600 , fixed pt res:  tensor(0.1389) , ls:  1 , rel_err:  tensor(0.6790) , time:  0.0013172626495361328\niter:  8650 , fixed pt res:  tensor(0.1384) , ls:  1 , rel_err:  tensor(0.6680) , time:  0.0013356208801269531\niter:  8700 , fixed pt res:  tensor(0.1440) , ls:  1 , rel_err:  tensor(0.6871) , time:  0.0013518333435058594\niter:  8750 , fixed pt res:  tensor(0.1415) , ls:  1 , rel_err:  tensor(0.6838) , time:  0.001293182373046875\niter:  8800 , fixed pt res:  tensor(0.1370) , ls:  1 , rel_err:  tensor(0.7017) , time:  0.0013251304626464844\niter:  8850 , fixed pt res:  tensor(0.1383) , ls:  1 , rel_err:  tensor(0.6953) , time:  0.001463174819946289\niter:  8900 , fixed pt res:  tensor(0.1370) , ls:  1 , rel_err:  tensor(0.6880) , time:  0.0013523101806640625\niter:  8950 , fixed pt res:  tensor(0.1372) , ls:  1 , rel_err:  tensor(0.7067) , time:  0.0013394355773925781\niter:  9000 , fixed pt res:  tensor(0.1405) , ls:  1 , rel_err:  tensor(0.6999) , time:  0.0013720989227294922\niter:  9050 , fixed pt res:  tensor(0.1458) , ls:  1 , rel_err:  tensor(0.7255) , time:  0.0013670921325683594\niter:  9100 , fixed pt res:  tensor(0.1417) , ls:  1 , rel_err:  tensor(0.7175) , time:  0.001369476318359375\niter:  9150 , fixed pt res:  tensor(0.1353) , ls:  1 , rel_err:  tensor(0.7578) , time:  0.0013086795806884766\niter:  9200 , fixed pt res:  tensor(0.1428) , ls:  1 , rel_err:  tensor(0.7319) , time:  0.0013167858123779297\niter:  9250 , fixed pt res:  tensor(0.1454) , ls:  1 , rel_err:  tensor(0.7346) , time:  0.00135040283203125\niter:  9300 , fixed pt res:  tensor(0.1510) , ls:  1 , rel_err:  tensor(0.7130) , time:  0.0013244152069091797\niter:  9350 , fixed pt res:  tensor(0.1436) , ls:  1 , rel_err:  tensor(0.7370) , time:  0.0013294219970703125\niter:  9400 , fixed pt res:  tensor(0.1460) , ls:  1 , rel_err:  tensor(0.7486) , time:  0.0013434886932373047\niter:  9450 , fixed pt res:  tensor(0.1476) , ls:  1 , rel_err:  tensor(0.7702) , time:  0.0013148784637451172\niter:  9500 , fixed pt res:  tensor(0.1363) , ls:  1 , rel_err:  tensor(0.7755) , time:  0.0013265609741210938\niter:  9550 , fixed pt res:  tensor(0.1386) , ls:  1 , rel_err:  tensor(0.8153) , time:  0.0013353824615478516\niter:  9600 , fixed pt res:  tensor(0.1428) , ls:  1 , rel_err:  tensor(0.8055) , time:  0.0013208389282226562\niter:  9650 , fixed pt res:  tensor(0.1402) , ls:  1 , rel_err:  tensor(0.8265) , time:  0.0013794898986816406\niter:  9700 , fixed pt res:  tensor(0.1369) , ls:  1 , rel_err:  tensor(0.8177) , time:  0.00130462646484375\niter:  9750 , fixed pt res:  tensor(0.1397) , ls:  1 , rel_err:  tensor(0.8112) , time:  0.0013453960418701172\niter:  9800 , fixed pt res:  tensor(0.1359) , ls:  1 , rel_err:  tensor(0.7822) , time:  0.0012867450714111328\niter:  9850 , fixed pt res:  tensor(0.1455) , ls:  1 , rel_err:  tensor(0.7920) , time:  0.0013346672058105469\niter:  9900 , fixed pt res:  tensor(0.1358) , ls:  1 , rel_err:  tensor(0.7939) , time:  0.0013093948364257812\niter:  9950 , fixed pt res:  tensor(0.1455) , ls:  1 , rel_err:  tensor(0.7798) , time:  0.0013077259063720703\niter:  10000 , fixed pt res:  tensor(0.1357) , ls:  1 , rel_err:  tensor(0.7740) , time:  0.0013074874877929688\ntrial  1  finished after 14.293195247650146\nnorm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) =  tensor(0.)\nNumber of Samples = 10000\niter:  50 , fixed pt res:  tensor(0.5998) , ls:  1 , rel_err:  tensor(15.2757) , time:  0.0027074813842773438\niter:  100 , fixed pt res:  tensor(0.2594) , ls:  1 , rel_err:  tensor(14.1686) , time:  0.0026099681854248047\niter:  150 , fixed pt res:  tensor(0.1279) , ls:  1 , rel_err:  tensor(13.2236) , time:  0.002675771713256836\niter:  200 , fixed pt res:  tensor(0.0737) , ls:  1 , rel_err:  tensor(12.3519) , time:  0.0026006698608398438\niter:  250 , fixed pt res:  tensor(0.0603) , ls:  1 , rel_err:  tensor(11.5406) , time:  0.0026094913482666016\niter:  300 , fixed pt res:  tensor(0.0584) , ls:  1 , rel_err:  tensor(10.7629) , time:  0.0026221275329589844\niter:  350 , fixed pt res:  tensor(0.0541) , ls:  1 , rel_err:  tensor(10.0456) , time:  0.0026645660400390625\niter:  400 , fixed pt res:  tensor(0.0505) , ls:  1 , rel_err:  tensor(9.3683) , time:  0.0026504993438720703\niter:  450 , fixed pt res:  tensor(0.0519) , ls:  1 , rel_err:  tensor(8.7420) , time:  0.002627849578857422\niter:  500 , fixed pt res:  tensor(0.0506) , ls:  1 , rel_err:  tensor(8.1479) , time:  0.0025856494903564453\niter:  550 , fixed pt res:  tensor(0.0503) , ls:  1 , rel_err:  tensor(7.5810) , time:  0.002635955810546875\niter:  600 , fixed pt res:  tensor(0.0478) , ls:  1 , rel_err:  tensor(7.0501) , time:  0.0025839805603027344\niter:  650 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(6.5615) , time:  0.002607583999633789\niter:  700 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(6.1033) , time:  0.002591848373413086\niter:  750 , fixed pt res:  tensor(0.0472) , ls:  1 , rel_err:  tensor(5.6785) , time:  0.0026273727416992188\niter:  800 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(5.2926) , time:  0.0025899410247802734\niter:  850 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(4.9309) , time:  0.002669811248779297\niter:  900 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(4.5934) , time:  0.0026297569274902344\niter:  950 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(4.2891) , time:  0.002602815628051758\niter:  1000 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(4.0050) , time:  0.0025856494903564453\niter:  1050 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(3.7418) , time:  0.002600431442260742\niter:  1100 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(3.4833) , time:  0.0026674270629882812\niter:  1150 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(3.2542) , time:  0.0025968551635742188\niter:  1200 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(3.0267) , time:  0.0026426315307617188\niter:  1250 , fixed pt res:  tensor(0.0428) , ls:  1 , rel_err:  tensor(2.8332) , time:  0.0026497840881347656\niter:  1300 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(2.6491) , time:  0.0026335716247558594\niter:  1350 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(2.4943) , time:  0.0026102066040039062\niter:  1400 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(2.3482) , time:  0.002626180648803711\niter:  1450 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(2.1982) , time:  0.0025713443756103516\niter:  1500 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(2.0771) , time:  0.002585172653198242\niter:  1550 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(1.9496) , time:  0.002601146697998047\niter:  1600 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(1.8299) , time:  0.002844095230102539\niter:  1650 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(1.7146) , time:  0.002629995346069336\niter:  1700 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.6179) , time:  0.0026674270629882812\niter:  1750 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.5289) , time:  0.0026276111602783203\niter:  1800 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(1.4434) , time:  0.0029823780059814453\niter:  1850 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(1.3554) , time:  0.0026099681854248047\niter:  1900 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(1.2854) , time:  0.002686023712158203\niter:  1950 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(1.2185) , time:  0.0026140213012695312\niter:  2000 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(1.1540) , time:  0.002638578414916992\niter:  2050 , fixed pt res:  tensor(0.0430) , ls:  1 , rel_err:  tensor(1.0946) , time:  0.002608060836791992\niter:  2100 , fixed pt res:  tensor(0.0458) , ls:  1 , rel_err:  tensor(1.0330) , time:  0.00270843505859375\niter:  2150 , fixed pt res:  tensor(0.0421) , ls:  1 , rel_err:  tensor(0.9753) , time:  0.002655506134033203\niter:  2200 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.9208) , time:  0.002630949020385742\niter:  2250 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.8866) , time:  0.0026464462280273438\niter:  2300 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.8417) , time:  0.0026397705078125\niter:  2350 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.8105) , time:  0.002640962600708008\niter:  2400 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.7749) , time:  0.0026361942291259766\niter:  2450 , fixed pt res:  tensor(0.0456) , ls:  1 , rel_err:  tensor(0.7270) , time:  0.002605915069580078\niter:  2500 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.6931) , time:  0.0027260780334472656\niter:  2550 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.6712) , time:  0.0026073455810546875\niter:  2600 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.6482) , time:  0.0026667118072509766\niter:  2650 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.6209) , time:  0.0026335716247558594\niter:  2700 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.5894) , time:  0.0026459693908691406\niter:  2750 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.5727) , time:  0.0026636123657226562\niter:  2800 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.5474) , time:  0.0026328563690185547\niter:  2850 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.5290) , time:  0.0026111602783203125\niter:  2900 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.5104) , time:  0.002604961395263672\niter:  2950 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.4945) , time:  0.002595186233520508\niter:  3000 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.4735) , time:  0.002607107162475586\niter:  3050 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.4701) , time:  0.0026390552520751953\niter:  3100 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.4575) , time:  0.0027000904083251953\niter:  3150 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.4560) , time:  0.002655506134033203\niter:  3200 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.4378) , time:  0.0026350021362304688\niter:  3250 , fixed pt res:  tensor(0.0468) , ls:  1 , rel_err:  tensor(0.4312) , time:  0.0026488304138183594\niter:  3300 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.4260) , time:  0.002607583999633789\niter:  3350 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.4119) , time:  0.002643585205078125\niter:  3400 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.4009) , time:  0.0026383399963378906\niter:  3450 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.4003) , time:  0.002610921859741211\niter:  3500 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.3972) , time:  0.0026311874389648438\niter:  3550 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.3895) , time:  0.002611398696899414\niter:  3600 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.3673) , time:  0.0025801658630371094\niter:  3650 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.3589) , time:  0.002653837203979492\niter:  3700 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.3513) , time:  0.002604961395263672\niter:  3750 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.3462) , time:  0.00260162353515625\niter:  3800 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.3258) , time:  0.002612590789794922\niter:  3850 , fixed pt res:  tensor(0.0466) , ls:  1 , rel_err:  tensor(0.3177) , time:  0.0026407241821289062\niter:  3900 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.3112) , time:  0.0027043819427490234\niter:  3950 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.3034) , time:  0.0026886463165283203\niter:  4000 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.3008) , time:  0.002656698226928711\niter:  4050 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.2942) , time:  0.0026063919067382812\niter:  4100 , fixed pt res:  tensor(0.0462) , ls:  1 , rel_err:  tensor(0.2901) , time:  0.002576112747192383\niter:  4150 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2870) , time:  0.002616405487060547\niter:  4200 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2925) , time:  0.0025975704193115234\niter:  4250 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2890) , time:  0.002580404281616211\niter:  4300 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2853) , time:  0.0026237964630126953\niter:  4350 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2807) , time:  0.0026149749755859375\niter:  4400 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2652) , time:  0.002762317657470703\niter:  4450 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2658) , time:  0.0026183128356933594\niter:  4500 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2650) , time:  0.0026106834411621094\niter:  4550 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2632) , time:  0.0026085376739501953\niter:  4600 , fixed pt res:  tensor(0.0426) , ls:  1 , rel_err:  tensor(0.2559) , time:  0.002616405487060547\niter:  4650 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2557) , time:  0.0026111602783203125\niter:  4700 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2527) , time:  0.0027801990509033203\niter:  4750 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2439) , time:  0.0026085376739501953\niter:  4800 , fixed pt res:  tensor(0.0438) , ls:  1 , rel_err:  tensor(0.2454) , time:  0.0027692317962646484\niter:  4850 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2379) , time:  0.0026547908782958984\niter:  4900 , fixed pt res:  tensor(0.0420) , ls:  1 , rel_err:  tensor(0.2425) , time:  0.002617359161376953\niter:  4950 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2371) , time:  0.0026412010192871094\niter:  5000 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2339) , time:  0.0026237964630126953\niter:  5050 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2248) , time:  0.0026144981384277344\niter:  5100 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2118) , time:  0.002590179443359375\niter:  5150 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2202) , time:  0.0026094913482666016\niter:  5200 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2171) , time:  0.002602100372314453\niter:  5250 , fixed pt res:  tensor(0.0436) , ls:  1 , rel_err:  tensor(0.2239) , time:  0.0026252269744873047\niter:  5300 , fixed pt res:  tensor(0.0428) , ls:  1 , rel_err:  tensor(0.2304) , time:  0.0026252269744873047\niter:  5350 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2316) , time:  0.0027251243591308594\niter:  5400 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2359) , time:  0.0026140213012695312\niter:  5450 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2331) , time:  0.0025742053985595703\niter:  5500 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.2311) , time:  0.002604246139526367\niter:  5550 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2384) , time:  0.002608060836791992\niter:  5600 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2446) , time:  0.002630949020385742\niter:  5650 , fixed pt res:  tensor(0.0475) , ls:  1 , rel_err:  tensor(0.2419) , time:  0.002635955810546875\niter:  5700 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2349) , time:  0.0026977062225341797\niter:  5750 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2445) , time:  0.0026857852935791016\niter:  5800 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2331) , time:  0.0026388168334960938\niter:  5850 , fixed pt res:  tensor(0.0459) , ls:  1 , rel_err:  tensor(0.2479) , time:  0.0027358531951904297\niter:  5900 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2453) , time:  0.0026693344116210938\niter:  5950 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2445) , time:  0.002724885940551758\niter:  6000 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2450) , time:  0.002702474594116211\niter:  6050 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2435) , time:  0.0026938915252685547\niter:  6100 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2424) , time:  0.002642393112182617\niter:  6150 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2368) , time:  0.002652883529663086\niter:  6200 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2373) , time:  0.002664804458618164\niter:  6250 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2439) , time:  0.0026662349700927734\niter:  6300 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2335) , time:  0.002669095993041992\niter:  6350 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2266) , time:  0.0026252269744873047\niter:  6400 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2422) , time:  0.0026700496673583984\niter:  6450 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2494) , time:  0.002619028091430664\niter:  6500 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2411) , time:  0.002673625946044922\niter:  6550 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2380) , time:  0.0026128292083740234\niter:  6600 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2402) , time:  0.0026497840881347656\niter:  6650 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2401) , time:  0.002610921859741211\niter:  6700 , fixed pt res:  tensor(0.0461) , ls:  1 , rel_err:  tensor(0.2256) , time:  0.0026390552520751953\niter:  6750 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.2239) , time:  0.002607107162475586\niter:  6800 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2263) , time:  0.002607583999633789\niter:  6850 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2380) , time:  0.002641916275024414\niter:  6900 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2354) , time:  0.0027132034301757812\niter:  6950 , fixed pt res:  tensor(0.0434) , ls:  1 , rel_err:  tensor(0.2344) , time:  0.0027217864990234375\niter:  7000 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2373) , time:  0.002673625946044922\niter:  7050 , fixed pt res:  tensor(0.0425) , ls:  1 , rel_err:  tensor(0.2289) , time:  0.002610921859741211\niter:  7100 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2301) , time:  0.002599477767944336\niter:  7150 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2306) , time:  0.002654552459716797\niter:  7200 , fixed pt res:  tensor(0.0465) , ls:  1 , rel_err:  tensor(0.2249) , time:  0.002593994140625\niter:  7250 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2225) , time:  0.0026268959045410156\niter:  7300 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2336) , time:  0.0026633739471435547\niter:  7350 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2387) , time:  0.0026025772094726562\niter:  7400 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2361) , time:  0.0027959346771240234\niter:  7450 , fixed pt res:  tensor(0.0447) , ls:  1 , rel_err:  tensor(0.2402) , time:  0.0026085376739501953\niter:  7500 , fixed pt res:  tensor(0.0437) , ls:  1 , rel_err:  tensor(0.2379) , time:  0.002661466598510742\niter:  7550 , fixed pt res:  tensor(0.0419) , ls:  1 , rel_err:  tensor(0.2360) , time:  0.0026352405548095703\niter:  7600 , fixed pt res:  tensor(0.0429) , ls:  1 , rel_err:  tensor(0.2377) , time:  0.0026412010192871094\niter:  7650 , fixed pt res:  tensor(0.0430) , ls:  1 , rel_err:  tensor(0.2376) , time:  0.00267791748046875\niter:  7700 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2417) , time:  0.0025963783264160156\niter:  7750 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2421) , time:  0.002657651901245117\niter:  7800 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2403) , time:  0.0026264190673828125\niter:  7850 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2342) , time:  0.002609729766845703\niter:  7900 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2360) , time:  0.0026090145111083984\niter:  7950 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2312) , time:  0.002658843994140625\niter:  8000 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2386) , time:  0.0026226043701171875\niter:  8050 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2389) , time:  0.002712249755859375\niter:  8100 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2428) , time:  0.0026378631591796875\niter:  8150 , fixed pt res:  tensor(0.0463) , ls:  1 , rel_err:  tensor(0.2545) , time:  0.0025916099548339844\niter:  8200 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2502) , time:  0.002643585205078125\niter:  8250 , fixed pt res:  tensor(0.0441) , ls:  1 , rel_err:  tensor(0.2474) , time:  0.0025789737701416016\niter:  8300 , fixed pt res:  tensor(0.0450) , ls:  1 , rel_err:  tensor(0.2367) , time:  0.0025835037231445312\niter:  8350 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2376) , time:  0.0025784969329833984\niter:  8400 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2338) , time:  0.0026235580444335938\niter:  8450 , fixed pt res:  tensor(0.0427) , ls:  1 , rel_err:  tensor(0.2361) , time:  0.002642393112182617\niter:  8500 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2343) , time:  0.0026869773864746094\niter:  8550 , fixed pt res:  tensor(0.0440) , ls:  1 , rel_err:  tensor(0.2282) , time:  0.0026705265045166016\niter:  8600 , fixed pt res:  tensor(0.0432) , ls:  1 , rel_err:  tensor(0.2310) , time:  0.002638578414916992\niter:  8650 , fixed pt res:  tensor(0.0433) , ls:  1 , rel_err:  tensor(0.2331) , time:  0.002623319625854492\niter:  8700 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2308) , time:  0.0025844573974609375\niter:  8750 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2349) , time:  0.0025954246520996094\niter:  8800 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2365) , time:  0.002594470977783203\niter:  8850 , fixed pt res:  tensor(0.0460) , ls:  1 , rel_err:  tensor(0.2305) , time:  0.0025708675384521484\niter:  8900 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2322) , time:  0.002640247344970703\niter:  8950 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2321) , time:  0.00260162353515625\niter:  9000 , fixed pt res:  tensor(0.0455) , ls:  1 , rel_err:  tensor(0.2332) , time:  0.002644062042236328\niter:  9050 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2342) , time:  0.002650022506713867\niter:  9100 , fixed pt res:  tensor(0.0431) , ls:  1 , rel_err:  tensor(0.2352) , time:  0.0026323795318603516\niter:  9150 , fixed pt res:  tensor(0.0419) , ls:  1 , rel_err:  tensor(0.2377) , time:  0.0025916099548339844\niter:  9200 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2383) , time:  0.002780437469482422\niter:  9250 , fixed pt res:  tensor(0.0446) , ls:  1 , rel_err:  tensor(0.2482) , time:  0.0026121139526367188\niter:  9300 , fixed pt res:  tensor(0.0454) , ls:  1 , rel_err:  tensor(0.2536) , time:  0.002669095993041992\niter:  9350 , fixed pt res:  tensor(0.0449) , ls:  1 , rel_err:  tensor(0.2583) , time:  0.0026013851165771484\niter:  9400 , fixed pt res:  tensor(0.0443) , ls:  1 , rel_err:  tensor(0.2538) , time:  0.002645730972290039\niter:  9450 , fixed pt res:  tensor(0.0442) , ls:  1 , rel_err:  tensor(0.2458) , time:  0.0026335716247558594\niter:  9500 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2508) , time:  0.0026450157165527344\niter:  9550 , fixed pt res:  tensor(0.0448) , ls:  1 , rel_err:  tensor(0.2519) , time:  0.0026204586029052734\niter:  9600 , fixed pt res:  tensor(0.0453) , ls:  1 , rel_err:  tensor(0.2448) , time:  0.0026938915252685547\niter:  9650 , fixed pt res:  tensor(0.0452) , ls:  1 , rel_err:  tensor(0.2445) , time:  0.002580404281616211\niter:  9700 , fixed pt res:  tensor(0.0435) , ls:  1 , rel_err:  tensor(0.2445) , time:  0.0026569366455078125\niter:  9750 , fixed pt res:  tensor(0.0444) , ls:  1 , rel_err:  tensor(0.2461) , time:  0.0026009082794189453\niter:  9800 , fixed pt res:  tensor(0.0457) , ls:  1 , rel_err:  tensor(0.2492) , time:  0.0026717185974121094\niter:  9850 , fixed pt res:  tensor(0.0439) , ls:  1 , rel_err:  tensor(0.2451) , time:  0.002624034881591797\niter:  9900 , fixed pt res:  tensor(0.0445) , ls:  1 , rel_err:  tensor(0.2470) , time:  0.0027098655700683594\niter:  9950 , fixed pt res:  tensor(0.0451) , ls:  1 , rel_err:  tensor(0.2420) , time:  0.002642393112182617\niter:  10000 , fixed pt res:  tensor(0.0422) , ls:  1 , rel_err:  tensor(0.2330) , time:  0.0026102066040039062\ntrial  1  finished after 27.398865699768066\nnorm(rel_err_hist_temp - rel_err_lmm_hist_sample_array[sample_index,:]) =  tensor(0.)\n</pre> In\u00a0[\u00a0]: Copied! <pre># plotting parameters\ntitle_fontsize = 22\nfontsize       = 20\nfig1 = plt.figure()\nmy_blue = '#1f77b4'\nmy_orange = '#F97306'\n\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.semilogy(rel_err_lmm_hist_sample_array[0,:], '-',linewidth=5, color=my_blue)\nax.semilogy(rel_err_lmm_hist_sample_array[1,:], '-', linewidth=5, color='tab:green')\nax.semilogy(rel_err_lmm_hist_sample_array[2,:], linewidth=5, color='tab:purple')\nax.semilogy(rel_err_lmm_hist_sample_array[3,:], linewidth=5, color='tab:cyan')\nax.semilogy(rel_err_hist_GD, linewidth=5, color='k')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['HJ-MM 1 Sample', 'HJ-MM 100 Samples', 'HJ-MM 1K Samples', 'HJ-MM 10K Samples', 'Gradient Descent'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left')\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'ADMM_noisy_sample_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n\ntitle_str = 'delta =  ' + str(delta_for_varying_samples)\nax.set_title(title_str, fontsize=fontsize)\n</pre> # plotting parameters title_fontsize = 22 fontsize       = 20 fig1 = plt.figure() my_blue = '#1f77b4' my_orange = '#F97306'  fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.semilogy(rel_err_lmm_hist_sample_array[0,:], '-',linewidth=5, color=my_blue) ax.semilogy(rel_err_lmm_hist_sample_array[1,:], '-', linewidth=5, color='tab:green') ax.semilogy(rel_err_lmm_hist_sample_array[2,:], linewidth=5, color='tab:purple') ax.semilogy(rel_err_lmm_hist_sample_array[3,:], linewidth=5, color='tab:cyan') ax.semilogy(rel_err_hist_GD, linewidth=5, color='k')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['HJ-MM 1 Sample', 'HJ-MM 100 Samples', 'HJ-MM 1K Samples', 'HJ-MM 10K Samples', 'Gradient Descent'],fontsize=fontsize, bbox_to_anchor=(1.0, 1.0), loc='upper left') ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'ADMM_noisy_sample_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)  title_str = 'delta =  ' + str(delta_for_varying_samples) ax.set_title(title_str, fontsize=fontsize) <pre>&lt;ipython-input-10-f1d11af914b3&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> Out[\u00a0]: <pre>Text(0.5, 1.0, 'delta =  10')</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre>"},{"location":"exp-oracle-constraints/#ladmm-algorithm-to-obtain-true-solution-of","title":"LADMM Algorithm to obtain true solution of\u00b6","text":"<p>\\begin{equation}          \\min_{x\\in\\mathbb{R}^{1000}} \\; \\|Wx\\|_1         \\quad \\text{such that} \\quad Ax=b \\end{equation}</p> <p>given by</p> <p>\\begin{align}     p^{k+1} &amp; = \\eta_\\lambda \\left(p^k + \\lambda(\\nu_1^k + \\alpha(Wx^k - p^k)) \\right)     \\\\     \\nu_1^{k+1} &amp;= \\nu_1^k + \\alpha(Wx^k - p^{k+1})     \\\\     \\nu_2^{k+1} &amp;= \\nu_2^k + \\alpha(Ax^k -b)      \\\\     r^{k} &amp; =  W^\\top \\left( 2\\nu_1^{k+1} - \\nu_1^k  \\right) + A^\\top \\left( 2\\nu_2^{k+1} - \\nu_2^k \\right)\\\\     x^{k+1} &amp; = x^k - \\beta r^k, \\end{align}</p> <p>where $\\alpha$, $\\beta$, and $\\lambda$ are chosen parameters</p>"},{"location":"exp-oracle-constraints/#find-numerical-true-solution-with-linearized-admm","title":"Find Numerical True Solution with Linearized ADMM.\u00b6","text":"<p>Numerically true solution is obtained by averaging three runs</p>"},{"location":"exp-oracle-constraints/#compute-gradient-descent-solution","title":"Compute Gradient Descent Solution\u00b6","text":"<p>This is to ensure that the proximal operator is not simply the identity</p>"},{"location":"exp-oracle-constraints/#blackbox-oracle-hj-prox-experiment-1-fix-number-of-samples-and-vary-delta","title":"Blackbox Oracle HJ Prox Experiment 1: Fix number of samples and vary $\\delta$\u00b6","text":""},{"location":"exp-oracle-constraints/#plot-varying-delta-results","title":"Plot varying $\\delta$ results\u00b6","text":""},{"location":"exp-oracle-constraints/#blackbox-oracle-hj-prox-experiment-2-fix-best-delta-and-vary-number-of-samples","title":"Blackbox Oracle HJ Prox Experiment 2: Fix best $\\delta$ and vary number of samples\u00b6","text":""},{"location":"exp-prox-comparison/","title":"Approximate Prox (Shrink) and Moreau Envelope for L1 Norm","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\nfrom google.colab import drive\ndrive.mount('/content/drive')\nsys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')\n\nfrom hj_prox import *\nfrom functions import *\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport matplotlib.pyplot as plt\nimport time\n\ntorch.set_default_dtype(torch.float64)\ntorch.manual_seed(0)\ndevice = 'cuda:0'\n</pre> import os import sys from google.colab import drive drive.mount('/content/drive') sys.path.append('/content/drive/MyDrive/Projects/2023-HJ-Prox/src/')  from hj_prox import * from functions import * import numpy as np import torch import torch.nn as nn import matplotlib.pyplot as plt import time  torch.set_default_dtype(torch.float64) torch.manual_seed(0) device = 'cuda:0' <pre>Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n</pre> In\u00a0[2]: Copied! <pre># plotting parameters\ntitle_fontsize = 22\nfontsize       = 20\nfig1 = plt.figure()\nmy_blue = '#1f77b4'\nmy_orange = '#F97306'\n</pre> # plotting parameters title_fontsize = 22 fontsize       = 20 fig1 = plt.figure() my_blue = '#1f77b4' my_orange = '#F97306' <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> In\u00a0[3]: Copied! <pre>f = l1_norm\nanalytic_prox = l1_norm_prox\n\n# create a grid of x's for plotting\nx = torch.linspace(-1,1,100).view(-1,1).to(device)\ny_vals = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\nerrs = torch.zeros(x.shape, device=device)\n\nt = 2e-1\ndelta = 1e-2\nalpha = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e5)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n  envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n\n  errs[i] = f(temp) + (temp - x[i])/t\n\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'l1_norm_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> f = l1_norm analytic_prox = l1_norm_prox  # create a grid of x's for plotting x = torch.linspace(-1,1,100).view(-1,1).to(device) y_vals = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device) errs = torch.zeros(x.shape, device=device)  t = 2e-1 delta = 1e-2 alpha = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e5) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope   envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2    errs[i] = f(temp) + (temp - x[i])/t   # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'l1_norm_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-3-31371be98f0c&gt;:32: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[4]: Copied! <pre>#Generate Files for Howard\nfilename = 'fig2a1_u.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_true):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n\nfilename = 'fig2a1_udelta.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n</pre> #Generate Files for Howard filename = 'fig2a1_u.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_true):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))  filename = 'fig2a1_udelta.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val)) In\u00a0[5]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'l1_norm_prox_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2) ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'l1_norm_prox_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-5-c80673add8e2&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[6]: Copied! <pre>f = l1_norm_noisy\nanalytic_prox = l1_norm_prox\n\n# create a grid of x's for plotting\nx = torch.linspace(-1,1,100).view(-1,1).to(device)\ny_vals = torch.zeros(x.shape, device=device)\ny_vals = f(x)\nprox_true = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_HJ2 = torch.zeros(x.shape, device=device)\n\nt = 0.1\ndelta = 5e-2\ndelta2 = 1e-2\nalpha = 1.0\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nprox_HJ2 = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e4)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)\n  prox_HJ2[i] = temp\n  envelope_HJ2[i] = temp_envelope\n\n# ------------------------ PLOT without noiseless y ------------------------\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g')\nax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)\nax.plot(x.cpu(), envelope_l1_norm(x, t=t).cpu(), 'k', linewidth=3) ###### for save_str = 'eye_candy'\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\n# save_str = 'l1_norm_envelope_noisy.pdf'\nsave_str = 'eye_candy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> f = l1_norm_noisy analytic_prox = l1_norm_prox  # create a grid of x's for plotting x = torch.linspace(-1,1,100).view(-1,1).to(device) y_vals = torch.zeros(x.shape, device=device) y_vals = f(x) prox_true = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_HJ2 = torch.zeros(x.shape, device=device)  t = 0.1 delta = 5e-2 delta2 = 1e-2 alpha = 1.0 prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) prox_HJ2 = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e4) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope  for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)   prox_HJ2[i] = temp   envelope_HJ2[i] = temp_envelope  # ------------------------ PLOT without noiseless y ------------------------ fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g') ax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4) ax.plot(x.cpu(), envelope_l1_norm(x, t=t).cpu(), 'k', linewidth=3) ###### for save_str = 'eye_candy'  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  # save_str = 'l1_norm_envelope_noisy.pdf' save_str = 'eye_candy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-6-14052be998c3&gt;:33: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[7]: Copied! <pre>A = torch.ones(1,1, device=device)\nA = A.view(1,1)\nb = torch.ones(1, device=device)\ndef f(x):\n  return quadratic(x, A, b)\n\ndef analytic_prox(x, t=0.5):\n  return quadratic_prox(x, A, b, t=t)\n\nf = f\n\n# create a grid of x's for plotting\nx = torch.linspace(-2.0,0.5,100, device=device).view(-1,1)\ny_vals = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\n\nt = 5e-1\ndelta = 5e-2\nalpha = 1.0\ny_vals = f(x)\nerrs = torch.zeros(x.shape, device=device)\nprox_true = analytic_prox(x, t=t)\nprox_HJ = torch.zeros(x.shape, device=device)\n\nn_integral_samples = int(1e5)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  errs[i] = f(temp) + (temp - x[i])/t\n  envelope_HJ[i] = temp_envelope\n  envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'quadratic_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> A = torch.ones(1,1, device=device) A = A.view(1,1) b = torch.ones(1, device=device) def f(x):   return quadratic(x, A, b)  def analytic_prox(x, t=0.5):   return quadratic_prox(x, A, b, t=t)  f = f  # create a grid of x's for plotting x = torch.linspace(-2.0,0.5,100, device=device).view(-1,1) y_vals = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device)  t = 5e-1 delta = 5e-2 alpha = 1.0 y_vals = f(x) errs = torch.zeros(x.shape, device=device) prox_true = analytic_prox(x, t=t) prox_HJ = torch.zeros(x.shape, device=device)  n_integral_samples = int(1e5) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   errs[i] = f(temp) + (temp - x[i])/t   envelope_HJ[i] = temp_envelope   envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2  # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'quadratic_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-7-e9418ee90c3a&gt;:36: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[8]: Copied! <pre># Figs for Howard\nfilename = 'fig2a2_udelta.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n</pre> # Figs for Howard filename = 'fig2a2_udelta.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val)) In\u00a0[9]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'quadratic_prox_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2) ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'quadratic_prox_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-9-f213e4ce4ac9&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[10]: Copied! <pre># Figs for Howard\nfilename = 'fig2a2_hjprox.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(prox_HJ):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n</pre> # Figs for Howard filename = 'fig2a2_hjprox.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(prox_HJ):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val)) In\u00a0[11]: Copied! <pre>def f(x):\n  return quadratic_noisy(x, A, b)\n\ny_vals = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\n\nt = 5e-1\ndelta = 5e-2\ndelta2 = 1e-2\nalpha = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nprox_HJ2 = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e4)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)\n  prox_HJ2[i] = temp\n  envelope_HJ2[i] = temp_envelope\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g')\nax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'quadratic_envelope_noisy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> def f(x):   return quadratic_noisy(x, A, b)  y_vals = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device)  t = 5e-1 delta = 5e-2 delta2 = 1e-2 alpha = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) prox_HJ2 = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e4) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope  for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)   prox_HJ2[i] = temp   envelope_HJ2[i] = temp_envelope  # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g') ax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'quadratic_envelope_noisy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-11-754e1ba4d0d8&gt;:31: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[12]: Copied! <pre># Figs for Howard\nfilename = 'fig2d2_noisyf.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(y_vals):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n\n# Figs for Howard\nfilename = 'fig2d2_udelta1.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n\n# Figs for Howard\nfilename = 'fig2d2_udelta2.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ2):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n</pre> # Figs for Howard filename = 'fig2d2_noisyf.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(y_vals):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))  # Figs for Howard filename = 'fig2d2_udelta1.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))  # Figs for Howard filename = 'fig2d2_udelta2.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ2):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val)) In\u00a0[13]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\n# ax.plot(x.cpu(), prox_true.cpu(), linewidth=4)\nax.plot(x.cpu(), prox_HJ.cpu(), linewidth=4, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['HJ Prox from noisy \\n samples'],fontsize=fontsize+2, loc=2)\n# ax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'quadratic_prox_noisy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  # ax.plot(x.cpu(), prox_true.cpu(), linewidth=4) ax.plot(x.cpu(), prox_HJ.cpu(), linewidth=4, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['HJ Prox from noisy \\n samples'],fontsize=fontsize+2, loc=2) # ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'quadratic_prox_noisy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-13-dfba4c3aef84&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[15]: Copied! <pre>f = log_barrier\nanalytic_prox = log_barrier_prox\n\n# create a grid of x's for plotting\nx = torch.linspace(2,10,100).view(-1,1).to(device)\ny_vals = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\nerrs = torch.zeros(x.shape, device=device)\n\nt = 2.0\ndelta = 1e-1\nalpha = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e4)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n  envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n\n  errs[i] = f(temp) + (temp - x[i])/t\n\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'log_barrier_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> f = log_barrier analytic_prox = log_barrier_prox  # create a grid of x's for plotting x = torch.linspace(2,10,100).view(-1,1).to(device) y_vals = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device) errs = torch.zeros(x.shape, device=device)  t = 2.0 delta = 1e-1 alpha = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e4) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope   envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2    errs[i] = f(temp) + (temp - x[i])/t   # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'log_barrier_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-15-a788420ea3cb&gt;:32: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[16]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'log_barrier_prox_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2) ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'log_barrier_prox_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-16-cc2ac5705551&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[17]: Copied! <pre>f = log_barrier_noisy\nanalytic_prox = log_barrier_prox\n\n# create a grid of x's for plotting\ny_vals = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\n\nt = 2.0\ndelta = 5e-2\ndelta2 = 1e-2\nalpha = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nprox_HJ2 = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e4)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)\n  prox_HJ2[i] = temp\n  envelope_HJ2[i] = temp_envelope\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g')\nax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=1)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'log_barrier_envelope_noisy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> f = log_barrier_noisy analytic_prox = log_barrier_prox  # create a grid of x's for plotting y_vals = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device)  t = 2.0 delta = 5e-2 delta2 = 1e-2 alpha = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) prox_HJ2 = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e4) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope  for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)   prox_HJ2[i] = temp   envelope_HJ2[i] = temp_envelope  # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g') ax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=1) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'log_barrier_envelope_noisy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-17-65d0accfa9cf&gt;:32: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[18]: Copied! <pre># Figs for Howard\nfilename = 'fig2d3_noisyf.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(y_vals):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n\n# Figs for Howard\nfilename = 'fig2d3_udelta1.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n\n# Figs for Howard\nfilename = 'fig2d3_udelta2.dat'\nwith open(filename, 'w') as csv_file:\n  for idx, f_val in enumerate(envelope_HJ2):\n    csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))\n</pre> # Figs for Howard filename = 'fig2d3_noisyf.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(y_vals):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))  # Figs for Howard filename = 'fig2d3_udelta1.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val))  # Figs for Howard filename = 'fig2d3_udelta2.dat' with open(filename, 'w') as csv_file:   for idx, f_val in enumerate(envelope_HJ2):     csv_file.write('%0.5e %0.5e\\n' % (x[idx], f_val)) In\u00a0[19]: Copied! <pre>def f(x):\n  return -torch.norm(x, p=1, dim=1)\n\n# create a grid of x's for plotting\nx = torch.linspace(-1.0,1.0,100, device=device).view(-1,1)\ny_vals = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\n\nt = 1e-1\ndelta = 1e-2\nalpha = 1.0\ny_vals = f(x)\nerrs = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nprox_HJ = torch.zeros(x.shape, device=device)\n\nn_integral_samples = int(1e5)\nfor i in range(x.shape[0]):\n  # print('f(x[i].view(1,1)) = ', f(x[i].view(1,1)))\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  errs[i] = f(temp) + (temp - x[i])/t\n  envelope_HJ[i] = temp_envelope\n  # envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n  envelope_true[i] = -torch.norm(x[i].view(1,1), p=1, dim=1) - t/2\n  # prox_true[i] = \n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize+2, loc=8)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'nonconvex1_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> def f(x):   return -torch.norm(x, p=1, dim=1)  # create a grid of x's for plotting x = torch.linspace(-1.0,1.0,100, device=device).view(-1,1) y_vals = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device)  t = 1e-1 delta = 1e-2 alpha = 1.0 y_vals = f(x) errs = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) prox_HJ = torch.zeros(x.shape, device=device)  n_integral_samples = int(1e5) for i in range(x.shape[0]):   # print('f(x[i].view(1,1)) = ', f(x[i].view(1,1)))   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   errs[i] = f(temp) + (temp - x[i])/t   envelope_HJ[i] = temp_envelope   # envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2   envelope_true[i] = -torch.norm(x[i].view(1,1), p=1, dim=1) - t/2   # prox_true[i] =   # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize+2, loc=8) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'nonconvex1_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-19-e38f0bd84404&gt;:31: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[20]: Copied! <pre>def f(x, a=1):\n  return -(a/2)* torch.norm(x, p=2, dim=1)**2\n\nf = f\n\n# create a grid of x's for plotting\nx = torch.linspace(-1.0,1.0,100, device=device).view(-1,1)\ny_vals = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\n\nt = 2e-1\ndelta = 1e-2\nalpha = 1.0\na = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nerrs = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nprox_HJ = torch.zeros(x.shape, device=device)\n\nn_integral_samples = int(1e5)\nfor i in range(x.shape[0]):\n  # print('f(x[i].view(1,1)) = ', f(x[i].view(1,1)))\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  errs[i] = f(temp) + (temp - x[i])/t\n  envelope_HJ[i] = temp_envelope\n  # envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n  envelope_true[i] = -(a/(2*(1-a*t)))* torch.norm(x[i].view(1,1), p=2, dim=1)**2\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize+2, loc=8)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'nonconvex2_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> def f(x, a=1):   return -(a/2)* torch.norm(x, p=2, dim=1)**2  f = f  # create a grid of x's for plotting x = torch.linspace(-1.0,1.0,100, device=device).view(-1,1) y_vals = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device)  t = 2e-1 delta = 1e-2 alpha = 1.0 a = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) errs = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) prox_HJ = torch.zeros(x.shape, device=device)  n_integral_samples = int(1e5) for i in range(x.shape[0]):   # print('f(x[i].view(1,1)) = ', f(x[i].view(1,1)))   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   errs[i] = f(temp) + (temp - x[i])/t   envelope_HJ[i] = temp_envelope   # envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2   envelope_true[i] = -(a/(2*(1-a*t)))* torch.norm(x[i].view(1,1), p=2, dim=1)**2 # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize+2, loc=8) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'nonconvex2_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-20-7c5ebcd98e9d&gt;:33: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[21]: Copied! <pre>def proximal_objective(z, x):\n  # assumes only one sample\n  return torch.norm(z)**2 - torch.sum(torch.log(z)) + (1/(2*t)) * torch.norm(z - x)**2\n\ndef proximal_objective_gradient(z, x):\n  return 2*z - (1/z) + (1/t)*(z-x)\n</pre> def proximal_objective(z, x):   # assumes only one sample   return torch.norm(z)**2 - torch.sum(torch.log(z)) + (1/(2*t)) * torch.norm(z - x)**2  def proximal_objective_gradient(z, x):   return 2*z - (1/z) + (1/t)*(z-x) In\u00a0[22]: Copied! <pre>def steepest_descent(x, f, grad_f, max_iters=1000, tol=1e-2, step_size = 1e-1, verbose=True):\n  # assumes only one sample\n  xk = x\n  fk = f(xk)\n  grad_fk = grad_f(xk)\n  norm_grad0 = torch.norm(grad_fk)\n\n  print('iter = 0', ', fk = ', fk, '|grad_fk| = ', 1)\n\n  for i in range(max_iters):\n    xk = xk - step_size*grad_fk\n\n    rel_grad_norm = torch.norm(grad_fk)/norm_grad0\n    if verbose:\n      print('iter = ', i+1, ', fk = ', ', |grad_fk| = ', rel_grad_norm)\n\n    fk = f(xk)\n    grad_fk = grad_f(xk)\n\n    if rel_grad_norm &lt; tol:\n      print('SD converged in ', i, ' iterations')\n      break\n\n  return xk\n\ndef evaluate_proximal(x):\n  def func(z):\n    return proximal_objective(z,x)\n  def grad_func(z):\n    return proximal_objective_gradient(z,x)\n\n  prox_val = steepest_descent(x, func, grad_func)\n\n  return prox_val\n</pre> def steepest_descent(x, f, grad_f, max_iters=1000, tol=1e-2, step_size = 1e-1, verbose=True):   # assumes only one sample   xk = x   fk = f(xk)   grad_fk = grad_f(xk)   norm_grad0 = torch.norm(grad_fk)    print('iter = 0', ', fk = ', fk, '|grad_fk| = ', 1)    for i in range(max_iters):     xk = xk - step_size*grad_fk      rel_grad_norm = torch.norm(grad_fk)/norm_grad0     if verbose:       print('iter = ', i+1, ', fk = ', ', |grad_fk| = ', rel_grad_norm)      fk = f(xk)     grad_fk = grad_f(xk)      if rel_grad_norm &lt; tol:       print('SD converged in ', i, ' iterations')       break    return xk  def evaluate_proximal(x):   def func(z):     return proximal_objective(z,x)   def grad_func(z):     return proximal_objective_gradient(z,x)    prox_val = steepest_descent(x, func, grad_func)    return prox_val In\u00a0[23]: Copied! <pre>def f(x):\n  return torch.norm(x, dim=1)**2 - torch.sum(torch.log(x), dim=1)\n# create a grid of x's for plotting\n\nx = torch.linspace(1,3,100).view(-1,1).to(device)\ny_vals = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\nerrs = torch.zeros(x.shape, device=device)\n\nt = 0.1\ndelta = 1e-1\nalpha = 1.0\ny_vals = f(x)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e5)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n  prox_true[i] = evaluate_proximal(x[i])\n  envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2\n\n  errs[i] = f(temp) + (temp - x[i])/t\n\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'non_analytic_convex_envelope.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> def f(x):   return torch.norm(x, dim=1)**2 - torch.sum(torch.log(x), dim=1) # create a grid of x's for plotting  x = torch.linspace(1,3,100).view(-1,1).to(device) y_vals = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device) errs = torch.zeros(x.shape, device=device)  t = 0.1 delta = 1e-1 alpha = 1.0 y_vals = f(x)  prox_HJ = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e5) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope   prox_true[i] = evaluate_proximal(x[i])   envelope_true[i] = f(prox_true[i].view(1,1)) + (1/(2*t))*torch.norm(prox_true[i] - x[i], p=2)**2    errs[i] = f(temp) + (temp - x[i])/t   # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), envelope_HJ.cpu(), '--g', linewidth=3)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['$f$', 'u', '$u^\\delta$'],fontsize=fontsize, loc=9) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'non_analytic_convex_envelope.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>iter = 0 , fk =  tensor(1., device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.3111, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0993, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0315, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0100, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.0208, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.3072, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0969, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0303, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0095, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.0428, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.3035, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0947, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0293, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0091, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.0660, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.3000, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0925, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0283, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0087, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.0904, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2967, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0905, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0274, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0083, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.1160, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2935, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0886, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0265, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0080, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.1427, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2904, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0868, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0257, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0076, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.1706, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2875, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0851, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0250, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0073, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.1995, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2848, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0835, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0243, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0071, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.2296, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2821, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0820, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0236, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0068, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.2608, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2796, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0805, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0230, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0066, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.2932, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2772, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0791, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0224, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0063, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.3266, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2749, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0778, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0218, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0061, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.3610, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2727, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0766, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0213, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0059, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.3966, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2706, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0754, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0208, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0058, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.4332, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2686, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0743, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0204, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0056, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.4709, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2666, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0732, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0199, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0054, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.5096, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2648, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0721, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0195, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0053, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.5493, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2630, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0712, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0191, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0051, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.5901, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2613, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0702, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0187, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0050, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.6320, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2596, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0693, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0184, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0049, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.6748, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2580, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0685, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0180, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0048, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.7187, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2565, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0677, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0177, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0046, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.7636, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2551, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0669, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0174, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0045, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.8095, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2537, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0661, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0171, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0044, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.8564, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2523, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0654, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0168, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0043, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.9042, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2510, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0647, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0166, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0042, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(1.9531, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2497, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0640, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0163, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0042, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.0030, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2485, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0634, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0161, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0041, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.0538, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2473, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0628, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0158, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0040, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.1056, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2462, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0622, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0156, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0039, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.1584, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2451, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0616, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0154, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0038, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.2122, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2441, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0611, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0152, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0038, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.2670, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2431, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0606, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0150, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0037, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.3227, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2421, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0601, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0148, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0037, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.3793, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2411, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0596, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0146, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0036, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.4369, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2402, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0591, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0144, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0035, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.4955, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2393, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0586, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0143, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0035, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.5550, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2385, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0582, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0141, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0034, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.6155, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2376, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0578, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0140, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0034, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.6769, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2368, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0574, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0138, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0033, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.7392, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2360, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0570, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0137, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0033, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.8025, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2353, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0566, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0135, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0032, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.8668, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2346, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0562, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0134, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0032, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.9319, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2338, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0559, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0133, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0032, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(2.9980, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2332, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0555, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0132, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0031, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.0650, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2325, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0552, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0130, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0031, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.1330, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2318, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0549, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0129, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0030, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.2018, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2312, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0546, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0128, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0030, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.2716, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2306, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0543, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0127, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0030, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.3423, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2300, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0540, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0126, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0029, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.4139, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2294, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0537, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0125, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0029, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.4865, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2289, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0534, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0124, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0029, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.5599, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2283, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0532, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0123, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0029, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.6343, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2278, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0529, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0122, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0028, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.7096, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2273, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0526, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0121, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0028, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.7858, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2268, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0524, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0120, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0028, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.8628, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2263, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0522, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0120, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0027, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(3.9408, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2258, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0519, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0119, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0027, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.0197, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2254, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0517, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0118, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0027, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.0995, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2249, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0515, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0117, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0027, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.1802, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2245, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0513, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0117, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0027, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.2618, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2240, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0511, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0116, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0026, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.3443, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2236, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0509, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0115, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0026, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.4277, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2232, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0507, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0115, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0026, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.5120, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2228, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0505, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0114, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0026, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.5971, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2224, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0503, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0113, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0026, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.6832, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2221, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0501, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0113, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0025, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.7702, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2217, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0499, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0112, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0025, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.8580, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2213, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0498, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0111, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0025, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(4.9467, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2210, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0496, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0111, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0025, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.0364, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2207, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0494, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0110, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0025, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.1269, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2203, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0493, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0110, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.2182, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2200, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0491, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0109, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.3105, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2197, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0490, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0109, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.4037, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2194, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0488, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0108, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.4977, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2191, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0487, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0108, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.5926, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2188, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0486, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0107, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.6884, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2185, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0484, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0107, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0024, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.7850, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2182, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0483, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0106, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.8826, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2179, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0482, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0106, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(5.9810, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2177, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0480, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0106, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.0803, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2174, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0479, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0105, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.1805, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2171, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0478, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0105, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.2815, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2169, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0477, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0104, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.3834, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2166, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0476, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0104, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.4862, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2164, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0474, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0104, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.5899, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2162, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0473, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0103, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0023, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.6944, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2159, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0472, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0103, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.7998, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2157, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0471, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0103, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(6.9061, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2155, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0470, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0102, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.0132, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2153, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0469, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0102, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.1212, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2151, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0468, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0102, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.2301, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2149, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0467, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0101, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.3398, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2147, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0466, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0101, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.4504, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2145, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0465, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0101, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.5618, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2143, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0464, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0100, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.6742, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2141, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0464, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0100, device='cuda:0')\niter =  5 , fk =  , |grad_fk| =  tensor(0.0022, device='cuda:0')\nSD converged in  4  iterations\niter = 0 , fk =  tensor(7.7873, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2139, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0463, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0100, device='cuda:0')\nSD converged in  3  iterations\niter = 0 , fk =  tensor(7.9014, device='cuda:0') |grad_fk| =  1\niter =  1 , fk =  , |grad_fk| =  tensor(1., device='cuda:0')\niter =  2 , fk =  , |grad_fk| =  tensor(0.2137, device='cuda:0')\niter =  3 , fk =  , |grad_fk| =  tensor(0.0462, device='cuda:0')\niter =  4 , fk =  , |grad_fk| =  tensor(0.0100, device='cuda:0')\nSD converged in  3  iterations\n</pre> <pre>&lt;ipython-input-23-c7672a6b1f1e&gt;:31: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[25]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\nax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange)\nax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'non_analytic_convex_prox_comparison.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  ax.plot(x.cpu(), prox_true.cpu(), linewidth=3, color=my_orange) ax.plot(x.cpu(), prox_HJ.cpu(), '--', linewidth=3, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['True Prox', 'HJ Prox'],fontsize=fontsize, loc=2) ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'non_analytic_convex_prox_comparison.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-25-749aff71ffe3&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[26]: Copied! <pre>def f_noisy(x):\n  return torch.norm(x, dim=1)**2 - torch.sum(torch.log(x), dim=1) + 5e-1*torch.randn(x.shape[0], device=x.device)\n\nf = f_noisy\n\ny_vals = torch.zeros(x.shape, device=device)\nprox_true = torch.zeros(x.shape, device=device)\nenvelope_HJ = torch.zeros(x.shape, device=device)\nenvelope_true = torch.zeros(x.shape, device=device)\nerrs = torch.zeros(x.shape, device=device)\n\nt = 1e-1\ndelta = 5e-1\ndelta2 = 1e-1\nalpha = 1.0\n# y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device)\ny_vals = f(x)\nprox_true = analytic_prox(x, t=t)\n\nprox_HJ = torch.zeros(prox_true.shape, device=device)\nprox_HJ2 = torch.zeros(prox_true.shape, device=device)\nn_integral_samples = int(1e4)\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)\n  prox_HJ[i] = temp\n  envelope_HJ[i] = temp_envelope\n\nfor i in range(x.shape[0]):\n  temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)\n  prox_HJ2[i] = temp\n  envelope_HJ2[i] = temp_envelope\n\n# PLOT\nfig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nax.plot(x.cpu(), y_vals.cpu(), linewidth=3);\nax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g')\nax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=2)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'non_analytic_convex_envelope_noisy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> def f_noisy(x):   return torch.norm(x, dim=1)**2 - torch.sum(torch.log(x), dim=1) + 5e-1*torch.randn(x.shape[0], device=x.device)  f = f_noisy  y_vals = torch.zeros(x.shape, device=device) prox_true = torch.zeros(x.shape, device=device) envelope_HJ = torch.zeros(x.shape, device=device) envelope_true = torch.zeros(x.shape, device=device) errs = torch.zeros(x.shape, device=device)  t = 1e-1 delta = 5e-1 delta2 = 1e-1 alpha = 1.0 # y_vals = l1_norm(x) + 0.1*torch.randn(x.shape[0], device=device) y_vals = f(x) prox_true = analytic_prox(x, t=t)  prox_HJ = torch.zeros(prox_true.shape, device=device) prox_HJ2 = torch.zeros(prox_true.shape, device=device) n_integral_samples = int(1e4) for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta, alpha=alpha, device=device)   prox_HJ[i] = temp   envelope_HJ[i] = temp_envelope  for i in range(x.shape[0]):   temp, ls_iters, temp_envelope = compute_prox(x[i].view(1,1), t, f, int_samples = n_integral_samples, delta = delta2, alpha=alpha, device=device)   prox_HJ2[i] = temp   envelope_HJ2[i] = temp_envelope  # PLOT fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes() ax.plot(x.cpu(), y_vals.cpu(), linewidth=3); ax.plot(x.cpu(), envelope_HJ.cpu(), linewidth=4, color='g') ax.plot(x.cpu(), envelope_HJ2.cpu(), linewidth=4)  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['noisy $f$', '$u^{\\delta_1}$', '$u^{\\delta_2}$'],fontsize=fontsize, loc=2) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'non_analytic_convex_envelope_noisy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-26-26e0534142f9&gt;:35: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[27]: Copied! <pre>fig1 = plt.figure()\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\n\n# ax.plot(x.cpu(), prox_true.cpu(), linewidth=4)\nax.plot(x.cpu(), prox_HJ.cpu(), linewidth=4, color='g')\n\n# ax.set_xlabel(\"x-axis\", fontsize=title_fontsize)\nax.legend(['HJ Prox from noisy \\n samples'],fontsize=fontsize+2, loc=2)\n# ax.tick_params(labelsize=fontsize, which='both', direction='in')\nsave_str = 'non_analytic_convex_prox_noisy.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> fig1 = plt.figure() plt.style.use('seaborn-whitegrid') ax = plt.axes()  # ax.plot(x.cpu(), prox_true.cpu(), linewidth=4) ax.plot(x.cpu(), prox_HJ.cpu(), linewidth=4, color='g')  # ax.set_xlabel(\"x-axis\", fontsize=title_fontsize) ax.legend(['HJ Prox from noisy \\n samples'],fontsize=fontsize+2, loc=2) # ax.tick_params(labelsize=fontsize, which='both', direction='in') save_str = 'non_analytic_convex_prox_noisy.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-27-29a46d037b0c&gt;:2: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[29]: Copied! <pre>f = l1_norm\nanalytic_prox = l1_norm_prox\n\ndim_array = [10, 25, 50, 75, 100]\nn_samples = int(1000)\nn_integral_samples_array = [int(1e1), int(1e3), int(1e4), int(1e5)]\nrel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array))\ntorch.manual_seed(2)\ndelta = 1e-1\nt = 1e-2\n\nfor k in range(len(dim_array)):\n  print('\\n DIMENSION = ', dim_array[k])\n  for i in range(len(n_integral_samples_array)):\n    x = torch.randn(n_samples, dim_array[k], device=device)\n    prox_true = analytic_prox(x, t=t) \n    for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time\n      # print('x[j,:].unsqueeze(1).shape = ', x[j,:].unsqueeze(1).shape)\n      prox_HJ, ls_iters, temp_envelope = compute_prox(x[j,:].unsqueeze(1), t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)\n      # NOTE: need to permute prox_HJ back to n_samples x dim\n      # print('prox_true[j,:].shape = ', prox_true[j,:].shape)\n      # print('prox_HJ.squeeze(1)shape = ', prox_HJ.squeeze(1).shape)\n      rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true[j,:].cpu() - prox_HJ.squeeze(1).cpu())/torch.norm(prox_true[j,:].cpu()) \n\n    rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples\n    print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters)\n</pre> f = l1_norm analytic_prox = l1_norm_prox  dim_array = [10, 25, 50, 75, 100] n_samples = int(1000) n_integral_samples_array = [int(1e1), int(1e3), int(1e4), int(1e5)] rel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array)) torch.manual_seed(2) delta = 1e-1 t = 1e-2  for k in range(len(dim_array)):   print('\\n DIMENSION = ', dim_array[k])   for i in range(len(n_integral_samples_array)):     x = torch.randn(n_samples, dim_array[k], device=device)     prox_true = analytic_prox(x, t=t)      for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time       # print('x[j,:].unsqueeze(1).shape = ', x[j,:].unsqueeze(1).shape)       prox_HJ, ls_iters, temp_envelope = compute_prox(x[j,:].unsqueeze(1), t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)       # NOTE: need to permute prox_HJ back to n_samples x dim       # print('prox_true[j,:].shape = ', prox_true[j,:].shape)       # print('prox_HJ.squeeze(1)shape = ', prox_HJ.squeeze(1).shape)       rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true[j,:].cpu() - prox_HJ.squeeze(1).cpu())/torch.norm(prox_true[j,:].cpu())       rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples     print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters) <pre>\n DIMENSION =  10\ndim =  10 , n_integral_samples =  10 , rel err =  tensor(0.0153) , ls_iters =  1\ndim =  10 , n_integral_samples =  1000 , rel err =  tensor(0.0021) , ls_iters =  1\ndim =  10 , n_integral_samples =  10000 , rel err =  tensor(0.0010) , ls_iters =  1\ndim =  10 , n_integral_samples =  100000 , rel err =  tensor(0.0007) , ls_iters =  1\n\n DIMENSION =  25\ndim =  25 , n_integral_samples =  10 , rel err =  tensor(0.0181) , ls_iters =  1\ndim =  25 , n_integral_samples =  1000 , rel err =  tensor(0.0034) , ls_iters =  1\ndim =  25 , n_integral_samples =  10000 , rel err =  tensor(0.0014) , ls_iters =  1\ndim =  25 , n_integral_samples =  100000 , rel err =  tensor(0.0009) , ls_iters =  1\n\n DIMENSION =  50\ndim =  50 , n_integral_samples =  10 , rel err =  tensor(0.0209) , ls_iters =  1\ndim =  50 , n_integral_samples =  1000 , rel err =  tensor(0.0064) , ls_iters =  1\ndim =  50 , n_integral_samples =  10000 , rel err =  tensor(0.0029) , ls_iters =  1\ndim =  50 , n_integral_samples =  100000 , rel err =  tensor(0.0014) , ls_iters =  1\n\n DIMENSION =  75\ndim =  75 , n_integral_samples =  10 , rel err =  tensor(0.0224) , ls_iters =  1\ndim =  75 , n_integral_samples =  1000 , rel err =  tensor(0.0091) , ls_iters =  1\ndim =  75 , n_integral_samples =  10000 , rel err =  tensor(0.0049) , ls_iters =  1\ndim =  75 , n_integral_samples =  100000 , rel err =  tensor(0.0025) , ls_iters =  1\n\n DIMENSION =  100\ndim =  100 , n_integral_samples =  10 , rel err =  tensor(0.0241) , ls_iters =  1\ndim =  100 , n_integral_samples =  1000 , rel err =  tensor(0.0116) , ls_iters =  1\ndim =  100 , n_integral_samples =  10000 , rel err =  tensor(0.0073) , ls_iters =  1\ndim =  100 , n_integral_samples =  100000 , rel err =  tensor(0.0040) , ls_iters =  1\n</pre> In\u00a0[30]: Copied! <pre>title_fontsize = 22\nfontsize       = 18\nfig1 = plt.figure()\n\ntitle_fontsize = 22\nfontsize       = 15\nmy_blue = '#1f77b4'\n\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nfor i in range(len(dim_array)):\n  ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);\n\nax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize)\nax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'shrink_higher_dim_err_vs_samples.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> title_fontsize = 22 fontsize       = 18 fig1 = plt.figure()  title_fontsize = 22 fontsize       = 15 my_blue = '#1f77b4'  plt.style.use('seaborn-whitegrid') ax = plt.axes() for i in range(len(dim_array)):   ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);  ax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize) ax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'shrink_higher_dim_err_vs_samples.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-30-e40ab8e14fd5&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[31]: Copied! <pre>dim_array = [10, 25, 50, 75, 100]\nn_samples = 1000\nn_integral_samples_array = [int(1e0), int(1e2), int(1e3), int(1e4)]\nrel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array))\ntorch.manual_seed(2)\ndelta = 1e-1\nt = 1e-2\n\n\nfor k in range(len(dim_array)):\n  print('\\n DIMENSION = ', dim_array[k])\n  for i in range(len(n_integral_samples_array)):\n    for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time\n      A = torch.eye(dim_array[k], device=device)\n      # A = torch.randn(dim_array[k], dim_array[k], device=device)\n      # A = A + A.t() + torch.eye(dim_array[k], device=device)\n      b = torch.ones(A.shape[0], device=device)\n      def f(x):\n        return quadratic(x, A, b)\n\n      def analytic_prox(x, t=0.5):\n        return quadratic_prox(x, A, b, t=t)\n      f = f\n      x = torch.randn(dim_array[k],1, device=device)\n      prox_true = analytic_prox(x.permute(1,0), t=t)\n      prox_HJ, ls_iters, envelopes = compute_prox(x, t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)\n      # NOTE: need to permute prox_HJ back to n_samples x dim\n      rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true.cpu() - prox_HJ.permute(1,0).cpu())/torch.norm(prox_true.cpu())  \n\n    rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples\n    print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters)\n</pre> dim_array = [10, 25, 50, 75, 100] n_samples = 1000 n_integral_samples_array = [int(1e0), int(1e2), int(1e3), int(1e4)] rel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array)) torch.manual_seed(2) delta = 1e-1 t = 1e-2   for k in range(len(dim_array)):   print('\\n DIMENSION = ', dim_array[k])   for i in range(len(n_integral_samples_array)):     for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time       A = torch.eye(dim_array[k], device=device)       # A = torch.randn(dim_array[k], dim_array[k], device=device)       # A = A + A.t() + torch.eye(dim_array[k], device=device)       b = torch.ones(A.shape[0], device=device)       def f(x):         return quadratic(x, A, b)        def analytic_prox(x, t=0.5):         return quadratic_prox(x, A, b, t=t)       f = f       x = torch.randn(dim_array[k],1, device=device)       prox_true = analytic_prox(x.permute(1,0), t=t)       prox_HJ, ls_iters, envelopes = compute_prox(x, t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)       # NOTE: need to permute prox_HJ back to n_samples x dim       rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true.cpu() - prox_HJ.permute(1,0).cpu())/torch.norm(prox_true.cpu())        rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples     print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters) <pre>\n DIMENSION =  10\ndim =  10 , n_integral_samples =  1 , rel err =  tensor(0.0367) , ls_iters =  1\ndim =  10 , n_integral_samples =  100 , rel err =  tensor(0.0076) , ls_iters =  1\ndim =  10 , n_integral_samples =  1000 , rel err =  tensor(0.0029) , ls_iters =  1\ndim =  10 , n_integral_samples =  10000 , rel err =  tensor(0.0010) , ls_iters =  1\n\n DIMENSION =  25\ndim =  25 , n_integral_samples =  1 , rel err =  tensor(0.0358) , ls_iters =  1\ndim =  25 , n_integral_samples =  100 , rel err =  tensor(0.0125) , ls_iters =  1\ndim =  25 , n_integral_samples =  1000 , rel err =  tensor(0.0063) , ls_iters =  1\ndim =  25 , n_integral_samples =  10000 , rel err =  tensor(0.0028) , ls_iters =  1\n\n DIMENSION =  50\ndim =  50 , n_integral_samples =  1 , rel err =  tensor(0.0352) , ls_iters =  1\ndim =  50 , n_integral_samples =  100 , rel err =  tensor(0.0174) , ls_iters =  1\ndim =  50 , n_integral_samples =  1000 , rel err =  tensor(0.0119) , ls_iters =  1\ndim =  50 , n_integral_samples =  10000 , rel err =  tensor(0.0073) , ls_iters =  1\n\n DIMENSION =  75\ndim =  75 , n_integral_samples =  1 , rel err =  tensor(0.0352) , ls_iters =  1\ndim =  75 , n_integral_samples =  100 , rel err =  tensor(0.0206) , ls_iters =  1\ndim =  75 , n_integral_samples =  1000 , rel err =  tensor(0.0158) , ls_iters =  1\ndim =  75 , n_integral_samples =  10000 , rel err =  tensor(0.0109) , ls_iters =  1\n\n DIMENSION =  100\ndim =  100 , n_integral_samples =  1 , rel err =  tensor(0.0350) , ls_iters =  1\ndim =  100 , n_integral_samples =  100 , rel err =  tensor(0.0222) , ls_iters =  1\ndim =  100 , n_integral_samples =  1000 , rel err =  tensor(0.0179) , ls_iters =  1\ndim =  100 , n_integral_samples =  10000 , rel err =  tensor(0.0140) , ls_iters =  1\n</pre> In\u00a0[32]: Copied! <pre>title_fontsize = 22\nfontsize       = 18\nfig1 = plt.figure()\n\ntitle_fontsize = 22\nfontsize       = 15\nmy_blue = '#1f77b4'\n\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nfor i in range(len(dim_array)):\n  ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);\n\nax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize)\nax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'quadratic_higher_dim_err_vs_samples.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> title_fontsize = 22 fontsize       = 18 fig1 = plt.figure()  title_fontsize = 22 fontsize       = 15 my_blue = '#1f77b4'  plt.style.use('seaborn-whitegrid') ax = plt.axes() for i in range(len(dim_array)):   ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);  ax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize) ax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'quadratic_higher_dim_err_vs_samples.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-32-ff10d27841a8&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[33]: Copied! <pre>f = log_barrier\nanalytic_prox = log_barrier_prox\n\ndim_array = [10, 25, 50, 75, 100]\nn_samples = 1000\nn_integral_samples_array = [int(1e0), int(1e2), int(1e3), int(1e4)]\nrel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array))\ntorch.manual_seed(2)\ndelta = 2e-1\nt = 1e-2\n\n\nfor k in range(len(dim_array)):\n  print('\\n DIMENSION = ', dim_array[k])\n  for i in range(len(n_integral_samples_array)):\n    for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time\n      x = torch.rand(dim_array[k],1, device=device) + 2\n      prox_true = analytic_prox(x.permute(1,0), t=t)\n      prox_HJ, ls_iters, envelopes = compute_prox(x, t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)\n      # NOTE: need to permute prox_HJ back to n_samples x dim\n      rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true.cpu() - prox_HJ.permute(1,0).cpu())/torch.norm(prox_true.cpu())  \n\n    rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples\n    print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters)\n</pre> f = log_barrier analytic_prox = log_barrier_prox  dim_array = [10, 25, 50, 75, 100] n_samples = 1000 n_integral_samples_array = [int(1e0), int(1e2), int(1e3), int(1e4)] rel_errs_array = torch.zeros(len(dim_array), len(n_integral_samples_array)) torch.manual_seed(2) delta = 2e-1 t = 1e-2   for k in range(len(dim_array)):   print('\\n DIMENSION = ', dim_array[k])   for i in range(len(n_integral_samples_array)):     for j in range(n_samples): # need to loop over samples since HJ prox can only handle one sample at a time       x = torch.rand(dim_array[k],1, device=device) + 2       prox_true = analytic_prox(x.permute(1,0), t=t)       prox_HJ, ls_iters, envelopes = compute_prox(x, t, f, int_samples = n_integral_samples_array[i], delta = delta, alpha=alpha, device=device)       # NOTE: need to permute prox_HJ back to n_samples x dim       rel_errs_array[k, i] = rel_errs_array[k, i] + torch.norm(prox_true.cpu() - prox_HJ.permute(1,0).cpu())/torch.norm(prox_true.cpu())        rel_errs_array[k, i] = rel_errs_array[k, i]/n_samples     print('dim = ', dim_array[k], ', n_integral_samples = ', n_integral_samples_array[i], ', rel err = ', rel_errs_array[k, i], ', ls_iters = ', ls_iters) <pre>\n DIMENSION =  10\ndim =  10 , n_integral_samples =  1 , rel err =  tensor(0.0173) , ls_iters =  1\ndim =  10 , n_integral_samples =  100 , rel err =  tensor(0.0018) , ls_iters =  1\ndim =  10 , n_integral_samples =  1000 , rel err =  tensor(0.0006) , ls_iters =  1\ndim =  10 , n_integral_samples =  10000 , rel err =  tensor(0.0002) , ls_iters =  1\n\n DIMENSION =  25\ndim =  25 , n_integral_samples =  1 , rel err =  tensor(0.0176) , ls_iters =  1\ndim =  25 , n_integral_samples =  100 , rel err =  tensor(0.0019) , ls_iters =  1\ndim =  25 , n_integral_samples =  1000 , rel err =  tensor(0.0006) , ls_iters =  1\ndim =  25 , n_integral_samples =  10000 , rel err =  tensor(0.0002) , ls_iters =  1\n\n DIMENSION =  50\ndim =  50 , n_integral_samples =  1 , rel err =  tensor(0.0177) , ls_iters =  1\ndim =  50 , n_integral_samples =  100 , rel err =  tensor(0.0022) , ls_iters =  1\ndim =  50 , n_integral_samples =  1000 , rel err =  tensor(0.0007) , ls_iters =  1\ndim =  50 , n_integral_samples =  10000 , rel err =  tensor(0.0002) , ls_iters =  1\n\n DIMENSION =  75\ndim =  75 , n_integral_samples =  1 , rel err =  tensor(0.0177) , ls_iters =  1\ndim =  75 , n_integral_samples =  100 , rel err =  tensor(0.0024) , ls_iters =  1\ndim =  75 , n_integral_samples =  1000 , rel err =  tensor(0.0008) , ls_iters =  1\ndim =  75 , n_integral_samples =  10000 , rel err =  tensor(0.0002) , ls_iters =  1\n\n DIMENSION =  100\ndim =  100 , n_integral_samples =  1 , rel err =  tensor(0.0177) , ls_iters =  1\ndim =  100 , n_integral_samples =  100 , rel err =  tensor(0.0026) , ls_iters =  1\ndim =  100 , n_integral_samples =  1000 , rel err =  tensor(0.0008) , ls_iters =  1\ndim =  100 , n_integral_samples =  10000 , rel err =  tensor(0.0003) , ls_iters =  1\n</pre> In\u00a0[34]: Copied! <pre>title_fontsize = 22\nfontsize       = 18\nfig1 = plt.figure()\n\ntitle_fontsize = 22\nfontsize       = 15\nmy_blue = '#1f77b4'\n\nplt.style.use('seaborn-whitegrid')\nax = plt.axes()\nfor i in range(len(dim_array)):\n  ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);\n\nax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize)\nax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1)\nax.tick_params(labelsize=fontsize, which='both', direction='in')\n\nsave_str = 'log_barrier_higher_dim_err_vs_samples.pdf'\nfig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0)\n</pre> title_fontsize = 22 fontsize       = 18 fig1 = plt.figure()  title_fontsize = 22 fontsize       = 15 my_blue = '#1f77b4'  plt.style.use('seaborn-whitegrid') ax = plt.axes() for i in range(len(dim_array)):   ax.semilogy(n_integral_samples_array, rel_errs_array[i,:], linewidth=3);  ax.set_xlabel(\"Number of Samples\", fontsize=title_fontsize) ax.legend(['dim 10', 'dim 25', 'dim 50', 'dim 75', 'dim 100'],fontsize=fontsize, loc=1) ax.tick_params(labelsize=fontsize, which='both', direction='in')  save_str = 'log_barrier_higher_dim_err_vs_samples.pdf' fig1.savefig(save_str, dpi=300 , bbox_inches=\"tight\", pad_inches=0.0) <pre>&lt;ipython-input-34-21601891ee5b&gt;:9: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"exp-prox-comparison/#approximate-proximals-and-moreau-envelopes","title":"Approximate Proximals and Moreau Envelopes\u00b6","text":"<p>The Proximal of $f$ is given by \\begin{equation}   \\text{prox}_{tf}(x) \\triangleq \\text{argmin}_{z\\in\\mathbb{R}^n} f(z) + \\dfrac{1}{2t}\\|z-x\\|^2, \\end{equation} and the Moreau envelope of $f$ is given by \\begin{equation}   u(x,t) \\triangleq \\inf_{z\\in \\mathbb{R}^n} f(z) + \\dfrac{1}{2t}\\|z-x\\|^2 \\end{equation}</p> <p>We leverage the fact that the solution to the Moreau envelope above satisfies the Hamilton-Jacobi Equation \\begin{equation}   \\begin{split}     u_t^\\delta  + \\frac{1}{2}\\|Du^\\delta  \\|^2 \\ = \\frac{\\delta}{2} \\Delta u^\\delta \\qquad &amp;\\text{ in }  \\mathbb{R}^n\\times (0,T]     \\\\     u = f \\qquad &amp;\\text{ in } \\mathbb{R}^n\\times \\{t = 0\\}   \\end{split} \\end{equation} when $\\delta = 0$.</p> <p>By adding a viscous term ($\\delta &gt; 0$), we are able to approximate the solution to the HJ equation using the Cole-Hopf formula to obtain \\begin{equation}   u^\\delta(x,t) = - \\delta \\ln\\Big(\\Phi_t * \\exp(-f/\\delta)\\Big)(x) = - \\delta \\ln \\int_{\\mathbb{R}^n} \\Phi(x-y,t)  \\exp\\left(\\frac{-f(y)}{\\delta}\\right) dy  \\end{equation} where \\begin{equation}   \\Phi(x,t) = \\frac{1}{{(4\\pi \\delta t)}^{n/2}} \\exp{\\frac{-\\|x\\|^2}{4\\delta t}}.  \\end{equation} This allows us to write the Moreau Envelope (and the proximal) explicitly as an expectation. In particular, we obtain \\begin{equation}   \\text{prox}_{tf}(x) = \\dfrac{\\mathbb{E}_{y \\sim  \\mathcal{N}_{x, \\delta t I}}  \\left[y \\exp\\left(-\\delta^{-1}f(y)\\right) \\right]}{\\mathbb{E}_{y \\sim  \\mathcal{N}_{x, \\delta t I}}  \\left[\\exp\\left(-\\delta^{-1}f(y)\\right) \\right]}  \\end{equation} and \\begin{equation}   u(x,t) \\approx - \\delta \\ln \\mathbb{E}_{y \\sim  \\mathcal{N}_{x, \\delta t I}}  \\left[y \\exp\\left(-\\delta^{-1}f(y)\\right) \\right] \\end{equation}</p>"},{"location":"exp-prox-comparison/#approximate-prox-shrink-and-moreau-envelope-for-l1-norm","title":"Approximate Prox (Shrink) and Moreau Envelope for L1 Norm\u00b6","text":""},{"location":"exp-prox-comparison/#clean-l1-norm-proximalmoreau-computation","title":"Clean L1 Norm Proximal/Moreau Computation\u00b6","text":""},{"location":"exp-prox-comparison/#noisy-l1-norm-proximalmoreau-computation","title":"Noisy L1 Norm Proximal/Moreau Computation\u00b6","text":""},{"location":"exp-prox-comparison/#approximate-prox-and-moreau-envelope-for-quadratic-function","title":"Approximate Prox and Moreau Envelope for Quadratic Function\u00b6","text":""},{"location":"exp-prox-comparison/#noisy-quadratic-moreau-and-prox","title":"Noisy Quadratic Moreau and Prox\u00b6","text":""},{"location":"exp-prox-comparison/#approximate-prox-and-moreau-envelope-for-log-barrier","title":"Approximate Prox and Moreau Envelope for Log Barrier\u00b6","text":""},{"location":"exp-prox-comparison/#noisy-log-barrier","title":"Noisy Log Barrier\u00b6","text":""},{"location":"exp-prox-comparison/#nonconvex-moreau-envelopes-with-analytic-formulas","title":"Nonconvex Moreau Envelopes with Analytic Formulas\u00b6","text":""},{"location":"exp-prox-comparison/#convex-functions-with-unknown-proxes","title":"Convex Functions with Unknown Proxes\u00b6","text":""},{"location":"exp-prox-comparison/#high-dimensional-shrink-experiments","title":"High Dimensional Shrink Experiments\u00b6","text":""},{"location":"exp-prox-comparison/#high-dimensional-quadratic-experiments","title":"High Dimensional Quadratic Experiments\u00b6","text":""},{"location":"exp-prox-comparison/#high-dimensional-log-barrier-experiments","title":"High Dimensional Log Barrier Experiments\u00b6","text":""},{"location":"hj-prox/","title":"compute_prox","text":"<p>Estimate proximals from function value sampling via HJ-Prox Algorithm.</p> <p>The output estimates the proximal:</p> \\[     \\mathsf{prox_{tf}(x) = argmin_y \\ f(y) + \\dfrac{1}{2t} \\| y - x \\|^2,} \\] <p>where \\(\\mathsf{x}\\) = <code>x</code> is the input, \\(\\mathsf{t}\\)=<code>t</code> is the time parameter,  and \\(\\mathsf{f}\\)=<code>f</code> is the function of interest. The process for this is  as follows.</p> <ul> <li> Sample points \\(\\mathsf{y^i}\\) (via a Gaussian) about the input \\(\\mathsf{x}\\)</li> <li> Evaluate function \\(\\mathsf{f}\\) at each point \\(\\mathsf{y^i}\\)</li> <li> Estimate proximal by using softmax to combine the values for \\(\\mathsf{f(y^i)}\\) and \\(\\mathsf{y^i}\\) </li> </ul> Note <p>The computation for the proximal involves the exponential of a potentially large negative number, which can result in underflow in floating point arithmetic that renders a grossly inaccurate proximal calculation. To avoid this, the \"large negative number\" is reduced in size by using a smaller value of alpha, returning a result once the underflow is not considered significant (as defined by the tolerances \"tol\" and \"tol_underflow\"). Utilizing a scaling trick with proximals, this is mitigated by using recursive function calls.</p> Warning <p>Memory errors can occur if too many layers of recursion are used, which can happen with tiny delta and large f(x). </p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>tensor</code> <p>Input vector</p> required <code>t</code> <code>tensor</code> <p>Time &gt; 0</p> required <code>f</code> <code>Callable</code> <p>Function to minimize</p> required <code>delta</code> <code>float</code> <p>Smoothing parameter</p> <code>0.1</code> <code>int_samples</code> <code>int</code> <p>Number of samples in Monte Carlo sampling for integral</p> <code>100</code> <code>alpha</code> <code>float</code> <p>Scaling parameter for sampling variance</p> <code>1.0</code> <code>linesearch_iters</code> <code>int</code> <p>Number of steps used in recursion (used for numerical stability)</p> <code>0</code> <code>device</code> <code>string</code> <p>Device on which to store variables</p> <code>'cpu'</code> Shape <ul> <li>Input <code>x</code> is of size <code>(n, 1)</code> where <code>n</code> is the dimension of the space of interest</li> <li>The output <code>prox_term</code> also has size <code>(n, 1)</code></li> </ul> <p>Returns:</p> Name Type Description <code>prox_term</code> <code>tensor</code> <p>Estimate of the proximal of f at x</p> <code>linesearch_iters</code> <code>int</code> <p>Number of steps used in recursion (used for numerical stability)</p> <code>envelope</code> <code>tensor</code> <p>Value of envelope function (i.e. infimal convolution) at proximal</p> Example <p>Below is an exmaple for estimating the proximal of the L1 norm. Note the function must have inputs of size <code>(n_samples, n)</code>. <pre><code>    def f(x):\n        return torch.norm(x, dim=1, p=1) \n    n = 3\n    x = torch.randn(n, 1)\n    t = 0.1\n    prox_term, _, _ = compute_prox(x, t, f, delta=1e-1, int_samples=100)   \n</code></pre></p> Source code in <code>src/hj_prox.py</code> <pre><code>def compute_prox(x, t, f, delta=1e-1, int_samples=100, alpha=1.0, linesearch_iters=0, device='cpu'):\n    \"\"\" Estimate proximals from function value sampling via HJ-Prox Algorithm.\n\n        The output estimates the proximal:\n\n        $$\n            \\mathsf{prox_{tf}(x) = argmin_y \\ f(y) + \\dfrac{1}{2t} \\| y - x \\|^2,}\n        $$\n\n        where $\\mathsf{x}$ = `x` is the input, $\\mathsf{t}$=`t` is the time parameter, \n        and $\\mathsf{f}$=`f` is the function of interest. The process for this is \n        as follows.\n\n        - [x] Sample points $\\mathsf{y^i}$ (via a Gaussian) about the input $\\mathsf{x}$\n        - [x] Evaluate function $\\mathsf{f}$ at each point $\\mathsf{y^i}$\n        - [x] Estimate proximal by using softmax to combine the values for $\\mathsf{f(y^i)}$ and $\\mathsf{y^i}$            \n\n        Note: \n            The computation for the proximal involves the exponential of a potentially\n            large negative number, which can result in underflow in floating point\n            arithmetic that renders a grossly inaccurate proximal calculation. To avoid\n            this, the \"large negative number\" is reduced in size by using a smaller\n            value of alpha, returning a result once the underflow is not considered\n            significant (as defined by the tolerances \"tol\" and \"tol_underflow\").\n            Utilizing a scaling trick with proximals, this is mitigated by using\n            recursive function calls.\n\n        Warning:\n            Memory errors can occur if too many layers of recursion are used,\n            which can happen with tiny delta and large f(x). \n\n        Args:\n            x (tensor): Input vector\n            t (tensor): Time &gt; 0\n            f (Callable): Function to minimize\n            delta (float, optional): Smoothing parameter\n            int_samples (int, optional): Number of samples in Monte Carlo sampling for integral\n            alpha (float, optional): Scaling parameter for sampling variance\n            linesearch_iters (int, optional): Number of steps used in recursion (used for numerical stability)\n            device (string, optional): Device on which to store variables\n\n        Shape:\n            - Input `x` is of size `(n, 1)` where `n` is the dimension of the space of interest\n            - The output `prox_term` also has size `(n, 1)`\n\n        Returns:\n            prox_term (tensor): Estimate of the proximal of f at x\n            linesearch_iters (int): Number of steps used in recursion (used for numerical stability)\n            envelope (tensor): Value of envelope function (i.e. infimal convolution) at proximal\n\n        Example:\n            Below is an exmaple for estimating the proximal of the L1 norm. Note the function\n            must have inputs of size `(n_samples, n)`.\n            ```\n                def f(x):\n                    return torch.norm(x, dim=1, p=1) \n                n = 3\n                x = torch.randn(n, 1)\n                t = 0.1\n                prox_term, _, _ = compute_prox(x, t, f, delta=1e-1, int_samples=100)   \n            ```\n    \"\"\"\n    assert x.shape[1] == 1\n    assert x.shape[0] &gt;= 1\n\n    linesearch_iters +=1\n    standard_dev = np.sqrt(delta * t / alpha)\n    dim = x.shape[0]\n\n    y = standard_dev * torch.randn(int_samples, dim, device=device) + x.permute(1,0) # y has shape (n_samples, dim)\n    z = -f(y)*(alpha/delta)     # shape =  n_samples\n    w = torch.softmax(z, dim=0) # shape = n_samples \n\n    softmax_overflow = 1.0 - (w &lt; np.inf).prod()\n    if softmax_overflow:\n        alpha *= 0.5\n        return compute_prox(x, t, f, delta=delta, int_samples=int_samples, alpha=alpha,\n                            linesearch_iters=linesearch_iters, device=device)\n    else:\n        prox_term = torch.matmul(w.t(), y)\n        prox_term = prox_term.view(-1,1)\n\n    prox_overflow = 1.0 - (prox_term &lt; np.inf).prod()\n    assert not prox_overflow, \"Prox Overflowed\"\n\n    envelope = f(prox_term.view(1,-1)) + (1/(2*t)) * torch.norm(prox_term - x.permute(1,0), p=2)**2    \n    return prox_term, linesearch_iters, envelope\n</code></pre>"},{"location":"assets/temp/","title":"Temp","text":"<p>temp</p>"}]}